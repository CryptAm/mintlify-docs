---
title: "subscription.prepareCharge"
description: "Подготовить вызовы транзакций для списания средств с подписки"
---

Определено в [Base Account SDK](https://github.com/base/account-sdk)

<Info>
Функция `subscription.prepareCharge` подготавливает необходимые вызовы транзакций для списания средств с подписки. Она возвращает массив объектов данных вызовов для выполнения списания через `wallet_sendCalls` или `eth_sendTransaction`. Это дает вам программный контроль над тем, когда и как выполнять списания с подписок.
</Info>

## Параметры

<ParamField body="id" type="string" required>
Идентификатор подписки (хэш разрешения), возвращенный из subscribe().

**Формат:** `^0x[0-9a-fA-F]{64}$`
</ParamField>

<ParamField body="amount" type="string | 'max-remaining-charge'" required>
Сумма для списания (например, "10.50") или 'max-remaining-charge' для полной оставшейся суммы в текущем периоде.
</ParamField>

<ParamField body="testnet" type="boolean">
Должен соответствовать настройке testnet, использованной в исходном вызове subscribe. По умолчанию: false
</ParamField>

## Возвращает

<ResponseField name="result" type="PrepareChargeResult">
Массив вызовов транзакций для выполнения списания.

<Expandable title="Свойства PrepareChargeResult">
<ResponseField name="to" type="Address">
Адрес для вызова (адрес смарт-контракта).
</ResponseField>

<ResponseField name="data" type="Hex">
Закодированные данные вызова для транзакции.
</ResponseField>

<ResponseField name="value" type="'0x0'">
Значение для отправки (всегда 0x0 для разрешений на расходы).
</ResponseField>
</Expandable>
</ResponseField>

Возвращаемый массив содержит:
- Вызов одобрения (если разрешение еще не активно)
- Вызов списания средств с подписки

<RequestExample>
```typescript EOA Owner Wallet
import { base } from '@base-org/account';
import { createWalletClient, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { base as baseChain } from 'viem/chains';

// Инициализировать клиент кошелька с вашим аккаунтом владельца подписки
const account = privateKeyToAccount('0x...'); // Your app's private key
const walletClient = createWalletClient({
  account,
  chain: baseChain,
  transport: http()
});

// Подготовить списание конкретной суммы
const chargeCalls = await base.subscription.prepareCharge({
  id: '0x71319cd488f8e4f24687711ec5c95d9e0c1bacbf5c1064942937eba4c7cf2984',
  amount: '9.99',
  testnet: false
});

// Выполнить каждый вызов списания
const transactionHashes = [];

for (const call of chargeCalls) {
  const hash = await walletClient.sendTransaction({
    to: call.to,
    data: call.data,
    value: call.value || 0n
  });
  
  transactionHashes.push(hash);
  
  // Подождать подтверждения транзакции перед следующим вызовом
  await walletClient.waitForTransactionReceipt({ hash });
}

console.log(`Charge transactions: ${transactionHashes.join(', ')}`);
```

```typescript Smart Owner Wallet
import { base } from '@base-org/account';
import { createPublicClient, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { base as baseChain } from 'viem/chains';
import { toCoinbaseSmartAccount, createBundlerClient } from 'viem/account-abstraction';

// Создать публичный клиент
const publicClient = createPublicClient({
  chain: baseChain,
  transport: http()
});

// Преобразовать приватный ключ в аккаунт владельца
const owner = privateKeyToAccount('0x...'); // Your app's private key

// Создать Coinbase Smart Wallet аккаунт из владельца
const smartAccount = await toCoinbaseSmartAccount({
  client: publicClient,
  owners: [owner],
  version: '1'
});

// Создать клиент бандлера для отправки UserOperations
const bundlerClient = createBundlerClient({
  account: smartAccount,
  chain: baseChain,
  client: publicClient,
  transport: http('your-bundler-url') // URL вашего бандлера
});

// Подготовить списание максимальной доступной суммы
const chargeCalls = await base.subscription.prepareCharge({
  id: subscriptionId,
  amount: 'max-remaining-charge',
  testnet: false
});

// Отправить UserOperation через бандлер
const userOpHash = await bundlerClient.sendUserOperation({
  calls: chargeCalls
});

// Подождать включения UserOperation
const receipt = await bundlerClient.waitForUserOperationReceipt({
  hash: userOpHash
});

console.log(`Charge bundled in transaction: ${receipt.receipt.transactionHash}`);
```
</RequestExample>

<ResponseExample>
```typescript Two Calls (Approval + Spend)
[
  {
    to: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    data: "0x095ea7b3...",
    value: "0x0"
  },
  {
    to: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    data: "0xa9059cbb...",
    value: "0x0"
  }
]
```
```typescript Single Call (Spend Only)
[
  {
    to: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    data: "0xa9059cbb...",
    value: "0x0"
  }
]
```
</ResponseExample>

## Обработка ошибок

```typescript
try {
  const chargeCalls = await base.subscription.prepareCharge({
    id: subscriptionId,
    amount: chargeAmount,
    testnet: false
  });
  // Выполнить списание
} catch (error) {
  console.error(`Failed to prepare charge: ${error.message}`);
}
```

import PolicyBanner from "/snippets/PolicyBanner.mdx";

<PolicyBanner />
