---
title: "auxiliaryFunds"
description: "Указывает на доступ кошелька к средствам за пределами проверки баланса в блокчейне"
---

Определено в [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792)

<Info>
Возможность auxiliaryFunds позволяет кошелькам указывать, что у них есть доступ к средствам, выходящим за пределы того, что можно напрямую проверить в блокчейне по адресу кошелька. Это обеспечивает более гибкое выполнение транзакций и улучшенный пользовательский опыт.
</Info>

<Warning>
Эта возможность еще не окончательна и может измениться в будущих итерациях.
</Warning>

## Параметры

У этой возможности нет параметров конфигурации. Она либо поддерживается, либо не поддерживается кошельком.

## Возвращает

<ResponseField name="auxiliaryFunds" type="object">
Конфигурация возможности вспомогательных средств (auxiliary funds) для указанной цепочки.

<Expandable title="Свойства возможности auxiliaryFunds">
<ResponseField name="supported" type="boolean">
Указывает, имеет ли кошелек доступ к вспомогательным источникам финансирования за пределами баланса в блокчейне.
</ResponseField>
</Expandable>
</ResponseField>

## Пример использования

<RequestExample>
```typescript Check Auxiliary Funds Support
const capabilities = await provider.request({
  method: 'wallet_getCapabilities',
  params: [userAddress]
});

const auxiliaryFunds = capabilities["0x2105"]?.auxiliaryFunds;
```

```typescript Balance Check with Auxiliary Funds
if (auxiliaryFunds?.supported) {
  // Не блокировать транзакции только на основе видимого баланса
  console.log("Wallet has access to auxiliary funds");
} else {
  // Проверять баланс в блокчейне перед разрешением транзакций
  const balance = await provider.request({
    method: 'eth_getBalance',
    params: [userAddress, 'latest']
  });
}
```
</RequestExample>

<ResponseExample>
```json Capability Response (Supported)
{
  "0x2105": {
    "auxiliaryFunds": {
      "supported": true
    }
  }
}
```

```json Capability Response (Unsupported)
{
  "0x2105": {
    "auxiliaryFunds": {
      "supported": false
    }
  }
}
```
</ResponseExample>

## Обработка ошибок

| Код | Сообщение | Описание |
| --- | --------- | -------- |
| 4100 | Auxiliary funds not supported | Кошелек не поддерживает вспомогательные источники финансирования |
| 4200 | Auxiliary funds unavailable | Вспомогательные источники финансирования временно недоступны |
| 4300 | Insufficient auxiliary funds | Вспомогательные средства существуют, но недостаточны для транзакции |

## Реализация в кошельке

Кошельки, поддерживающие вспомогательные средства, должны включать эту возможность в свой ответ:

```typescript
// Ответ кошелька на wallet_getCapabilities
{
  "0x2105": { // Base mainnet
    "auxiliaryFunds": {
      "supported": true
    }
  }
}
```

## Поведение приложения

Приложения должны изменять свою логику проверки баланса, когда поддерживаются вспомогательные средства:

### Без вспомогательных средств

```typescript
async function checkCanExecuteTransaction(amount: bigint) {
  const balance = await provider.request({
    method: 'eth_getBalance',
    params: [userAddress, 'latest']
  });
  
  if (BigInt(balance) < amount) {
    throw new Error("Insufficient balance");
  }
  
  return true;
}
```

### С поддержкой вспомогательных средств

```typescript
async function checkCanExecuteTransaction(amount: bigint) {
  const capabilities = await provider.request({
    method: 'wallet_getCapabilities',
    params: [userAddress]
  });
  
  if (capabilities["0x2105"]?.auxiliaryFunds?.supported) {
    //Кошелек может иметь доступ к вспомогательным средствам, разрешаем транзакцию
    console.log("Auxiliary funds available, proceeding with transaction");
    return true;
  }
  
  // Проверяем баланс в блокчейне как откат
  const balance = await provider.request({
    method: 'eth_getBalance', 
    params: [userAddress, 'latest']
  });
  
  if (BigInt(balance) < amount) {
    throw new Error("Insufficient balance");
  }
  
  return true;
}
```

## Сценарии использования

### DeFi-приложения

Включение DeFi-операций даже когда баланс кошелька кажется недостаточным:

```typescript
class DeFiManager {
  async executeSwap(fromToken: string, toToken: string, amount: string) {
    const capabilities = await provider.request({
      method: 'wallet_getCapabilities',
      params: [userAddress]
    });
    
    const hasAuxiliaryFunds = capabilities["0x2105"]?.auxiliaryFunds?.supported;
    
    if (!hasAuxiliaryFunds) {
      // Проверяем баланс токена для кошельков без вспомогательных средств
      const tokenBalance = await this.getTokenBalance(fromToken, userAddress);
      if (BigInt(tokenBalance) < BigInt(amount)) {
        throw new Error("Insufficient token balance");
      }
    }
    
    // Продолжаем обмен
    return provider.request({
      method: 'wallet_sendCalls',
      params: [{
        version: "1.0",
        chainId: "0x2105",
        from: userAddress,
        calls: [{
          to: swapContractAddress,
          value: "0x0",
          data: this.encodeSwap(fromToken, toToken, amount)
        }]
      }]
    });
  }
  
  private async getTokenBalance(token: string, account: string): Promise<string> {
    // Реализация проверки баланса токена ERC-20
    return "0";
  }
  
  private encodeSwap(from: string, to: string, amount: string): string {
    // Реализация кодирования данных вызова обмена
    return "0x";
  }
}
```

### E-commerce приложения

Разрешение покупок без блокировки из-за видимого баланса:

```typescript
class PaymentProcessor {
  async processPurchase(amount: bigint, currency: string) {
    const capabilities = await provider.request({
      method: 'wallet_getCapabilities',
      params: [userAddress]
    });
    
    if (capabilities["0x2105"]?.auxiliaryFunds?.supported) {
      // Кошелек может получить доступ к средствам через вспомогательные источники
      console.log("Processing payment with auxiliary funds support");
      
      return this.executePurchase(amount, currency);
    } else {
      // Проверяем достаточность баланса для обычных кошельков
      const balance = await this.getCurrencyBalance(currency, userAddress);
      
      if (balance < amount) {
        throw new Error(`Insufficient ${currency} balance`);
      }
      
      return this.executePurchase(amount, currency);
    }
  }
  
  private async executePurchase(amount: bigint, currency: string) {
    return provider.request({
      method: 'wallet_sendCalls',
      params: [{
        version: "1.0",
        chainId: "0x2105",
        from: userAddress,
        calls: [{
          to: paymentContractAddress,
          value: currency === "ETH" ? `0x${amount.toString(16)}` : "0x0",
          data: currency === "ETH" ? "0x" : this.encodeTokenTransfer(currency, amount)
        }]
      }]
    });
  }
  
  private async getCurrencyBalance(currency: string, account: string): Promise<bigint> {
    if (currency === "ETH") {
      const balance = await provider.request({
        method: 'eth_getBalance',
        params: [account, 'latest']
      });
      return BigInt(balance);
    } else {
      // Получаем баланс токена ERC-20
      const balance = await this.getTokenBalance(currency, account);
      return BigInt(balance);
    }
  }
  
  private encodeTokenTransfer(token: string, amount: bigint): string {
    // Реализация кодирования передачи токена
    return "0x";
  }
  
  private async getTokenBalance(token: string, account: string): Promise<string> {
    // Реализация проверки баланса токена
    return "0";
  }
}
```

### Игровые приложения

Включение внутриигровых покупок без ограничений по балансу:

```typescript
class GamePurchaseManager {
  async buyGameItem(itemId: string, price: bigint) {
    const capabilities = await provider.request({
      method: 'wallet_getCapabilities',
      params: [userAddress]
    });
    
    // Не проверяем баланс, если поддерживаются вспомогательные средства
    if (!capabilities["0x2105"]?.auxiliaryFunds?.supported) {
      await this.validateBalance(price);
    }
    
    return provider.request({
      method: 'wallet_sendCalls',
      params: [{
        version: "1.0",
        chainId: "0x2105",
        from: userAddress,
        calls: [{
          to: gameContractAddress,
          value: "0x0",
          data: this.encodePurchaseItem(itemId, price)
        }]
      }]
    });
  }
  
  private async validateBalance(requiredAmount: bigint) {
    const balance = await provider.request({
      method: 'eth_getBalance',
      params: [userAddress, 'latest']
    });
    
    if (BigInt(balance) < requiredAmount) {
      throw new Error("Insufficient balance for purchase");
    }
  }
  
  private encodePurchaseItem(itemId: string, price: bigint): string {
    // Реализация кодирования покупки игрового предмета
    return "0x";
  }
}
```

## Обработка ошибок

Обрабатывайте сценарии, связанные со вспомогательными средствами:

```typescript
async function executeTransactionWithAuxiliarySupport(calls: any[]) {
  try {
    const result = await provider.request({
      method: 'wallet_sendCalls',
      params: [{
        version: "1.0",
        chainId: "0x2105", 
        from: userAddress,
        calls
      }]
    });
    
    return result;
    
  } catch (error) {
    if (error.message.includes("insufficient funds")) {
      const capabilities = await provider.request({
        method: 'wallet_getCapabilities',
        params: [userAddress]
      });
      
      if (capabilities["0x2105"]?.auxiliaryFunds?.supported) {
        console.log("Transaction failed despite auxiliary funds support");
        // Может указывать на временную недоступность вспомогательных средств
        throw new Error("Payment method temporarily unavailable");
      } else {
        throw new Error("Insufficient balance");
      }
    }
    
    throw error;
  }
}
```

## Рекомендации

1. **Плавная деградация**: Всегда обеспечивайте откат на проверку баланса для кошельков без вспомогательных средств
2. **Четкая коммуникация**: Информируйте пользователей, когда используются вспомогательные средства
3. **Обработка ошибок**: Обрабатывайте случаи, когда вспомогательные средства могут быть временно недоступны
4. **Безопасность**: Не предполагайте, что вспомогательные средства всегда доступны

<Info>
Возможность вспомогательных средств улучшает пользовательский опыт, позволяя выполнять транзакции, которые в противном случае были бы заблокированы из-за недостаточного видимого баланса.
</Info>

<Warning>
Приложения все равно должны реализовывать правильную обработку ошибок, так как вспомогательные средства могут быть не всегда доступны или достаточны.
</Warning>

## Связанные возможности

Вспомогательные средства хорошо работают с другими возможностями:

- **[Сервис Paymaster](/base-account/reference/core/capabilities/paymasterService)**: Для спонсируемых транзакций
- **[Атомарность (Atomic)](/base-account/reference/core/capabilities/atomic)**: Для обеспечения успеха транзакций со вспомогательными средствами
- **[Управление потоком (Flow Control)](/base-account/reference/core/capabilities/flowControl)**: Для обработки сбоев вспомогательных средств

import PolicyBanner from "/snippets/PolicyBanner.mdx";

<PolicyBanner />
