---
title: useClose
description: Программное закрытие фрейма мини-приложения
---

Определен в [@coinbase/onchainkit](https://github.com/coinbase/onchainkit)

<Info>
Позволяет мини-приложениям закрываться программно. Полезно для процессов завершения, действий отмены или после успешных операций.
</Info>

## Возвращает

<ResponseField name="close" type="() => void">
Функция, которая закрывает фрейм мини-приложения и возвращает пользователя в хост-приложение.
</ResponseField>

<RequestExample>
```tsx components/CloseButton.tsx
import { useClose } from '@coinbase/onchainkit/minikit';

export default function CloseButton() {
  const close = useClose();

  return (
    <button onClick={close} className="close-btn">
      ✕ Close
    </button>
  );
}
```

```tsx components/PurchaseFlow.tsx
import { useClose } from '@coinbase/onchainkit/minikit';
import { useState } from 'react';

export default function PurchaseFlow() {
  const close = useClose();
  const [isComplete, setIsComplete] = useState(false);

  const handlePurchase = async () => {
    try {
      await processPurchase();
      setIsComplete(true);
      
      // Автоматическое закрытие после успешной покупки
      setTimeout(() => {
        close();
      }, 2000);
    } catch (error) {
      console.error('Purchase failed:', error);
    }
  };

  if (isComplete) {
    return (
      <div className="success-screen">
        <h2>✅ Purchase Complete!</h2>
        <p>Closing in 2 seconds...</p>
        <button onClick={close}>Close Now</button>
      </div>
    );
  }

  return (
    <div className="purchase-flow">
      <button onClick={handlePurchase}>Complete Purchase</button>
      <button onClick={close}>Cancel</button>
    </div>
  );
}
```

```tsx components/ConfirmClose.tsx
import { useClose } from '@coinbase/onchainkit/minikit';
import { useState } from 'react';

export default function ConfirmClose() {
  const close = useClose();
  const [showConfirm, setShowConfirm] = useState(false);

  const handleCloseRequest = () => {
    setShowConfirm(true);
  };

  const confirmClose = () => {
    // Сохраните любые ожидающие данные
    savePendingChanges();
    close();
  };

  if (showConfirm) {
    return (
      <div className="confirm-dialog">
        <h3>Close Mini App?</h3>
        <p>Any unsaved changes will be lost.</p>
        <div className="actions">
          <button onClick={confirmClose}>Yes, Close</button>
          <button onClick={() => setShowConfirm(false)}>Cancel</button>
        </div>
      </div>
    );
  }

  return (
    <div className="app-content">
      <button onClick={handleCloseRequest}>Exit</button>
      {/* Your app content */}
    </div>
  );
}
```
</RequestExample>

## Паттерны использования

### Процессы завершения
Автоматически закрывайте после успешных операций:

```tsx components/CompletionFlow.tsx
const handleGameComplete = async () => {
  await saveScore(finalScore);
  
  // Показать экран завершения ненадолго
  setShowCompletion(true);
  
  // Автоматически закрыть после празднования
  setTimeout(close, 3000);
};
```

### Замена навигации
Используйте закрытие вместо навигации для простых процессов:

```tsx components/NavigationReplacement.tsx
// Вместо возврата назад закройте фрейм
const handleCancel = () => {
  if (hasUnsavedChanges) {
    confirmAndClose();
  } else {
    close();
  }
};
```

### Восстановление после ошибок
Предоставьте пути для выхода из состояний ошибки:

```tsx components/ErrorScreen.tsx
if (hasUnrecoverableError) {
  return (
    <div className="error-screen">
      <h2>Something went wrong</h2>
      <p>Please try again later</p>
      <button onClick={close}>Close</button>
    </div>
  );
}
```

## Рекомендации

### Пользовательский опыт
- **Подтверждайте важные действия**: Спрашивайте перед закрытием, если у пользователя есть несохраненная работа
- **Предоставляйте обратную связь**: Показывайте состояния завершения перед автоматическим закрытием
- **Быстрый выход**: Всегда предоставляйте способ закрытия, особенно в состояниях ошибки

### Технические соображения
- **Сохраняйте состояние**: Сохраняйте важные данные перед закрытием
- **Очищайте ресурсы**: Отменяйте ожидающие запросы или таймеры
- **Аналитика**: Отслеживайте события закрытия для получения инсайтов о UX

```tsx components/HandleClose.tsx
const handleClose = () => {
  // Очистка
  cancelPendingRequests();
  clearIntervals();
  
  // Отслеживание аналитики
  analytics.track('mini_app_closed', {
    session_duration: Date.now() - sessionStart,
    completion_state: currentState
  });
  
  // Закрытие
  close();
};
```

<Info>
`useClose` обеспечивает аккуратный выход для мини-приложений. Используйте его обдуманно, чтобы создавать отполированные пользовательские интерфейсы, которые выглядят нативно в потоке хост-приложения.
</Info>


