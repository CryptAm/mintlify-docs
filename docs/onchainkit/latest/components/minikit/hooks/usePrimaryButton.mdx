---
title: usePrimaryButton
description: Настройка и обработка постоянной основной кнопки
---

Определен в [@coinbase/onchainkit](https://github.com/coinbase/onchainkit)

<Info>
Настраивает постоянную основную кнопку, которая появляется в нижней части фрейма мини-приложения. Идеально подходит для глобальных действий, которые всегда должны быть доступны.
</Info>

## Параметры

<ParamField body="options" type="SetPrimaryButtonOptions" required>
Объект конфигурации для внешнего вида и поведения основной кнопки.

<Expandable title="Свойства SetPrimaryButtonOptions">
<ParamField body="text" type="string" required>
Текст для отображения на основной кнопке.
</ParamField>
</Expandable>
</ParamField>

<ParamField body="callback" type="() => void" required>
Функция для выполнения при нажатии на основную кнопку.
</ParamField>

<RequestExample>
```tsx components/GameComponent.tsx
import { usePrimaryButton } from '@coinbase/onchainkit/minikit';
import { useState } from 'react';

enum GameState {
  RUNNING = 'running',
  PAUSED = 'paused',
  STOPPED = 'stopped'
}

export default function GameComponent() {
  const [gameState, setGameState] = useState(GameState.STOPPED);

  // Настройка основной кнопки в зависимости от состояния игры
  usePrimaryButton(
    { 
      text: gameState === GameState.RUNNING ? 'PAUSE GAME' : 'START GAME' 
    },
    () => {
      setGameState(
        gameState === GameState.RUNNING 
          ? GameState.PAUSED 
          : GameState.RUNNING
      );
    }
  );

  return (
    <div className="game-container">
      <h2>Game Status: {gameState}</h2>
      {/* Game content */}
    </div>
  );
}
```

```tsx components/FormComponent.tsx
import { usePrimaryButton } from '@coinbase/onchainkit/minikit';
import { useState } from 'react';

export default function FormComponent() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  const [isValid, setIsValid] = useState(false);

  // Динамический текст кнопки и действие в зависимости от состояния формы
  usePrimaryButton(
    { 
      text: isValid ? 'Submit Form' : 'Complete Form First' 
    },
    () => {
      if (isValid) {
        handleSubmit();
      } else {
        // Фокус на первое пустое поле
        focusFirstEmptyField();
      }
    }
  );

  const handleSubmit = async () => {
    await fetch('/api/submit', {
      method: 'POST',
      body: JSON.stringify(formData)
    });
  };

  return (
    <form>
      <input 
        value={formData.name}
        onChange={(e) => {
          setFormData({ ...formData, name: e.target.value });
          setIsValid(e.target.value && formData.email);
        }}
        placeholder="Name"
      />
      <input 
        value={formData.email}
        onChange={(e) => {
          setFormData({ ...formData, email: e.target.value });
          setIsValid(formData.name && e.target.value);
        }}
        placeholder="Email"
      />
    </form>
  );
}
```

```tsx components/CheckoutComponent.tsx
import { usePrimaryButton } from '@coinbase/onchainkit/minikit';
import { useState } from 'react';

export default function CheckoutComponent() {
  const [step, setStep] = useState('cart'); // cart, shipping, payment, complete

  const getButtonConfig = () => {
    switch (step) {
      case 'cart':
        return { text: 'Proceed to Shipping', action: () => setStep('shipping') };
      case 'shipping':
        return { text: 'Proceed to Payment', action: () => setStep('payment') };
      case 'payment':
        return { text: 'Complete Purchase', action: () => processPurchase() };
      case 'complete':
        return { text: 'Continue Shopping', action: () => setStep('cart') };
      default:
        return { text: 'Next', action: () => {} };
    }
  };

  const config = getButtonConfig();

  usePrimaryButton(
    { text: config.text },
    config.action
  );

  const processPurchase = async () => {
    // Логика обработки покупки
    setStep('complete');
  };

  return (
    <div className="checkout-flow">
      <h2>Step: {step}</h2>
      {/* Контент, специфичный для шага */}
    </div>
  );
}
```
</RequestExample>

## Паттерны использования

### Управление глобальным состоянием
Основная кнопка идеально подходит для действий, которые влияют на все приложение:

```tsx components/GlobalStateExamples.tsx
// Управление игрой
usePrimaryButton(
  { text: isPlaying ? 'Pause' : 'Play' },
  toggleGameState
);

// Управление модальным окном
usePrimaryButton(
  { text: 'Close' },
  closeModal
);
```

### Отправка формы
Используйте для основных действий формы:

```tsx components/FormSubmit.tsx
usePrimaryButton(
  { text: isValid ? 'Submit' : 'Complete Required Fields' },
  handleFormSubmission
);
```

### Многошаговые процессы
Навигация по сложным рабочим процессам:

```tsx components/MultiStepFlow.tsx
usePrimaryButton(
  { text: getStepButtonText(currentStep) },
  () => advanceToNextStep()
);
```

## Рекомендации

### Рекомендации по тексту кнопки
- **Делайте ориентированным на действие**: "Начать игру", "Отправить заказ", "Продолжить"
- **Будьте конкретны**: "Сохранить изменения" вместо общего "Отправить"
- **Указывайте состояние**: "Пауза" во время игры, "Продолжить" на паузе
- **Будьте краткими**: Стремитесь к 1-3 словам, когда это возможно

### Соображения по макету
- Основная кнопка появляется в нижней части фрейма
- **Не дублируйте действия**: Избегайте наличия того же действия в виде кнопки в контенте
- **Учитывайте мобильные устройства**: Кнопка оптимизирована для доступности большим пальцем
- **Тестируйте на разных клиентах**: Внешний вид кнопки может отличаться между клиентами Farcaster

### Советы по производительности
- **Мемоизируйте колбэки**: Используйте useCallback для сложных обработчиков кнопок
- **Избегайте частых изменений**: Не обновляйте текст кнопки при каждом рендере
- **Группируйте обновления состояния**: Обновляйте конфигурацию кнопки и состояние приложения вместе

```tsx components/HandlePrimaryAction.tsx
import { useCallback } from 'react';

const handlePrimaryAction = useCallback(() => {
  // Ресурсоемкая операция
  performComplexAction();
}, [dependencies]);

usePrimaryButton(
  { text: 'Process Data' },
  handlePrimaryAction
);
```

<Warning>
Основная кнопка сохраняется на протяжении всей сессии вашего мини-приложения. Используйте `usePrimaryButton` только один раз в дереве компонентов, чтобы избежать конфликтов.
</Warning>

<Info>
Основная кнопка предоставляет нативный, доступный способ отображения вашего самого важного действия. Она особенно эффективна для игр, форм и многошаговых рабочих процессов, где пользователям нужен постоянный доступ к следующему действию.
</Info>


