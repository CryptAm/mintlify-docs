---
title: "Интеграция Wagmi & Viem"
---

OnchainKit автоматически настраивает провайдеры Wagmi и TanStack Query за вас. Однако вы можете предоставить свою собственную кастомную конфигурацию Wagmi для продвинутых случаев использования, таких как кастомные коннекторы, цепи или настройки хранения.

## Настройка по умолчанию

По умолчанию OnchainKitProvider обрабатывает всю настройку провайдеров внутри себя:

```tsx
<OnchainKitProvider
  apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
  chain={base}
>
  {children}
</OnchainKitProvider>
```

Это автоматически включает:

- Конфигурацию Wagmi с коннектором Coinbase Wallet
- TanStack Query клиент для кэширования
- Оптимизированные настройки по умолчанию для большинства приложений

## Кастомная конфигурация Wagmi

Для продвинутого контроля над коннекторами кошельков, цепями или другими настройками Wagmi оберните OnchainKitProvider своими собственными провайдерами Wagmi:

<CodeGroup>

```tsx wagmi.ts
import { http, cookieStorage, createConfig, createStorage } from 'wagmi';
import { base, baseSepolia } from 'viem/chains';
import { coinbaseWallet, metaMask } from 'wagmi/connectors';

export function getConfig() {
  return createConfig({
    chains: [base, baseSepolia],
    connectors: [
      coinbaseWallet({
        appName: 'My OnchainKit App',
        preference: 'smartWalletOnly',
        version: '4',
      }),
      metaMask(), // Добавьте дополнительные коннекторы
    ],
    storage: createStorage({
      storage: cookieStorage,
    }),
    ssr: true,
    transports: {
      [base.id]: http(),
      [baseSepolia.id]: http(),
    },
  });
}

declare module 'wagmi' {
  interface Register {
    config: ReturnType<typeof getConfig>;
  }
}
```

```tsx providers.tsx
import { OnchainKitProvider } from '@coinbase/onchainkit';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { base } from 'viem/chains';
import { type ReactNode, useState } from 'react';
import { type State, WagmiProvider } from 'wagmi';
import { getConfig } from './wagmi';

export function Providers(props: {
  children: ReactNode;
  initialState?: State;
}) {
  const [config] = useState(() => getConfig());
  const [queryClient] = useState(() => new QueryClient());

  return (
    <WagmiProvider config={config} initialState={props.initialState}>
      <QueryClientProvider client={queryClient}>
        <OnchainKitProvider
          apiKey={process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY}
          chain={base}
        >
          {props.children}
        </OnchainKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

</CodeGroup>

## Когда использовать кастомную конфигурацию

Рассмотрите возможность использования кастомной конфигурации Wagmi, когда вам нужно:

- **Несколько цепей** помимо основной цепи
- **Продвинутое кэширование** с кастомными настройками QueryClient
- **Поддержка SSR** с хранением на основе кук
- **Кастомные транспорты** или RPC-конфигурации

## Распространенные паттерны

### Поддержка нескольких цепей

```tsx wagmi.ts
import { base, mainnet, optimism } from 'viem/chains';

export function getConfig() {
  return createConfig({
    chains: [base, mainnet, optimism],
    // ... другая конфигурация
    transports: {
      [base.id]: http(),
      [mainnet.id]: http(),
      [optimism.id]: http(),
    },
  });
}
```

### Кастомный Query Client

```tsx providers.tsx
const [queryClient] = useState(() => new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
    },
  },
}));
```

### Конфигурация в зависимости от окружения

```tsx wagmi.ts
const isDevelopment = process.env.NODE_ENV === 'development';

export function getConfig() {
  return createConfig({
    chains: isDevelopment ? [baseSepolia] : [base],
    // ... настройки для разработки и продакшена
  });
}
```

## Важные замечания

- Всегда размещайте кастомные провайдеры Wagmi и Query вне OnchainKitProvider
- Компоненты OnchainKit будут автоматически использовать вашу кастомную конфигурацию Wagmi
- Пропс chain в OnchainKitProvider должен соответствовать вашей основной цепи
- Кастомные конфигурации требуют дополнительной настройки, но предоставляют максимальную гибкость
