---
title: Наследование
description: Узнайте, как использовать наследование для переноса функциональности из одного контракта в другой.
hide_table_of_contents: false
sidebarTitle: Пошаговое руководство
---

Solidity - это объектно-ориентированный язык. Контракты могут наследовать друг от друга, что позволяет эффективно повторно использовать код.

---

## Цели

К концу этого урока вы сможете:

- Написать смарт-контракт, который наследует от другого контракта
- Описать влияние наследования на ограничение размера байт-кода

---

## Наследование

Создайте новый файл контракта в Remix под названием `Inheritance.sol` и добавьте два простых контракта, каждый с функцией, идентифицирующей, какой контракт ее вызвал:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

contract ContractB {
    function whoAmI() external pure returns (string memory) {
        return "contract B";
    }
}

contract ContractA {
    function whoAmI() external pure returns (string memory) {
        return "contract A";
    }
}
```

`ContractA` говорит, что это "contract A", а `ContractB` говорит, что это "contract B".

### Наследование от другого контракта

[Inheritance] между контрактами обозначается ключевым словом `is` в объявлении контракта. Обновите `ContractA` так, чтобы он `is` `ContractB`, и удалите функцию `whoAmI` из `ContractA`.

<Accordion title="Показать код">

```solidity
contract ContractB {
    function whoAmI() external pure returns (string memory) {
        return "contract B";
    }
}

contract ContractA is ContractB {

}
```

</Accordion>

Разверните и протестируйте снова. Несмотря на то, что в `ContractA` нет никаких функций, развертывание все равно показывает кнопку для вызова `whoAmI`. Вызовите ее. Теперь `ContractA` сообщает, что это "contract B", из-за наследования функции от `Contract B`.

### Внутренние функции и наследование

Контракты могут вызывать `internal` функции контрактов, от которых они наследуют. Добавьте `internal` функцию в `ContractB` с именем `whoAmIInternal`, которая возвращает "contract B".

Добавьте внешнюю функцию `whoAmIExternal`, которая возвращает результат вызова `whoAmIInternal`.

<Accordion title="Показать код">

```solidity
contract ContractB {
    function whoAmI() external pure returns (string memory) {
        return "contract B";
    }

    function whoAmIInternal() internal pure returns (string memory) {
        return "contract B";
    }
}

contract ContractA is ContractB {
    function whoAmExternal() external pure returns (string memory) {
        return whoAmIInternal();
    }
}
```

</Accordion>

Разверните и протестируйте. Обратите внимание, что в развертывании `ContractB`, функция `whoAmIInternal` **не** доступна, так как она является `internal`. Однако вызов `whoAmIExternal` может вызвать `internal` функцию и вернуть ожидаемый результат "contract B".

### Internal vs. Private

Вы не можете вызвать `private` функцию из контракта, который наследует от контракта, содержащего эту функцию.

```solidity
// Пример плохого кода, не используйте
contract ContractB {
    function whoAmIPrivate() private pure returns (string memory) {
        return "contract B";
    }
}

contract ContractA is ContractB {
    function whoAmExternal() external pure returns (string memory) {
        return whoAmIPrivate();
    }
}
```

Компилятор выдаст ошибку:

```text
from solidity:
DeclarationError: Undeclared identifier.
  --> contracts/Inheritance.sol:17:16:
   |
17 |         return whoAmIPrivate();
   |                ^^^^^^^^^^^^^
```

### Наследование и размер контракта

Контракт, который наследует от другого контракта, будет включать байт-код этого контракта в свой собственный. Вы можете увидеть это, открыв настройки в Remix и снова включив _Artifact Generation_. Байт-код для каждого скомпилированного контракта будет присутствовать в JSON-файле с именем этого контракта в папке `artifacts` folder.

Любой пустой контракт:

```solidity
contract EmptyContract {

}
```

Скомпилируется во что-то подобное:

```text
6080604052600080fdfea2646970667358221220df894b82f904e22617d7e40150306e2d2e8cb2ca5dcacb666a0c3d40f5f988c464736f6c63430008110033
```

Немного более сложный контракт:

```solidity
contract notEmptyContract {
    function sayHello() public pure returns (string memory) {
        return "To whom it may concern, I write you after a long period of silence to alert you that after much reflection, it occurs to me that I don't think you have fully considered...";
    }
}
```

Будет иметь более сложный байт-код. В данном случае в основном для хранения длинной строки в возвращаемом значении:

```text
608060405234801561001057600080fd5b50610201806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063ef5fb05b14610030575b600080fd5b61003861004e565b60405161004591906100fe565b60405180910390f35b60606040518060e0016040528060ab815260200161012160ab9139905090565b600081519050919050565b600082825260208201905092915050565b60005b838110156100a857808201518184015260208101905061008d565b60008484015250505050565b6000601f19601f8301169050919050565b60006100d08261006e565b6100da8185610079565b93506100ea81856020860161008a565b6100f3816100b4565b840191505092915050565b6000602082019050818103600083015261011881846100c5565b90509291505056fe546f2077686f6d206974206d617920636f6e6365726e2c204920777269746520796f752061667465722061206c6f6e6720706572696f64206f662073696c656e636520746f20616c65727420796f752074686174206166746572206d756368207265666c656374696f6e2c206974206f636375727320746f206d652074686174204920646f6e2774207468696e6b20796f7520686176652066756c6c7920636f6e736964657265642e2e2ea264697066735822122058d68a2853aaa473c9a5ff4dba0cc94657cb2a5a87ce3a986090a7ab991055a464736f6c63430008110033
```

Однако, если пустой контракт наследует от непустого контракта:

```solidity
contract EmptyContract is notEmptyContract {

}
```

Результирующий байт-код будет включать байт-код унаследованного контракта:

```text
608060405234801561001057600080fd5b50610201806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063ef5fb05b14610030575b600080fd5b61003861004e565b60405161004591906100fe565b60405180910390f35b60606040518060e0016040528060ab815260200161012160ab9139905090565b600081519050919050565b600082825260208201905092915050565b60005b838110156100a857808201518184015260208101905061008d565b60008484015250505050565b6000601f19601f8301169050919050565b60006100d08261006e565b6100da8185610079565b93506100ea81856020860161008a565b6100f3816100b4565b840191505092915050565b6000602082019050818103600083015261011881846100c5565b90509291505056fe546f2077686f6d206974206d617920636f6e6365726e2c204920777269746520796f752061667465722061206c6f6e6720706572696f64206f662073696c656e636520746f20616c65727420796f752074686174206166746572206d756368207265666c656374696f6e2c206974206f636375727320746f206d652074686174204920646f6e2774207468696e6b20796f7520686176652066756c6c7920636f6e736964657265642e2e2ea264697066735822122088e486b0a77cd3e2ce809e0a086052815913daec73ebd731e30496d650784f7664736f6c63430008110033
```

---

## Заключение

В этом уроке вы узнали, как использовать наследование для включения функциональности одного контракта в другой. Вы также узнали, что наследуемые контракты могут вызывать `internal` функции, но не могут вызывать `private` функции. Вы также узнали, что наследование от контракта добавляет размер байт-кода этого контракта к общему размеру развертывания.

---

[Inheritance]: https://docs.soliditylang.org/en/v0.8.17/contracts.html
