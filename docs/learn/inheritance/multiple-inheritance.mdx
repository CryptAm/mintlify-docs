---
title: Множественное наследование
sidebarTitle: Руководство по множественному наследованию
description: Узнайте, как заставить контракт наследовать от нескольких контрактов.
hide_table_of_contents: false
---

Контракты могут наследовать от более чем одного контракта. В этом уроке мы исследуем, как работает множественное наследование в Solidity.

---

## Цели

К концу этого урока вы сможете:

- Написать смарт-контракт, который наследует от нескольких контрактов

---

## Множественное наследование

Продолжайте работу с вашими контрактами в `Inheritance.sol`. Добавьте новый контракт под названием `ContractC` с другой функцией `whoAmI`:

<Accordion title="Показать код">

```solidity
contract ContractC {
    function whoAmI() external pure returns (string memory) {
        return "contract C";
    }
}
```

</Accordion>

### Наследование от двух контрактов

Вы можете наследовать от дополнительных контрактов, просто добавив запятую и имя этого контракта после первого. Добавьте наследование от `ContractC` (ожидается ошибка):

<Accordion title="Показать код">

```solidity
// пример плохого кода, не используйте
contract ContractA is ContractB, ContractC {
    function whoAmExternal() external pure returns (string memory) {
        return whoAmIInternal();
    }
}
```

</Accordion>

Ошибка возникает потому, что и `ContractB` и `ContractC` содержат функцию с именем `whoAmI`. В результате компилятору нужна инструкция о том, какую использовать.

```text
from solidity:
TypeError: Derived contract must override function "whoAmI". Two or more base classes define function with same name and parameter types.
  --> contracts/Inheritance.sol:21:1:
   |
21 | contract ContractA is ContractB, ContractC {
   | ^ (Relevant source part starts here and spans across multiple lines).
Note: Definition in "ContractC":
 --> contracts/Inheritance.sol:6:5:
  |
6 |     function whoAmI() external pure returns (string memory) {
  |     ^ (Relevant source part starts here and spans across multiple lines).
Note: Definition in "ContractB":
  --> contracts/Inheritance.sol:12:5:
   |
12 |     function whoAmI() external pure returns (string memory) {
   |     ^ (Relevant source part starts here and spans across multiple lines).
```

### Использование Virtual и Override

Один из методов разрешения этого конфликта - использование ключевых слов [`virtual` and `override`], чтобы дать вам возможность добавить функционал для выбора, какую функцию вызывать.

Добавьте ключевое слово `virtual` к функции `whoAmI` как в `ContractC`, так и в `ContractB`.

Они также должны быть сделаны `public` вместо `external`, потому что `external` функции не могут быть вызваны внутри контракта.

```solidity
contract ContractC {
    function whoAmI() public virtual pure returns (string memory) {
        return "contract C";
    }
}

contract ContractB {
    function whoAmI() public virtual pure returns (string memory) {
        return "contract B";
    }

    // ... дополнительный код
}
```

Добавьте `override` функцию с именем `whoAmI` в `ContractA`:

```solidity
// Пример плохого кода, не используйте
function whoAmI() public override pure returns (string memory) {
    return ContractB.whoAmI();
}
```

Вы получите еще одну ошибку, сообщающую вам указать, от каких контрактов эта функция должна переопределять (override).

```text
from solidity:
TypeError: Function needs to specify overridden contracts "ContractB" and "ContractC".
  --> contracts/Inheritance.sol:22:32:
   |
22 |     function whoAmI() public override pure returns (string memory) {
   |                              ^^^^^^^^
```

Добавьте их оба:

```solidity
function whoAmI() external override(ContractB, ContractC) pure returns (string memory) {
    return ContractB.whoAmI();
}
```

Разверните и протестируйте. Теперь вызов снова будет возвращать "contract B".

### Динамическое изменение типов

Добавьте `enum` на уровне контракта в `ContractA` с элементами `None`, `ContractBType` и `ContractCType`, а также его экземпляр с именем `contractType`.

<Accordion title="Показать код">

```solidity
enum Type { None, ContractBType, ContractCType }

Type contractType;
```

</Accordion>

Добавьте `constructor` в `ContractA`, который принимает `Type` и устанавливает `initialType`.

<Accordion title="Показать код">

```solidity
constructor (Type _initialType) {
    contractType = _initialType;
}
```

</Accordion>

Обновите `whoAmI` в `ContractA`, чтобы вызывать соответствующую `virtual` функцию в зависимости от его `currentType`.

<Accordion title="Показать код">

```solidity
// Пример плохого кода, не используйте
function whoAmI() public override(ContractB, ContractC) pure returns (string memory) {
    if(contractType == Type.ContractBType) {
        return ContractB.whoAmI();
    }
    if(contractType == Type.ContractCType) {
        return ContractC.whoAmI();
    }
    return "contract A";
}
```

</Accordion>

Вы получите ошибки, потому что функция теперь читает из состояния (state), поэтому она больше не является `pure`. Обновите ее до `view`. Вам также придется обновить `virtual` функции `whoAmI` до `view`, чтобы они соответствовали.

<Accordion title="Показать код">

```solidity
function whoAmI() public override(ContractB, ContractC) view returns (string memory) {
    if(contractType == Type.ContractBType) {
        return ContractB.whoAmI();
    }
    if(contractType == Type.ContractCType) {
        return ContractC.whoAmI();
    }
    return "contract A";
}
```

</Accordion>

Наконец, добавьте функцию, которая позволяет переключать `currentType`:

<Accordion title="Показать код">

```solidity
function changeType(Type _newType) external {
    contractType = _newType;
}
```

</Accordion>

Разверните и протестируйте. Вам нужно будет использовать **0**, **1**, и **2** в качестве значений для установки `contractType`, потому что Remix не будет знать о вашем `enum`.

## Итоговый код

После завершения этого упражнения у вас должно получиться что-то подобное:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

contract ContractC {
    function whoAmI() public virtual view returns (string memory) {
        return "contract C";
    }
}

contract ContractB {
    function whoAmI() public virtual view returns (string memory) {
        return "contract B";
    }

    function whoAmIInternal() internal pure returns (string memory) {
        return "contract B";
    }
}

contract ContractA is ContractB, ContractC {
    enum Type { None, ContractBType, ContractCType }

    Type contractType;

    constructor (Type _initialType) {
        contractType = _initialType;
    }

    function changeType(Type _newType) external {
        contractType = _newType;
    }

    function whoAmI() public override(ContractB, ContractC) view returns (string memory) {
        if(contractType == Type.ContractBType) {
            return ContractB.whoAmI();
        }
        if(contractType == Type.ContractCType) {
            return ContractC.whoAmI();
        }
        return "contract A";
    }

    function whoAmExternal() external pure returns (string memory) {
        return whoAmIInternal();
    }
}
```

---

## Заключение

В этом уроке вы исследовали, как использовать множественное наследование для импорта дополнительной функциональности в контракт. Вы также реализовали один из подходов к разрешению конфликтов имен между этими контрактами.

---

[`virtual` and `override`]: https://docs.soliditylang.org/en/v0.8.17/contracts.html?#function-overriding

