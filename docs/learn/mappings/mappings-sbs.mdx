---
title: Отображения (Mappings)
sidebarTitle: Пошаговое руководство
description: Используйте тип данных mapping для хранения пар ключ-значение.
hide_table_of_contents: false
---

В Solidity тип данных, сравнимый с хеш-таблицей/хеш-картой/словарем, используемый для хранения пар ключ-значение, называется `mapping.` `mapping` - это мощный инструмент со многими применениями, но он также имеет некоторые неожиданные ограничения. И они **не являются** на самом деле хеш-таблицами!

---

## Цели

К концу этого урока вы сможете:

- Создать тип данных Map (словарь)
- Помнить, что присваивание типа данных Map не такое гибкое, как для других типов данных/в других языках
- Ограничивать вызовы функций с помощью глобальной переменной `msg.sender`
- Помнить, что в EVM нет защиты от коллизий, и почему это (вероятно) нормально

---

## Отображения (Mappings) в Solidity против хеш-таблиц

На первый взгляд тип данных [`mapping`] кажется просто еще одной реализацией хеш-таблицы, которая хранит пары любого хешируемого типа в качестве ключа и любого другого типа в качестве значения. Разница заключается в реализации.

В более традиционной реализации данные хранятся в памяти как массив, а функция хеширования по модулю _(hashmod)_ используется для определения, в каком месте массива хранить данное значение, на основе ключа. Иногда функция _hashmod_ для двух разных ключей дает один и тот же индекс, вызывая _коллизию_.

Коллизии разрешаются с помощью дополнительных решений, таких как цепочки связных списков; когда базовый массив начинает заполняться, создается больший массив, все ключи повторно хешируются по модулю, и все значения перемещаются в новый массив.

В EVM `mapping` **не** имеют массива в качестве базовой структуры данных. Вместо этого хеш `keccak256` от ключа плюс слот хранения (storage slot) самого mapping используется для определения того, какой слот хранения из всех 2**256 будет использоваться для значения.

Нет обработки коллизий по той же причине, по которой вообще работают кошельки - 2**256 — это невообразимо большое число. Одно из самых больших чисел, с которым вы можете регулярно сталкиваться, - это количество возможных комбинаций [shuffled deck of cards], которое равно:

80658175170943878571660636856403766975289505440883277824000000000000

Между тем количество вариаций хеша `keccak256` равно:

115792089237316195423570985008687907853269984665640564039457584007913129639935

Коллизии очень маловероятны.

В результате есть несколько особых характеристик и ограничений, которые следует иметь в виду для типа данных `mapping`:

- Отображения могут иметь расположение данных (data location) только `storage`
- Они не могут использоваться в качестве параметров или возвращаемых значений публичных функций
- Они не являются итерируемыми, и вы не можете получить список ключей
- Все возможные ключи будут возвращать значение по умолчанию, если другое значение не было сохранено

### Создание mapping

Создайте контракт под названием `Mappings`. В нем добавьте `mapping` от `address` к `uint` с именем `favoriteNumbers`.

<Accordion title="Показать код">

```solidity
contract Mappings {
    mapping (address => uint) favoriteNumbers;
}
```

</Accordion>

### Запись в mapping

Добавьте функцию под названием `saveFavoriteNumber`, которая принимает `address` и `uint`, а затем сохраняет `uint` в `mapping`, используя `address` в качестве ключа.

<Accordion title="Показать код">

```solidity
function saveFavoriteNumber(address _address, uint _favorite) public {
    favoriteNumbers[_address] = _favorite;
}
```

</Accordion>

Разверните и протестируйте. Работает ли? Вероятно...

У вас нет способа прочитать данные в `favoriteNumber`, но эту проблему легко исправить. Подобно массивам, если вы пометите `mapping` как public, компилятор Solidity автоматически создаст геттер для значений в этом `mapping`.

Обновите объявление `favoriteNumbers` и разверните, чтобы снова протестировать.

### Использование msg.sender

Другая проблема с этим контрактом заключается в том, что `public` функцию может вызвать любой и каждый, у кого есть кошелек и средства для оплаты газа. В результате кто угодно может зайти после вас и изменить ваше любимое число с удачного числа **13** на что угодно, даже на **7**!

Это совершенно неприемлемо!

К счастью, вы можете использовать [global variable] под названием `msg.sender` для получения `address` кошелька, отправившего транзакцию. Используйте это, чтобы сделать так, чтобы только владелец `address` мог установить свое любимое число.

<Accordion title="Показать код">

```solidity
function saveFavoriteNumber(uint _favorite) public {
    favoriteNumbers[msg.sender] = _favorite;
}
```

</Accordion>

Разверните и протестируйте снова. Успех!

---

## Получение всех любимых чисел

Одно сложное ограничение типа данных `mapping` заключается в том, что он не является итерируемым - вы не можете пройтись по всем значениям в `mapping` и манипулировать ими или возвращать их.

По крайней мере, без встроенных функций, но вы можете решить эту проблему самостоятельно. Распространенной практикой в Solidity для решения этой и подобных проблем является использование нескольких переменных или типов данных для хранения нужной комбинации, необходимой для решения задачи.

### Использование вспомогательного массива

Для этой проблемы вы можете использовать вспомогательный массив для хранения списка всех ключей, присутствующих в `favoriteNumbers`. Просто добавьте массив и добавляйте в него новые ключи при сохранении нового любимого числа.

<Accordion title="Показать код">

```solidity
contract Mappings {
    mapping (address => uint) public favoriteNumbers;
    address[] addressesOfFavs;

    function saveFavoriteNumber(uint _favorite) public {
        favoriteNumbers[msg.sender] = _favorite;
        // Неидеальное решение, см. ниже
        addressesOfFavs.push(msg.sender);
    }
}
```

</Accordion>

Чтобы вернуть все любимые числа, вы можете затем перебрать `addressesOfFavs`, найти любимое число этого адреса, добавить его в возвращаемый массив и затем вернуть массив, когда закончите.


<Accordion title="Показать код">

```solidity
function returnAllFavorites() public view returns (uint[] memory) {
    uint[] memory allFavorites = new uint[](addressesOfFavs.length);

    for(uint i = 0; i < allFavorites.length; i++) {
        allFavorites[i] = favoriteNumbers[addressesOfFavs[i]];
    }

    return allFavorites;
}
```

</Accordion>

На первый взгляд это решение работает, но есть проблема: что произойдет, если пользователь **обновит** свое любимое число? Его адрес окажется в списке дважды, что приведет к дублированию записи в возвращаемом значении.

Решение здесь - сначала проверить, есть ли у `address` уже число в качестве значения в `favoriteNumbers`, и добавлять его в массив только если нет.

<Accordion title="Показать код">

```solidity
function saveFavoriteNumber(uint _favorite) public {
    if(favoriteNumbers[msg.sender] == 0) {
        addressesOfFavs.push(msg.sender);
    }
    favoriteNumbers[msg.sender] = _favorite;
}
```

</Accordion>

В итоге у вас должен получиться контракт, похожий на этот:

<Accordion title="Показать код">

```solidity
pragma solidity 0.8.17;

contract Mappings {
    mapping (address => uint) public favoriteNumbers;
    address[] addressesOfFavs;

    function saveFavoriteNumber(uint _favorite) public {
        if(favoriteNumbers[msg.sender] == 0) {
            addressesOfFavs.push(msg.sender);
        }
        favoriteNumbers[msg.sender] = _favorite;
    }

    function returnAllFavorites() public view returns (uint[] memory) {
        uint[] memory allFavorites = new uint[](addressesOfFavs.length);

        for(uint i = 0; i < allFavorites.length; i++) {
            allFavorites[i] = favoriteNumbers[addressesOfFavs[i]];
        }

        return allFavorites;
    }
}
```

</Accordion>

---

## Заключение

В этом уроке вы узнали, как использовать тип данных `mapping` для хранения пар ключ-значение в Solidity. Вы также исследовали одну стратегию решения некоторых ограничений, присущих типу `mapping`, по сравнению с аналогичными типами в других языках.

---

[`mapping`]: https://docs.soliditylang.org/en/v0.8.17/types.html#mapping-types
[hash table]: https://en.wikipedia.org/wiki/Hash_table
[shuffled deck of cards]: https://czep.net/weblog/52cards.html
[global variable]: https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html
