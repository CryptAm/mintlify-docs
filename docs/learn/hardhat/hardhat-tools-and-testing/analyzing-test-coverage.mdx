---
title: 'Hardhat: Анализ покрытия тестами смарт-контрактов'
slug: /hardhat-test-coverage
description: Руководство, которое научит анализировать покрытие тестами ваших смарт-контрактов с помощью Hardhat и плагина Solidity Coverage.
author: Edson Alcala
---

# Анализ покрытия тестами смарт-контрактов с использованием Hardhat

В этом руководстве вы узнаете, как анализировать покрытие тестами ваших смарт-контрактов с помощью [Hardhat] и плагина сообщества [Solidity Coverage].

## Цели обучения

После изучения этого руководства вы сможете:

- Использовать плагин Solidity Coverage для анализа покрытия вашего набора тестов
- Увеличить покрытие вашего набора тестов

## Обзор

Плагин Solidity Coverage позволяет анализировать и визуализировать покрытие тестами ваших смарт-контрактов. Это позволяет вам увидеть, какие части вашего смарт-контракта тестируются, а какие области могли быть упущены. Это незаменимый плагин для разработчиков, стремящихся укрепить свои практики тестирования и обеспечить надежную функциональность смарт-контрактов.

## Настройка плагина Solidity Coverage

Плагин Solidity Coverage интегрирован в пакет Hardhat toolbox, который устанавливается по умолчанию при использовании команды `npx hardhat init`.

Чтобы установить вручную, выполните `npm install -D solidity-coverage`.

Затем импортируйте `solidity-coverage` in `hardhat.config.ts`:

```solidity
import "solidity-coverage"
```

После завершения установки, вручную или через шаблон Hardhat по умолчанию, задача `coverage` становится доступной через команду `npx hardhat coverage`.

## Мое первое покрытие тестами

Рассмотрите следующий контракт и набор тестов (Вы узнаете их, если завершили [Hardhat testing lesson] по [Base Learn] в нашей серии).

Контракт:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

contract Lock {
    uint public unlockTime;
    address payable public owner;

    event Withdrawal(uint amount, uint when);

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);
    }

    function withdraw() public {
        require(block.timestamp >= unlockTime, "You can't withdraw yet");
        require(msg.sender == owner, "You aren't the owner");

        emit Withdrawal(address(this).balance, block.timestamp);

        owner.transfer(address(this).balance);
    }
}
```

`Lock.test.ts`:

```solidity
import { expect } from "chai";
import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-network-helpers";
import { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers'
import { Lock__factory, Lock} from '../typechain-types'

describe("Lock Tests", function () {
  const UNLOCK_TIME = 10000;
  const VALUE_LOCKED = ethers.parseEther("0.01");

  let lastBlockTimeStamp: number;
  let lockInstance: Lock;
  let ownerSigner: SignerWithAddress
  let otherUserSigner: SignerWithAddress;

  before(async() => {
    lastBlockTimeStamp = await time.latest()
    const signers = await ethers.getSigners()
    ownerSigner = signers[0]
    otherUserSigner= signers[1]

    const unlockTime = lastBlockTimeStamp + UNLOCK_TIME;

    lockInstance = await new Lock__factory(ownerSigner).deploy(unlockTime, {
      value: VALUE_LOCKED
    })
  })

  it('should get the unlockTime value', async() => {
    const unlockTime = await lockInstance.unlockTime();

    expect(unlockTime).to.equal(lastBlockTimeStamp + UNLOCK_TIME)
  })

  it('should have the right ether balance', async() => {
    const lockInstanceAddress = await lockInstance.getAddress()

    const contractBalance = await ethers.provider.getBalance(lockInstanceAddress)

    expect(contractBalance).to.equal(VALUE_LOCKED)
  })

  it('should have the right owner', async()=> {
    expect(await lockInstance.owner()).to.equal(ownerSigner.address)
  })

  it('should not allow to withdraw before unlock time', async()=> {
    await expect(lockInstance.withdraw()).to.be.revertedWith("You can't withdraw yet")
  })

  it('should not allow to withdraw a non owner', async()=> {
    const newLastBlockTimeStamp = await time.latest()

    await time.setNextBlockTimestamp(newLastBlockTimeStamp + UNLOCK_TIME)

    const newInstanceUsingAnotherSigner = lockInstance.connect(otherUserSigner)

    await expect(newInstanceUsingAnotherSigner.withdraw()).to.be.revertedWith("You aren't the owner")
  })

 it('should allow to withdraw a owner', async()=> {
    const balanceBefore = await ethers.provider.getBalance(await lockInstance.getAddress());

    expect(balanceBefore).to.equal(VALUE_LOCKED)

    const newLastBlockTimeStamp = await time.latest()

    await time.setNextBlockTimestamp(newLastBlockTimeStamp + UNLOCK_TIME)

    await lockInstance.withdraw();

    const balanceAfter = await ethers.provider.getBalance(await lockInstance.getAddress());
    expect(balanceAfter).to.equal(0)
  })
});
```

Если вы запустите `npx hardhat coverage`, вы должны получить:

```terminal
 Lock Tests
    ✔ должен получить значение unlockTime
    ✔ должен иметь правильный баланс эфира
    ✔ должен иметь правильного владельца
    ✔ не должен позволять выводить до времени разблокировки
    ✔ не должен позволять выводить не владельцу
    ✔ должен позволять выводить владельцу

  6 проходящих (195ms)

------------|----------|----------|----------|----------|----------------|
Файл        |  % Строк | % Веток  |  % Функц |  % Линий |Непокрытые стрк |
------------|----------|----------|----------|----------|----------------|
 contracts/ |      100 |    83.33 |      100 |      100 |                |
  Lock.sol  |      100 |    83.33 |      100 |      100 |                |
------------|----------|----------|----------|----------|----------------|
Все файлы   |      100 |    83.33 |      100 |      100 |                |
------------|----------|----------|----------|----------|----------------|
```

Что дает вам отчет о покрытии тестами вашего набора тестов. Обратите внимание, что появилась новая папка под названием `coverage`, которая была создана плагином `solidity-coverage`. Внутри папки `coverage` находится файл `index.html`. Откройте его в браузере, и вы увидите отчет, подобный следующему:

![Coverage report](/images/hardhat-test-coverage/coverage-report.png)

## Увеличение покрытия тестами

Хотя покрытие предыдущего набора тестов почти идеально, есть одна пропущенная ветвь при создании контракта. Потому что вы не протестировали условие, что `_unlockTime` должно быть больше, чем `block.timestamp`:

```solidity
require(
    block.timestamp < _unlockTime,
    "Unlock time should be in the future"
  );
```

Чтобы увеличить покрытие, добавьте новый тест со следующим:

```solidity
  it('should verify the unlock time to be in the future', async () => {
    const newLockInstance = new Lock__factory(ownerSigner).deploy(lastBlockTimeStamp, {
      value: VALUE_LOCKED
    })

    await expect(newLockInstance).to.be.revertedWith("Unlock time should be in the future")
  })
```

Затем запустите `npx hardhat coverage`, и вы должны получить:

```solidity
  Lock Tests
    ✔ должен проверять, что время разблокировки в будущем (39ms)
    ✔ должен получить значение unlockTime
    ✔ должен иметь правильный баланс эфира
    ✔ должен иметь правильного владельца
    ✔ не должен позволять выводить до времени разблокировки
    ✔ не должен позволять выводить не владельцу
    ✔ должен позволять выводить владельцу

  7 проходящих (198ms)

------------|----------|----------|----------|----------|----------------|
Файл        |  % Строк | % Веток  |  % Функц |  % Линий |Непокрытые стрк |
------------|----------|----------|----------|----------|----------------|
 contracts/ |      100 |      100 |      100 |      100 |                |
  Lock.sol  |      100 |      100 |      100 |      100 |                |
------------|----------|----------|----------|----------|----------------|
Все файлы   |      100 |      100 |      100 |      100 |                |
------------|----------|----------|----------|----------|----------------|
```

## Заключение

В этом руководстве вы узнали, как анализировать покрытие тестами ваших смарт-контрактов. Вы узнали, как визуализировать отчет о покрытии и улучшить покрытие набора тестов с помощью плагина Solidity Coverage.

## Смотрите также

[Hardhat]: https://hardhat.org/
[Solidity Coverage]: https://github.com/sc-forks/solidity-coverage
[Hardhat testing lesson]: https://docs.base.org/base-learn/docs/hardhat-testing/hardhat-testing-sbs
[Base Learn]: https://base.org/learn

