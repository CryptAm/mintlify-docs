---
title: 'Hardhat: Оптимизация размера смарт-контрактов'
slug: /hardhat-profiling-size
description: Руководство, которое учит, как оптимизировать размер ваших смарт-контрактов с помощью Hardhat.
author: Edson Alcala and Brian Doyle
keywords:
  [
    Smart Contract Sizes,
    Hardhat Contract Sizer,
    Base network,
    Base blockchain,
    Blockchain,
    Contract Optimization,
    Inheritance,
    External Contracts,
    Solidity Optimizer,
    Smart Contract Development,
  ]
tags: ['smart contracts']
difficulty: beginner
hide_table_of_contents: false
displayed_sidebar: null
---

# Hardhat: Оптимизация размера смарт-контрактов

В этом учебнике вы узнаете, как профилировать и оптимизировать размер смарт-контрактов с помощью Hardhat и плагина [Hardhat Contract Sizer].



## Цели

К концу этого учебника вы сможете:

- Использовать плагин Hardhat Contract Sizer для профилирования размера контракта
- Описывать распространенные стратегии управления ограничением размера контракта
- Описывать влияние наследования на ограничение размера байт-кода
- Описывать влияние внешних контрактов на ограничение размера байт-кода
- Описывать влияние использования библиотек на ограничение размера байт-кода
- Описывать влияние использования оптимизатора Solidity



## Обзор

В мире блокчейна и Ethereum оптимизация размеров смарт-контрактов имеет решающее значение. Меньшие контракты потребляют меньше газа при развертывании и выполнении, что приводит к экономии затрат на газ для ваших пользователей. К счастью, в Hardhat вы можете использовать плагин `hardhat-contract-sizer`, который помогает анализировать и оптимизировать размер ваших смарт-контрактов.

## Настройка плагина Hardhat Contract Sizer



Hardhat Contract Sizer - это плагин, разработанный сообществом, который позволяет профилировать смарт-контракты, выводя размер ваших контрактов в терминал. Это полезно во время разработки, так как позволяет сразу выявлять потенциальные проблемы с размером ваших смарт-контрактов. Помните, что [maximum size of a smart contract in Ethereum] составляет 24 КиБ.

Для установки выполните `npm install -D hardhat-contract-sizer`.

Затем импортируйте `hardhat-contract-sizer` in `hardhat.config.ts`:

```solidity
import "hardhat-contract-sizer"
```

После завершения настройки вы готовы использовать плагин.

## Ваше первое профилирование размера

Как и в предыдущих учебниках, вы начнете с профилирования смарт-контракта `Lock.sol`.

Выполните `npx hardhat size-contracts` - это задача (task), добавленная в Hardhat после настройки и конфигурации плагина `hardhat-contract-sizer`.

Затем вы увидите:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: false      ·  Runs: 200                     │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  BalanceReader         ·                      0.612 ()  ·                      0.644 ()  │
 ·························|································|·································
 |  Lock                  ·                      1.009 ()  ·                      1.461 ()  │
```

Хотя ваш контракт прост, вы сразу видите силу плагина `hardhat-contract-sizer`, так как он показывает размер ваших контрактов.

## Распространенные стратегии для оптимизации размера контрактов

<Video videoId='863776975' title='Manual Optimizations' />

Чтобы проиллюстрировать некоторые стратегии оптимизации размера ваших контрактов, создайте два смарт-контракта: `Calculator.sol` и `ScientificCalculator.sol` со следующим содержимым:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

contract Calculator {
    function add(uint256 a, uint256 b) external pure returns(uint256) {
        require(a > 0 && b > 0, "Invalid values");
        return a + b;
    }

    function sub(uint256 a, uint256 b) external pure returns(uint256) {
        require(a > 0 && b > 0, "Invalid values");
        return a - b;
    }

    function mul(uint256 a, uint256 b) external pure returns(uint256) {
       require(a > 0 && b > 0, "Invalid values");
       return a * b;
    }

    function div(uint256 a, uint256 b) external pure returns(uint256) {
        require(a > 0 && b > 0, "Invalid values");
        return a / b;
    }
}
```

```solidity
contract ScientificCalculator is Calculator {
    function power(uint256 base, uint256 exponent) public pure returns (uint256) {
        require(base > 0 && exponent > 0, "Invalid values");

        return base ** exponent;
    }
}
```

Затем снова выполните команду `npx hardhat size-contracts`, и вы должны увидеть:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: false      ·  Runs: 200                     │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  BalanceReader         ·                 0.612 (0.000)  ·                 0.644 (0.000)  │
 ·························|································|·································
 |  Lock                  ·                 1.009 (0.000)  ·                 1.461 (0.000)  │
 ·························|································|·································
 |  Calculator            ·                      1.299 ()  ·                      1.330 ()  │
 ·························|································|·································
 |  ScientificCalculator  ·                      1.827 ()  ·                      1.858 ()  │
 ·------------------------|--------------------------------|--------------------------------·
```

Обратите внимание, что размер `ScientificCalculator` больше, чем `Calculator`. Это связано с тем, что `ScientificCalculator` наследует контракт `Calculator`, что означает, что весь его функционал и код доступны в `ScientificCalculator`, и это повлияет на его размер.

### Абстракция кода и модификаторы

На этом этапе, как разработчик смарт-контрактов, вы можете пересмотреть код своего смарт-контракта и найти способы его оптимизации.

Первое, что бросается в глаза в исходном коде - это частое использование:

```solidity
require(a > 0 && b > 0, "Invalid values");
```

Возможной оптимизацией является вынос повторяющегося кода в [modifiers], например:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

contract Calculator {
    error InvalidInput();

    function add(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
       return a * b;
    }

    function div(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
        return a / b;
    }

    modifier onlyValidInputs(uint256 a, uint256 b) {
        if(a == 0 && b == 0){
            revert InvalidInput();
        }
        _;
    }
}
```

И для `ScientificCalculator`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "./Calculator.sol";

contract ScientificCalculator is Calculator {
    function power(uint256 base, uint256 exponent) public pure onlyValidInputs(base,exponent) returns (uint256) {
        return base ** exponent;
    }
}
```

Обратите внимание на использование модификатора и замену `require` на пользовательскую ошибку.

Когда вы запустите команду `npx hardhat size-contracts`, вы должны увидеть:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: false      ·  Runs: 200                     │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  BalanceReader         ·                 0.612 (0.000)  ·                 0.644 (0.000)  │
 ·························|································|·································
 |  Lock                  ·                 1.009 (0.000)  ·                 1.461 (0.000)  │
 ·························|································|·································
 |  Calculator            ·                 1.165 (0.000)  ·                 1.196 (0.000)  │
 ·························|································|·································
 |  ScientificCalculator  ·                 1.690 (0.000)  ·                 1.722 (0.000)  │
 ·------------------------|--------------------------------|--------------------------------·
```

Хотя оптимизация невелика, вы видите некоторые улучшения.

Вы можете продолжать этот процесс, пока не будете удовлетворены размером контракта.

### Разделение на несколько контрактов

Распространенной практикой является разделение ваших смарт-контрактов на несколько контрактов, не только из-за ограничений по размеру, но и для создания лучших абстракций, улучшения читаемости и избежания повторений.

С точки зрения размера контракта наличие нескольких независимых контрактов уменьшит размер каждого из них. Например, исходный размер смарт-контракта составлял 30 КиБ: разделив его на 2, вы получите 2 смарт-контракта размером примерно по 15 КиБ каждый, что соответствует ограничениям Solidity. Имейте в виду, что это повлияет на затраты газа при выполнении контракта, так как потребуется вызов внешнего контракта.

Чтобы объяснить этот пример, создайте контракт под названием `Computer` который содержит функцию `executeProcess`:

```tsx
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

contract Computer {
     function executeProcess() external view {
        // ...логика для реализации
    }
}
```

В этом примере функция `executeProcess` контракта `Computer` требует определенный функционал от `Calculator` и нового контракта под названием `Printer`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

contract Printer {
     function print(string memory _content) external view {
        require(bytes(_content).length > 0, "invalid length");
        console.log(_content);
    }
}
```

Самый простой способ для `Computer` получить доступ к обоим функциям - это наследование. Однако по мере того, как все эти контракты продолжают добавлять функционал, размер кода также будет увеличиваться. В какой-то момент вы столкнетесь с проблемой размера контракта, поскольку копируете весь функционал в свой контракт. Лучше позволить этому функционалу оставаться в их конкретных контрактах, и если `Computer` потребуется доступ к нему, он может вызывать контракты `Calculator` и `Printer`.

Но в этом примере есть процесс, который должен вызывать и `Calculator` и `Printer`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

import "./Calculator.sol";
import "./Printer.sol";

contract Computer {
    Calculator calculator;
    Printer printer;

    constructor(address _calculator, address _printer) {
        calculator = Calculator(_calculator);
        printer = Printer(_printer);
    }

    function executeProcess() external view {
        // вызов контракта Calculator, например calculator.add(a, b);
        // вызов контракта Printer, например printer.print("value to print");
    }
}
```

Если вы запустите плагин contract sizer, вы получите:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: true       ·  Runs: 10000                   │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  console               ·                 0.084 (0.000)  ·                 0.138 (0.000)  │
 ·························|································|·································
 |  Computer              ·                 0.099 (0.000)  ·                 0.283 (0.000)  │
 ·························|································|·································
 |  Calculator            ·                 0.751 (0.000)  ·                 0.782 (0.000)  │
 ·························|································|·································
 |  Printer               ·                 0.761 (0.000)  ·                 0.792 (0.000)  │
 ·························|································|·································
 |  ScientificCalculator  ·                 1.175 (0.000)  ·                 1.206 (0.000)  │
 ·------------------------|--------------------------------|--------------------------------·
```

Обратите внимание, как ваш контракт `Computer` очень мал, но все еще имеет возможность доступа ко всему функционалу `Printer` и `Calculator`.

Хотя это уменьшит размер каждого контракта, стоимость этого обсуждается более подробно в статье [Gas Optimization].

### Использование библиотек

Библиотеки - еще один распространенный способ инкапсулировать и абстрагировать общий функционал, который может использоваться несколькими контрактами. Это может существенно повлиять на размер байт-кода смарт-контрактов. Помните, что в Solidity библиотеки могут быть внешними (external) и внутренними (internal).

То, как внутренние библиотеки влияют на размер контракта, очень похоже на то, как наследуемые контракты влияют на размер контракта; это связано с тем, что внутренние функции библиотеки включаются в итоговый байт-код.

Но когда библиотеки являются внешними, поведение иное: способ, которым Solidity вызывает внешние библиотеки, заключается в использовании специальной функции под названием [delegate call].

Внешние библиотеки обычно развертываются независимо и могут повторно использоваться несколькими контрактами. Поскольку библиотеки не хранят состояние (stateless), они ведут себя как чистые функции (pure functions) в блокчейне.

В этом примере ваш компьютер будет использовать только библиотеку `Calculator`. Тогда у вас будет следующее:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

library Calculator {
    error InvalidInput();

    function add(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
       return a * b;
    }

    function div(uint256 a, uint256 b) external pure onlyValidInputs(a,b) returns(uint256) {
        return a / b;
    }

    modifier onlyValidInputs(uint256 a, uint256 b) {
        if(a == 0 && b == 0){
            revert InvalidInput();
        }
        _;
    }
}
```

Тогда `Computer` выглядит так:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

import "./Calculator.sol";
import "./Printer.sol";

contract Computer {
    using Calculator for uint256;

    function executeProcess() external view {
        uint256 a = 1;
        uint256 b = 2;
        uint256 result = a.add(b);
        // ... логика для реализации
    }
}
```

Обратите внимание, как вы указываете смарт-контракту использовать библиотеку `Calculator` для `uint256`, и как в функции `executeProcess` вы теперь можете использовать функцию `add` из библиотеки `Calculator` для всех `uint256`.

Если вы выполните команду `npx hardhat size-contracts`, вы получите:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: true       ·  Runs: 10000                   │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  Calculator            ·                 0.761          ·                 0.817          │
 ·························|································|·································
 |  Printer               ·                 0.771          ·                 0.827          │
 ·························|································|·································
 |  Computer              ·                0.961           ·                0.992           │
 ·------------------------|--------------------------------|--------------------------------·
```

Чтобы сравнить влияние, вы можете изменить модификатор external для всех функций библиотеки `Calculator`, и тогда вы получите:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: true       ·  Runs: 10000                   │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  Calculator            ·                 0.084          ·                 0.138          │
 ·························|································|·································
 |  Printer               ·                0.084           ·                0.138           │
 ·························|································|·································
 |  Computer              ·                1.139           ·                1.170           │
 ·------------------------|--------------------------------|--------------------------------·
```

Что демонстрирует, почему использование внешних библиотек может быть хорошим вариантом для оптимизации размера ваших контрактов.

### Использование оптимизатора компилятора Solidity

<Video videoId='863777593' title='Using the Optimizer' />

Еще один способ оптимизировать размер смарт-контрактов - просто использовать оптимизатор Solidity.

Из [Solidity official docs]:

> В целом, оптимизатор пытается упростить сложные выражения, что уменьшает как размер кода, так и стоимость выполнения.

Вы можете включить оптимизатор Solidity в Hardhat, просто добавив следующее в файл `hardhat.config.ts`:

```solidity
const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.18",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  ...
}
```

Обратите внимание, что оптимизатор включен и имеет параметр `runs`. Если вы снова запустите команду contract sizer, вы увидите следующее:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: true       ·  Runs: 200                     │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  BalanceReader         ·                0.351 (-0.262)  ·                0.382 (-0.262)  │
 ·························|································|·································
 |  Lock                  ·                0.471 (-0.538)  ·                0.661 (-0.800)  │
 ·························|································|·································
 |  Calculator            ·                0.604 (-0.561)  ·                0.636 (-0.561)  │
 ·························|································|·································
 |  ScientificCalculator  ·                0.930 (-0.761)  ·                0.961 (-0.761)  │
 ·------------------------|--------------------------------|--------------------------------·
```

Обратите внимание на значительное улучшение, но посмотрите, что произойдет, если вы увеличите значение параметра `runs` до 1000:

```
 ·------------------------|--------------------------------|--------------------------------·
 |  Solc version: 0.8.18  ·  Optimizer enabled: true       ·  Runs: 1000                    │
 ·························|································|·································
 |  Contract Name         ·  Deployed size (KiB) (change)  ·  Initcode size (KiB) (change)  │
 ·························|································|·································
 |  BalanceReader         ·                0.400 (+0.050)  ·                0.432 (+0.050)  │
 ·························|································|·································
 |  Lock                  ·                0.537 (+0.066)  ·                0.728 (+0.066)  │
 ·························|································|·································
 |  Calculator            ·                 0.604 (0.000)  ·                 0.636 (0.000)  │
 ·························|································|·································
 |  ScientificCalculator  ·                0.945 (+0.016)  ·                0.977 (+0.016)  │
 ·------------------------|--------------------------------|--------------------------------·
```

Размер контракта увеличился, однако это означает, что ваш код будет более эффективным в течение всего времени жизни контракта, потому что чем выше значение `runs`, тем эффективнее выполнение, но дороже развертывание. Вы можете прочитать больше в [Solidity documentation].

## Заключение

В этом учебнике вы узнали, как профилировать и оптимизировать смарт-контракты, используя среду разработки Hardhat и плагин Hardhat Contract Sizer. Сосредоточившись на критически важном аспекте размера контракта, мы вооружили себя инструментами и стратегиями для создания более эффективного кода на Solidity.

Продолжая свой путь в разработке смарт-контрактов, помните, что оптимизация размеров контрактов - это непрерывный процесс, требующий тщательного учета компромиссов между размером, читаемостью и эффективностью газа.


[Hardhat Contract Sizer]: https://github.com/ItsNickBarry/hardhat-contract-sizer
[maximum size of a smart contract in Ethereum]: https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/#why-is-there-a-limit
[modifiers]: https://docs.base.org/learn/advanced-functions/function-modifiers
[Solidity official docs]: https://docs.soliditylang.org/en/v0.8.20/internals/optimizer.html
[Delegate call]: https://solidity-by-example.org/delegatecall/
[Gas Optimization]: ./hardhat-profiling-gas
[Solidity documentation]: https://docs.soliditylang.org/en/v0.8.20/internals/optimizer.html#optimizer-parameter-runs
