---
title: 'Hardhat: Отладка смарт-контрактов'
slug: /hardhat-debugging
description: Руководство, которое научит отлаживать ваши смарт-контракты с помощью Hardhat.
author: Edson Alcala
---

# Отладка смарт-контрактов с использованием Hardhat

В этом руководстве вы узнаете, как отлаживать ваши смарт-контракты, используя встроенные возможности отладки Hardhat.

## Цели обучения

После изучения этого руководства вы сможете:

- Использовать `console.log` для записи журналов отладки
- Перечислять распространенные ошибки и их решения
- Определять, является ли ошибка ошибкой контракта или ошибкой в тесте

## Обзор

Отладка смарт-контрактов может быть сложной задачей, особенно при работе с децентрализованными приложениями и технологией блокчейна. Hardhat предоставляет мощные инструменты для упрощения процесса отладки.

В этом руководстве вы изучите основные функции отладки, предлагаемые Hardhat, и узнаете, как эффективно выявлять и устранять распространенные ошибки в ваших смарт-контрактах.

## Ваш первый `console.log`

Одной из ключевых функций Hardhat является возможность использования `console.log` для записи журналов отладки в ваших смарт-контрактах. Чтобы использовать его, вы должны включить `hardhat/console.sol` в контракт, который хотите отладить.

Например, в следующем контракте `Lock.sol` вы включаете `hardhat/console.sol` импортируя его и добавляя несколько `console.log` в конструкторе с текстом "Creating" и балансом эфира контракта. Это может помочь вам не только отслеживать успешное создание контракта, но и, что более важно, добавлять дополнительные журналы, такие как баланс контракта после его создания:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

contract Lock {
    uint256 public unlockTime;
    address payable public owner;

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);

        console.log("Creating");
        console.log("Balance", address(this).balance);
    }
}
```

Чтобы протестировать это, вам нужно создать новый файл в папке `test` с именем `Lock.test.ts` со следующим содержимым:

```solidity
import { expect } from "chai";
import { ethers } from "hardhat";

import { time } from "@nomicfoundation/hardhat-network-helpers";
import { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers'

import { Lock__factory, Lock } from '../typechain-types'

describe("Lock Tests", function () {
  const UNLOCK_TIME = 10000;
  const VALUE_LOCKED = ethers.parseEther("0.01");

  let lastBlockTimeStamp: number;
  let lockInstance: Lock;
  let ownerSigner: SignerWithAddress

  before(async () => {
    lastBlockTimeStamp = await time.latest()

    const signers = await ethers.getSigners()
    ownerSigner = signers[0]

    lockInstance = await new Lock__factory().connect(ownerSigner).deploy(lastBlockTimeStamp + UNLOCK_TIME, {
      value: VALUE_LOCKED
    })
  })

  it('should get the unlockTime value', async () => {
    expect(await lockInstance.unlockTime()).to.equal(lastBlockTimeStamp + UNLOCK_TIME)
  })
});
```

Обратите внимание, что включен только один тест для получения правильных журналов. Однако вас интересует только процесс создания, который происходит в хуке `before`. Затем вы можете запустить:

```bash
npx hardhat test
```

Вы должны увидеть следующее в терминале:

```bash
  Lock
Creating
Balance 10000000000000000
    ✔ should get the unlockTime value
```

Терминал показывает текст "Creating" и баланс (который составляет 0.01 эфира), потому что во время создания вы вносите эфир в смарт-контракт через свойство `value`.

### Замечание о `console.log`

В предыдущем примере вы использовали `console.log` для добавления некоторых журналов отладки. Имейте в виду, что версия `console.log` для Solidity ограничена по сравнению с теми, которые предоставляются в других языках программирования, где вы можете логировать почти все.

`Console.log` может вызываться с до четырех параметров следующих типов:

- uint
- string
- bool
- address

Hardhat включает другие функции `console`, такие как:

- console.logInt(int i)
- console.logBytes(bytes memory b)
- console.logBytes1(bytes1 b)
- console.logBytes2(bytes2 b)
- ...
- console.logBytes32(bytes32 b)

Эти функции логирования удобны, когда тип, который вы хотите залогировать, не попадает в типы, принимаемые по умолчанию `console.log`. Для получения дополнительной информации обратитесь к официальной [console.log] документации.

## Определение распространенных ошибок

При отладке ваших смарт-контрактов важно быть знакомым с распространенными ошибками, которые могут возникнуть во время разработки. Распознавание этих ошибок и знание того, как их устранить - важный навык.

В нашей серии руководств [Base Learn], мы рассматриваем несколько ошибок времени компиляции в разделе [Error Triage]. Другие ошибки, такие как `reverts` или `index out of bounds errors`, могут быть неожиданными во время выполнения смарт-контракта.

Далее исследуются типичные методы отладки этих типов ошибок.

### Ошибки отката

Когда транзакция завершается неудачей из-за оператора `require` или `revert`, вам нужно диагностировать, почему условие не выполняется, а затем устранить проблему. Обычно это включает проверку входных параметров, переменных состояния или условий контракта.

Ниже приведен контракт `Lock.sol` с оператором require, который проверяет, что передаваемый параметр (`_unlockTime`) должен быть больше текущего `block.timestamp`.

Простое решение для устранения этой ошибки - залогировать значение `block.timestamp` и `_unlockTime`, что поможет вам сравнить эти значения и затем убедиться, что вы передаете правильные:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

contract Lock {
    uint public unlockTime;
    address payable public owner;

    // event Withdrawal(uint amount, uint when);

    constructor(uint _unlockTime) payable {
        console.log("_unlockTime",_unlockTime);
        console.log("block.timestamp",block.timestamp);
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);

        console.log("Creating");
        console.log("Balance", address(this).balance);
    }
}
```

Когда вы запускаете тесты с помощью `npx hardhat test`, вы увидите следующее:

```bash
Lock Tests
_unlockTime 1697493891
block.timestamp 1697483892
Creating
Balance 10000000000000000
    ✔ should get the unlockTime value
```

Теперь вы можете видеть `block.timestamp` и значение, которое вы передаете, что облегчает обнаружение ошибки.

### Ошибки непреднамеренного поведения

Ошибки непреднамеренного поведения возникают, когда вы вводите неожиданное поведение в код из-за непонимания того, как работает Solidity.

В следующем примере `LockCreator` - это контракт, который позволяет любому развернуть экземпляр `Lock.sol`. Однако  `LockCreator` содержит ошибку: функции `createLock` могут принимать эфир для блокировки, но отправленная сумма не передается в контракт `Lock`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "hardhat/console.sol";

import {Lock} from "./Lock.sol";

contract LockCreator {

    Lock[] internal locks;

    // Пример плохого кода, не используйте
    function createLock(uint256 _unlockTime) external payable {
        Lock newLock = new Lock(_unlockTime);
        locks.push(newLock);
    }
}
```

Вы можете создать тестовый файл `LockCreator.test.ts`, который может идентифицировать ошибку и затем решить ее:

```solidity
import { ethers } from "hardhat";

import { time } from "@nomicfoundation/hardhat-network-helpers";
import { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers'

import { LockCreator, LockCreator__factory } from '../typechain-types'

describe("LockCreator Tests", function () {
  const UNLOCK_TIME = 10000;
  const VALUE_LOCKED = ethers.parseEther("0.01");

  let lastBlockTimeStamp: number;
  let lockInstance: LockCreator;
  let ownerSigner: SignerWithAddress

  before(async () => {
    const signers = await ethers.getSigners()
    ownerSigner = signers[0]

    lockInstance = await new LockCreator__factory().connect(ownerSigner).deploy()
  })

  it('should create a lock', async () => {
    lastBlockTimeStamp = await time.latest()
    await lockInstance.createLock(lastBlockTimeStamp + UNLOCK_TIME, {
      value: VALUE_LOCKED
    })
  })
});
```

В терминале появляется следующее, где вы можете видеть, что баланс равен `0`:

```bash
  LockCreator Tests
Creating
Balance 0
    ✔ should create a lock (318ms)
```

Хотя этой проблемы можно избежать, добавив больше тестовых случаев с правильными утверждениями (assertions), повторная передача эфира из `LockCreator` - это то, что вы могли упустить.

Решение - изменить функцию `createLock` на:

```solidity
function createLock(uint256 _unlockTime) external payable {
    Lock newLock = new Lock{ value: msg.value}(_unlockTime);
    locks.push(newLock);
}
```

### Ошибки выхода за границы

Попытка доступа к массивам по недопустимой позиции также может вызывать ошибки.

Если вы хотите получить все экземпляры контракта `Lock`, созданные в предыдущем примере, вы можете сделать массив `locks` публичным. Чтобы проиллюстрировать этот пример, вы можете создать пользовательскую функцию `getAllLocks`:

```solidity
contract LockCreator {
    //
    // остальной код..
    //
    function getAllLocks() external view returns(Lock[] memory result) {
        result = new Lock[](locks.length);
        for(uint i = 0; i <= locks.length; i++){
            result[i] = locks[i];
        }
    }
}
```

Функцию можно протестировать следующим тестом:

```solidity
describe("LockCreator Tests", function () {
  const UNLOCK_TIME = 10000;
  const VALUE_LOCKED = ethers.parseEther("0.01");

  let lastBlockTimeStamp: number;
  let lockInstance: LockCreator;
  let ownerSigner: SignerWithAddress

  before(async () => {
    const signers = await ethers.getSigners()
    ownerSigner = signers[0]

    lockInstance = await new LockCreator__factory().connect(ownerSigner).deploy()

    lastBlockTimeStamp = await time.latest()

    await lockInstance.createLock(lastBlockTimeStamp + UNLOCK_TIME, {
      value: VALUE_LOCKED
    })
  })

  it('should get all locks', async () => {
    const allLocks = await lockInstance.getAllLocks()

    console.log("all locks", allLocks)
  })
});
```

Что вызовет ошибку:

```bash
LockCreator Tests
Creating
Balance 10000000000000000
    1) should get all locks

  0 passing (3s)
  1 failing

  1) LockCreator Tests
       should get all locks:
     Error: VM Exception while processing transaction: reverted with panic code 0x32 (Array accessed at an out-of-bounds or negative index)
```

Вы можете включить некоторые журналы отладки, чтобы идентифицировать проблему:

```solidity
 function getAllLocks() external view returns(Lock[] memory result) {
        result = new Lock[](locks.length);

        console.log("locks length %s", locks.length);

        for(uint i = 0; i <= locks.length; i++){
            console.log("Locks index %s", i);
            result[i] = locks[i];
        }
}
```

Затем вы видите следующее в терминале:

```bash
 LockCreator Tests
Creating
Balance 10000000000000000
locks length 1
Locks index 0
Locks index 1
1) LockCreator Tests
       should get all locks:
     Error: VM Exception while processing transaction: reverted with panic code 0x32 (Array accessed at an out-of-bounds or negative index)
```

Поскольку массивы индексируются с 0, массив с 1 элементом будет хранить этот элемент по индексу 0. В приведенном выше примере оператор `if` сравнивает `<=` с длиной массива, поэтому он пытается получить доступ к элементу в позиции 1 и падает.

Вот простое решение:

```solidity
 function getAllLocks() external view returns(Lock[] memory result) {
        result = new Lock[](locks.length);

        console.log("locks length %s", locks.length);

        for(uint i = 0; i < locks.length; i++){
            console.log("Locks index %s", i);
            result[i] = locks[i];
        }
}
```

Что сразу решает проблему:

```bash
  LockCreator Tests
Creating
Balance 10000000000000000
locks length 1
Locks index 0
all locks Result(1) [ '0x83BA8C2028EE8a6476396145C7692fBD09337acD' ]
    ✔ should get all locks

  1 passing (3s)
```

## Заключение

В этом руководстве вы изучили некоторые методы отладки смарт-контрактов с помощью Hardhat. Вы рассмотрели несколько распространенных случаев различных ошибок и то, как просто используя `console.log` и правильный тест, вы можете идентифицировать и решить проблему.

## Смотрите также

[Console.log]: https://hardhat.org/hardhat-network/docs/reference#console.log
[Error Triage]: https://docs.base.org/learn/error-triage/error-triage
[Base Learn]: https://base.org/learn

