---
title: Настройка `useReadContract`
description: Настройка свойств хука `useReadContract`.
hide_table_of_contents: false
---

# Настройка `useReadContract`

Хук [`useReadContract`] имеет ряд настраиваемых свойств, которые позволят вам адаптировать его к вашим потребностям. Вы можете комбинировать функциональность TanStack queries с [`useBlockNumber`] для отслеживания изменений в блокчейне, хотя это потребует значительного количества вызовов API.

---

## Цели

К концу этого руководства вы должны уметь:

- Использовать `useBlockNumber` и `queryClient` для автоматической выборки обновлений из блокчейна
- Описать затраты на использование вышеуказанного и методы их снижения
- Настраивать аргументы, передаваемые при вызове `pure` или `view` функции смарт-контракта
- Вызывать экземпляр `useReadContract` по требованию
- Использовать `isLoading` и `isFetching` для улучшения пользовательского опыта

---

## Получение обновлений из блокчейна

Вы продолжите работать с проектом, который создавали и последний раз обновляли, изучая [`useReadContract` hook].

Как только восторг от вашего достижения - чтения из собственного контракта — уляжется, попробуйте использовать BaseScan, чтобы добавить еще один вопрос (issue) или проголосовать за существующий. Вы заметите, что ваш фронтенд **не** обновляется. Есть несколько способов справиться с этим.

<Steps>
<Step title="Получение обновлений из блокчейна">
Используйте `useBlockNumber` с функцией `watch` для автоматического отслеживания номера блока, затем используйте `queryClient` для обновления при его изменении. **Убедитесь**, что вы декомпозируете `queryKey` из возвращаемого значения `useReadContract`.

```tsx
import { useEffect, useState } from 'react';
import { useReadContract, useBlockNumber } from 'wagmi';
import { useQueryClient } from '@tanstack/react-query';

// Другой код

export function IssueList() {
  // Другой код

  const queryClient = useQueryClient();
  const { data: blockNumber } = useBlockNumber({ watch: true });

  const {
    data: issuesData,
    isError: issuesIsError,
    isPending: issuesIsPending,
    queryKey: issuesQueryKey,
  } = useReadContract({
    address: contractData.address as `0x${string}`,
    abi: contractData.abi,
    functionName: 'getAllIssues',
  });

  useEffect(() => {
    queryClient.invalidateQueries({ queryKey: issuesQueryKey });
  }, [blockNumber, queryClient, issuesQueryKey]);

  // Код return
}
```
<Info>
Не делайте этого. Вместо этого используйте мульти-вызов через [`useReadContracts`], или объедините ваши `view` функции в одну, которая получает все необходимые данные за один вызов.
</Info>
</Step>
<Step title="Пауза при потере фокуса">
Прекратите отслеживать блокчейн, если сайт не в фокусе. Добавьте переменную состояния для подсчета количества вызовов функции и одну для отслеживания фокуса страницы. Настройте слушатели событий для установки состояния последней, когда страница получает или теряет фокус.

```tsx
const [timesCalled, setTimesCalled] = useState(0);
const [pageIsFocused, setPageIsFocused] = useState(true);

useEffect(() => {
  const onFocus = () => setPageIsFocused(true);
  const onBlur = () => setPageIsFocused(false);

  window.addEventListener('focus', onFocus);
  window.addEventListener('blur', onBlur);

  return () => {
    window.removeEventListener('focus', onFocus);
    window.removeEventListener('blur', onBlur);
  };
}, []);
```

Обновите `watch` для `useBlockNumber`, чтобы он работал только если `pageIsFocused`.

```tsx
const { data: blockNumber } = useBlockNumber({ watch: pageIsFocused });
```

Добавьте строку в `useEffect` для `blockNumber` и увеличьте ваш счетчик.

```tsx
useEffect(() => {
  setTimesCalled((prev) => prev + 1);
  queryClient.invalidateQueries({ queryKey: issuesQueryKey });
}, [blockNumber, queryClient]);
```

Наконец, отобразите ваш счетчик в компоненте.

```tsx
return (
  <div>
    <h2>Number of times called</h2>
    <p>{timesCalled.toString()}</p>
    <p>{'Has focus: ' + pageIsFocused}</p>
    <h2>All Issues</h2>
    <div>{renderIssues()}</div>
  </div>
);
```
</Step>
<Step title="Настройка интервала опроса">
Настройте ваш [`pollingInterval`] установив его в `getDefaultConfig` в `_app.tsx`:

```tsx
const config = getDefaultConfig({
  appName: 'RainbowKit App',
  projectId: 'YOUR_PROJECT_ID',
  chains: [baseSepolia],
  ssr: true,
  pollingInterval: 30_000,
});
```

Установка интервала в 30 секунд (30 000 миллисекунд) значительно сократит ваши вызовы API, не влияя негативно на членов DAO.
</Step>
<Step title="Обновление по требованию">
Используйте похожую систему для вызова вашей функции обновления по требованию. Добавьте кнопку, обработчик для нее и переменную состояния, которую она будет устанавливать:

```tsx
const [triggerRead, setTriggerRead] = useState(false);

const handleTriggerRead = () => {
  setTriggerRead(true);
};
```

```tsx
return (
  <div>
    <button onClick={handleTriggerRead}>Read Now</button>
    <h2>Number of times called</h2>
    <p>{timesCalled.toString()}</p>
    <p>{'Has focus: ' + pageIsFocused}</p>
    <h2>All Issues</h2>
    <div>{renderIssues()}</div>
  </div>
);
```

Наконец, установите `watch` равным `triggerRead` вместо `pageIsFocused` и сбросьте `triggerRead` в `useEffect`.

```tsx
const { data: blockNumber } = useBlockNumber({ watch: triggerRead });

// Другой код...

useEffect(() => {
  setTriggerRead(false);
  queryClient.invalidateQueries({ queryKey: issuesQueryKey });
}, [blockNumber, queryClient]);
```
</Step>
<Step title="Настройка UI-элементов в зависимости от статуса">
Используйте возвращаемые значения "is" для настройки UI-элементов в зависимости от статуса хука при попытке вызвать функцию в блокчейне.

```tsx
<button disabled={issuesIsFetching} onClick={handleTriggerRead}>
  {issuesIsFetching ? 'Loading' : 'Read Now'}
</button>
```
Вы, вероятно, увидите, что кнопка мигает очень быстро, так как вызов не занимает много времени. Для продакшн-приложения потребуется дополнительная обработка, чтобы сгладить опыт.
</Step>
<Step title="Передача аргументов в useReadContract">
Аргументы передаются в хук `useReadContract` путем добавления массива аргументов по порядку в свойство `args`. Общепринятой практикой является использование переменных состояния React, устанавливаемых UI-элементами, чтобы аргументы можно было задавать и изменять. Например, вы можете создать выпадающий список для установки `issueNumber`, а затем получить этот вопрос с помощью:

```tsx
const [issueNumber, setIssueNumber] = useState(0);

const { isLoading: getIssueIsLoading } = useReadContract({
  address: contractData.address as `0x${string}`,
  abi: contractData.abi,
  functionName: 'getIssue',
  args: [issueNumber],
});
```
</Step>
</Steps>

---

## Заключение

В этом руководстве вы узнали, как использовать функцию `watch` в `useBlockNumber` в сочетании с `useEffect` и `queryClient.invalidateQueries`, чтобы ваш фронтенд мог видеть обновления вашего смарт-контракта. Вы также узнали о затратах на это и некоторые стратегии их снижения. Вы узнали, как передавать аргументы вашим функциям. Наконец, вы узнали, как использовать свойства, возвращаемые `useReadContract`, для настройки пользовательского интерфейса, чтобы улучшить опыт для ваших пользователей.

---

[wagmi]: https://wagmi.sh/
[`useReadContract`]: https://wagmi.sh/react/hooks/useReadContract
[`useReadContract` hook]: ./useReadContract
[`useBlockNumber`]: https://wagmi.sh/react/api/hooks/useBlockNumber
[removed]: https://wagmi.sh/react/guides/migrate-from-v1-to-v2#removed-watch-property
[`useReadContracts`]: https://wagmi.sh/react/hooks/useReadContracts
[`pollingInterval`]: https://wagmi.sh/react/api/createConfig#pollinginterval
