---
title: Отправка сообщений из Base в другие цепи с использованием LayerZero V2
description: Руководство, которое учит, как использовать LayerZero V2 для отправки кросс-чейн сообщений из тестнета Base Sepolia в тестнет Optimism Sepolia.
authors:
  - taycaldwell
---

# Отправка сообщений из Base в другие цепи с использованием LayerZero V2

Это руководство проведет вас через процесс отправки данных кросс-чейн сообщений из смарт-контракта на Base в другой смарт-контракт на другой цепи с использованием LayerZero V2.

## Цели

К концу этого руководства вы должны уметь делать следующее:

- Настроить проект смарт-контрактов для Base с использованием Foundry
- Установить смарт-контракты LayerZero в качестве зависимости
- Использовать LayerZero для отправки и получения сообщений между смарт-контрактами на Base и смарт-контрактами на других цепях
- Развернуть и протестировать свои смарт-контракты в тестнете Base

## Предварительные требования

### Foundry

Для этого руководства требуется установленный Foundry.

- Из командной строки (терминала) выполните: `curl -L https://foundry.paradigm.xyz | bash`
- Затем выполните `foundryup`, чтобы установить последнюю (ночную) сборку Foundry

Для получения дополнительной информации см. [руководство по установке](https://book.getfoundry.sh/getting-started/installation) в Foundry Book.

### Coinbase Wallet

Чтобы развернуть смарт-контракт, вам сначала понадобится кошелек. Вы можете создать кошелек, скачав браузерное расширение Coinbase Wallet.

- Скачайте [Coinbase Wallet](https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad?hl=en)

### Средства в кошельке

Чтобы завершить это руководство, вам нужно пополнить кошелек ETH в Base Sepolia и Optimism Sepolia.

ETH необходим для покрытия комиссий за газ, связанных с развертыванием смарт-контрактов в каждой сети.

- Чтобы пополнить кошелек ETH в Base Sepolia, посетите краны, перечисленные на странице [кранов Base](/base-chain/tools/network-faucets).
- Чтобы пополнить кошелек ETH в Optimism Sepolia, посетите краны, перечисленные на странице [кранов Optimism](https://docs.optimism.io/builders/tools/faucets).

## Что такое LayerZero?

LayerZero - это протокол интероперабельности, который позволяет разработчикам создавать приложения (и токены), которые могут подключаться к нескольким блокчейнам. LayerZero определяет такие приложения как "омниканальные" (omnichain) приложения.

Протокол LayerZero состоит из неизменяемых ончейн [Endpoints](https://docs.layerzero.network/v2/concepts/protocol/layerzero-endpoint), настраиваемого [Security Stack](https://docs.layerzero.network/explore/decentralized-verifier-networks), и набором [Executors](https://docs.layerzero.network/v2/concepts/permissionless-execution/executors) без разрешений, которые передают сообщения между цепями.

### Основные концепции высокого уровня

#### Конечные точки (Endpoints)

Конечные точки - это неизменяемые смарт-контракты LayerZero, которые реализуют стандартизированный интерфейс для использования вашими собственными смарт-контрактами, а также для управления конфигурациями безопасности и отправки и получения сообщений.

#### Стек безопасности (DVNs)

[Security Stack](https://docs.layerzero.network/explore/decentralized-verifier-networks) - это настраиваемый набор обязательных и опциональных Децентрализованных Сетей Верификаторов (DVNs). DVNs используются для проверки полезной нагрузки сообщений, чтобы обеспечить целостность сообщений вашего приложения.

#### Исполнители (Executors)

[Executors](https://docs.layerzero.network/v2/concepts/permissionless-execution/executors) отвечают за инициацию доставки сообщений. Они автоматически выполнят функцию `lzReceive` конечной точки в целевой цепи, как только сообщение будет проверено Стеком безопасности.

## Создание проекта

Прежде чем начать, вам нужно настроить среду разработки смарт-контрактов, создав проект Foundry.

Чтобы создать новый проект Foundry, сначала создайте новую директорию:

```bash
mkdir myproject
```

Затем выполните:

```bash
cd myproject
forge init
```

Это создаст проект Foundry со следующей базовой структурой:

```bash
.
├── foundry.toml
├── script
├── src
└── test
```

<Info>
Вы можете удалить шаблонные файлы `src/Counter.sol`, `test/Counter.t.sol` и `script/Counter.s.sol`, которые были сгенерированы вместе с проектом, так как они вам не понадобятся.
</Info>

## Установка смарт-контрактов LayerZero

Чтобы использовать LayerZero в вашем проекте Foundry, вам нужно установить смарт-контракты LayerZero и их зависимости с помощью `forge install`.

Чтобы установить смарт-контракты LayerZero и их зависимости, выполните следующие команды:

```bash
forge install GNSPS/solidity-bytes-utils --no-commit
forge install OpenZeppelin/openzeppelin-contracts@v4.9.4 --no-commit
forge install LayerZero-Labs/LayerZero-v2 --no-commit
```

После установки обновите ваш файл `foundry.toml`, добавив следующие строки:

```bash
remappings = [
    '@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts',
    'solidity-bytes-utils/=lib/solidity-bytes-utils',
    '@layerzerolabs/lz-evm-oapp-v2/=lib/LayerZero-v2/oapp',
    '@layerzerolabs/lz-evm-protocol-v2/=lib/LayerZero-v2/protocol',
    '@layerzerolabs/lz-evm-messagelib-v2/=lib/LayerZero-v2/messagelib',
]

```

## Начало работы с LayerZero

LayerZero предоставляет стандарт смарт-контрактов под названием [OApp](https://docs.layerzero.network/v2/developers/evm/oapp/overview), предназначенный для омниканального обмена сообщениями и конфигурации.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { OAppSender } from "./OAppSender.sol";
import { OAppReceiver, Origin } from "./OAppReceiver.sol";
import { OAppCore } from "./OAppCore.sol";

abstract contract OApp is OAppSender, OAppReceiver {
   constructor(address _endpoint) OAppCore(_endpoint, msg.sender) {}

   function oAppVersion() public pure virtual returns (uint64 senderVersion, uint64 receiverVersion) {
       senderVersion = SENDER_VERSION;
       receiverVersion = RECEIVER_VERSION;
   }
}
```

<Info>
Вы можете просмотреть исходный код этого контракта на [GitHub](https://github.com/LayerZero-Labs/LayerZero-v2/blob/main/packages/layerzero-v2/evm/oapp/contracts/oapp/OApp.sol).
</Info>

Чтобы начать использовать LayerZero, разработчикам достаточно унаследовать свой контракт от контракта [OApp](https://github.com/LayerZero-Labs/LayerZero-v2/blob/main/packages/layerzero-v2/evm/oapp/contracts/oapp/OApp.sol) и реализовать следующие две унаследованные функции:

- `_lzSend`: Функция, используемая для отправки омниканального сообщения
- `_lzReceive`: Функция, используемая для получения омниканального сообщения

В этом руководстве вы реализуете стандарт [OApp](https://docs.layerzero.network/v2/developers/evm/oapp/overview) в своем собственном проекте, чтобы добавить возможность отправки сообщений из смарт-контракта на Base в смарт-контракт на Optimism.

<Info>
Также доступно расширение стандарта контрактов [OApp](https://docs.layerzero.network/v2/developers/evm/oapp/overview) известное как [OFT](https://docs.layerzero.network/contracts/oft) для поддержки омниканальных переводов взаимозаменяемых токенов.
</Info>

<Info>
Для получения дополнительной информации о переводе токенов между цепями с использованием LayerZero посетите [LayerZero documentation](https://docs.layerzero.network/contracts/oft).
</Info>

## Написание смарт-контракта

Для начала создайте новый файл смарт-контракта Solidity в директории `src/` вашего проекта с именем `ExampleContract.sol`, и добавьте следующее содержимое:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { OApp, Origin, MessagingFee } from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol";

contract ExampleContract is OApp {
   constructor(address _endpoint, address _owner) OApp(_endpoint, _owner) {}
}
```

Фрагмент кода выше определяет новый смарт-контракт с именем `ExampleContract`, который расширяет стандарт контрактов `OApp`.

Конструктор контракта ожидает два аргумента:

- `_endpoint`: The [LayerZero Endpoint](https://docs.layerzero.network/v2/deployments/deployed-contracts) `address` для цепи, в которую развертывается смарт-контракт.
- `_owner`: The `address` владельца смарт-контракта.

<Info>
[LayerZero Endpoints](https://docs.layerzero.network/v2/deployments/deployed-contracts) - это смарт-контракты, которые предоставляют интерфейс для контрактов OApp для управления конфигурациями безопасности и отправки и получения сообщений через протокол LayerZero.
</Info>

### Реализация отправки сообщений (`_lzSend`)

Чтобы отправлять сообщения в другую цепь, ваш смарт-контракт должен вызвать функцию `_lzSend`, унаследованную от контракта [OApp](https://docs.layerzero.network/v2/developers/evm/oapp/overview).

Добавьте новую пользовательскую функцию с именем `sendMessage` в ваш смарт-контракт со следующим содержимым:

```solidity
/// @notice Отправляет сообщение из исходной цепи в цепь назначения.
/// @param _dstEid Идентификатор конечной точки (endpoint ID) цепи назначения.
/// @param _message Сообщение для отправки.
/// @param _options Опции выполнения сообщения (например, газ для использования на стороне назначения).
function sendMessage(uint32 _dstEid, string memory _message, bytes calldata _options) external payable {
   bytes memory _payload = abi.encode(_message); // Кодируем сообщение в байты
   _lzSend(
       _dstEid,
       _payload,
       _options,
       MessagingFee(msg.value, 0), // Комиссия за сообщение (nativeFee, lzTokenFee)
       payable(msg.sender) // Адрес для возврата средств в случае отмены вызова отправки
   );
}
```

Функция `sendMessage` выше вызывает унаследованную функцию `_lzSend`, передавая следующие ожидаемые данные:

| Название             | Тип                                                                                                                                                                      | Описание                                                                                                                                                      |
| :--------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `_dstEid`        | `uint32`                                                                                                                                                                  | [endpoint ID](https://docs.layerzero.network/v2/deployments/deployed-contracts?stages=mainnet&chains=base) цепи назначения, на которую отправляется сообщение.                                  |
| `_payload`       | `bytes`                                                                                                                                                                   | Сообщение (закодированное) для отправки.                                                                                                                                   |
| `_options`       | `bytes`                                                                                                                                                                   | [Дополнительные опции](https://docs.layerzero.network/v2/concepts/message-options#why-do-options-matter) при отправке сообщения, например, сколько газа должно быть использовано при получении сообщения. |
| `_fee`           | [`MessagingFee`](https://github.com/LayerZero-Labs/LayerZero-v2/blob/c3213200dfe8fabbf7d92c685590d34e6e70da43/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol#L24) | Рассчитанная комиссия за отправку сообщения.                                                                                                                      |
| `_refundAddress` | `address`                                                                                                                                                                 | `address` который получит любые излишки комиссии, отправленные на конечную точку, в случае отмены выполнения `_lzSend`.                                              |

### Реализация оценки комиссии за газ (`_quote`)

Как показано в таблице в предыдущем разделе, функция `_lzSend` ожидает предоставления расчетной [fee](https://github.com/LayerZero-Labs/LayerZero-v2/blob/c3213200dfe8fabbf7d92c685590d34e6e70da43/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol#L24) за газ (`_fee`) при отправке сообщения.

Следовательно, для отправки сообщения с помощью функции `sendMessage` вашего контракта сначала необходимо оценить связанные комиссии за газ.

При отправке сообщения между цепями с использованием LayerZero возникает несколько комиссий, включая: оплату газа в исходной цепи, комиссии, выплачиваемые DVNs за проверку сообщения, и газ в цепи назначения. К счастью, LayerZero объединяет все эти комиссии в единую комиссию, которую должен оплатить `msg.sender`, а Конечные точки LayerZero предоставляют функцию `_quote` для оценки этой комиссии.

Добавьте новую функцию в ваш контракт `ExampleContract` с именем `estimateFee`, которая вызывает функцию `_quote`, как показано ниже:

```solidity
/// @notice Оценивает газ, связанный с отправкой сообщения.
/// @param _dstEid Идентификатор конечной точки (endpoint ID) цепи назначения.
/// @param _message Сообщение для отправки.
/// @param _options Опции выполнения сообщения (например, газ для использования на стороне назначения).
/// @return nativeFee Расчетная комиссия за газ в нативной валюте.
/// @return lzTokenFee Расчетная комиссия за газ в токене ZRO.
function estimateFee(
   uint32 _dstEid,
   string memory _message,
   bytes calldata _options
) public view returns (uint256 nativeFee, uint256 lzTokenFee) {
   bytes memory _payload = abi.encode(_message);
   MessagingFee memory fee = _quote(_dstEid, _payload, _options, false);
   return (fee.nativeFee, fee.lzTokenFee);
}
```

Функция `estimateFee` выше вызывает унаследованную функцию `_quote`, передавая следующие ожидаемые данные:

| Название            | Тип     | Описание                                                                                                                                                      |
| :-------------- | :------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `_dstEid`       | `uint32` | [endpoint ID](https://docs.layerzero.network/v2/deployments/deployed-contracts?stages=mainnet&chains=base) цепи назначения, на которую будет отправлено сообщение.                             |
| `_payload`      | `bytes`  | Сообщение (закодированное), которое будет отправлено.                                                                                                                         |
| `_options`      | `bytes`  | [Additional options](https://docs.layerzero.network/v2/concepts/message-options#why-do-options-matter) при отправке сообщения, например, сколько газа должно быть использовано при получении сообщения. |
| `_payInLzToken` | `bool`   | Булев флаг для выбора токена, который будет использоваться при возврате комиссии (нативный или токен ZRO).                                                                                |

<Info>
Функцию `estimateFee` вашего контракта всегда следует вызывать непосредственно перед вызовом `sendMessage` для точной оценки связанных комиссий за газ.
</Info>

### Реализация получения сообщений (`_lzReceive`)

Для получения сообщений в цепи назначения ваш смарт-контракт должен переопределить функцию `_lzReceive`, унаследованную от контракта [OApp](https://docs.layerzero.network/v2/developers/evm/oapp/overview) contract.

Добавьте следующий фрагмент кода в ваш контракт `ExampleContract`, чтобы переопределить функцию `_lzReceive`:

```solidity
/// @notice Точка входа для получения сообщений.
/// @param _origin Информация о происхождении, содержащая идентификатор исходной конечной точки и адрес отправителя.
///  - srcEid: Идентификатор конечной точки исходной цепи.
///  - sender: Адрес отправителя в исходной цепи.
///  - nonce: nonce сообщения.
/// @param _guid Уникальный идентификатор полученного сообщения LayerZero.
/// @param _message Полезная нагрузка полученного сообщения.
/// @param _executor Адрес исполнителя для полученного сообщения.
/// @param _extraData Дополнительные произвольные данные, предоставленные соответствующим исполнителем.
function _lzReceive(
   Origin calldata _origin,
   bytes32 _guid,
   bytes calldata payload,
   address _executor,
   bytes calldata _extraData
   ) internal override {
       data = abi.decode(payload, (string));
       // другая логика
}
```

Переопределенная функция `_lzReceive` получает следующие аргументы при получении сообщения:

| Название      | Тип       | Описание                                                                                                              |
| :------------ | :-------- | :-------------------------------------------------------------------------------------------------------------------- |
| `_origin`     | `Origin`  | Информация о происхождении, содержащая идентификатор исходной конечной точки и адрес отправителя.                                             |
| `_guid`       | `bytes32` | Уникальный идентификатор полученного сообщения LayerZero.                                                            |
| `payload`     | `bytes`   | Полезная нагрузка полученного сообщения (закодированная).                                                                       |
| `_executor`   | `address` | `address` [Executor](https://docs.layerzero.network/v2/concepts/permissionless-execution/executors) для полученного сообщения.           |
| `_extraData ` | `bytes`   | Дополнительные произвольные данные, предоставленные соответствующим [Executor](https://docs.layerzero.network/v2/concepts/permissionless-execution/executors). |

Обратите внимание, что переопределенный метод декодирует полезную нагрузку сообщения и сохраняет строку в переменной `data`, которую вы можете позже прочитать, чтобы получить последнее сообщение.

Добавьте поле `data` как переменную-член вашего контракта:

```solidity
contract ExampleContract is OApp {

    // highlight-next-line
    string public data;

    constructor(address _endpoint) OApp(_endpoint, msg.sender) {}
}
```

<Info>
Переопределение функции `_lzReceive` позволяет вам реализовать любую пользовательскую логику при получении сообщений, включая обратный вызов в исходную цепь путем вызова `_lzSend`. Посетите [Message Design Patterns](https://docs.layerzero.network/v2/developers/evm/oapp/message-design-patterns) для распространенных потоков сообщений.
</Info>

### Финальный код

После выполнения всех шагов выше ваш контракт должен выглядеть так:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { OApp, Origin, MessagingFee } from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol";

contract ExampleContract is OApp {

 string public data;

  constructor(address _endpoint) OApp(_endpoint, msg.sender) {}

  /// @notice Отправляет сообщение из исходной цепи в цепь назначения.
  /// @param _dstEid Идентификатор конечной точки (endpoint ID) цепи назначения.
  /// @param _message Сообщение для отправки.
  /// @param _options Опции выполнения сообщения (например, газ для использования на стороне назначения).
  function sendMessage(uint32 _dstEid, string memory _message, bytes calldata _options) external payable {
     bytes memory _payload = abi.encode(_message); // Кодируем сообщение в байты
     _lzSend(
           _dstEid,
           _payload,
           _options,
           MessagingFee(msg.value, 0), // Комиссия за сообщение (nativeFee, lzTokenFee)
           payable(msg.sender) // Адрес для возврата средств в случае отмены вызова отправки
     );
  }

  /// @notice Оценивает газ, связанный с отправкой сообщения.
  /// @param _dstEid Идентификатор конечной точки (endpoint ID) цепи назначения.
  /// @param _message Сообщение для отправки.
  /// @param _options Опции выполнения сообщения (например, газ для использования на стороне назначения).
  /// @return nativeFee Расчетная комиссия за газ в нативной валюте.
  /// @return lzTokenFee Расчетная комиссия за газ в токене ZRO.
  function estimateFee(
     uint32 _dstEid,
     string memory _message,
     bytes calldata _options
  ) public view returns (uint256 nativeFee, uint256 lzTokenFee) {
     bytes memory _payload = abi.encode(_message);
     MessagingFee memory fee = _quote(_dstEid, _payload, _options, false);
     return (fee.nativeFee, fee.lzTokenFee);
  }

  /// @notice Точка входа для получения сообщений.
  /// @param _origin Информация о происхождении, содержащая идентификатор исходной конечной точки и адрес отправителя.
  ///  - srcEid: Идентификатор конечной точки исходной цепи.
  ///  - sender: Адрес отправителя в исходной цепи.
  ///  - nonce: nonce сообщения.
  /// @param _guid Уникальный идентификатор полученного сообщения LayerZero.
  /// @param _message Полезная нагрузка полученного сообщения.
  /// @param _executor Адрес исполнителя для полученного сообщения.
  /// @param _extraData Дополнительные произвольные данные, предоставленные соответствующим исполнителем.
  function _lzReceive(
     Origin calldata _origin,
     bytes32 _guid,
     bytes calldata payload,
     address _executor,
     bytes calldata _extraData
     ) internal override {
        data = abi.decode(payload, (string));
  }
}
```

## Компиляция смарт-контракта

Скомпилируйте смарт-контракт, чтобы убедиться, что он собирается без ошибок.

Чтобы скомпилировать ваш смарт-контракт, выполните:

```bash
forge build
```

## Развертывание смарт-контракта

### Настройка вашего кошелька как развертывающего

Прежде чем вы сможете развернуть свой смарт-контракт в различных цепях, вам нужно настроить кошелек, который будет использоваться как развертывающий.

Для этого вы можете использовать команду [`cast wallet import`](https://getfoundry.sh/cast/reference/wallet/import#cast-wallet-import), чтобы импортировать приватный ключ кошелька в безопасно зашифрованное хранилище ключей Foundry:

```bash
cast wallet import deployer --interactive
```

После выполнения команды выше вам будет предложено ввести ваш приватный ключ, а также пароль для подписи транзакций.

<Info>
Инструкции о том, как получить ваш приватный ключ из Coinbase Wallet, см. в [документации Coinbase Wallet](https://docs.cloud.coinbase.com/wallet-sdk/docs/developer-settings#show-private-key). **Крайне важно, чтобы вы НЕ сохраняли это в публичном репозитории**.
</Info>

Чтобы подтвердить, что кошелек был импортирован как учетная запись `deployer` в вашем проекте Foundry, выполните:

```bash
cast wallet list
```

### Настройка переменных окружения

Чтобы настроить ваше окружение, создайте файл `.env` в домашней директории вашего проекта и добавьте RPC URL и информацию о [LayerZero Endpoint](https://docs.layerzero.network/v2/deployments/deployed-contracts?chains=base-sepolia%2Coptimism-sepolia) для тестнетов Base Sepolia и Optimism Sepolia:

```bash
BASE_SEPOLIA_RPC="https://sepolia.base.org"
BASE_SEPOLIA_LZ_ENDPOINT=0x6EDCE65403992e310A62460808c4b910D972f10f
BASE_SEPOLIA_LZ_ENDPOINT_ID=40245

OPTIMISM_SEPOLIA_RPC="https://sepolia.optimism.io"
OPTIMISM_SEPOLIA_LZ_ENDPOINT=0x6EDCE65403992e310A62460808c4b910D972f10f
OPTIMISM_SEPOLIA_LZ_ENDPOINT_ID=40232
```

После создания файла `.env` выполните следующую команду, чтобы загрузить переменные окружения в текущую сессию командной строки:

```
source .env
```

Когда ваш контракт скомпилирован и окружение настроено, вы готовы развернуть смарт-контракт в разных сетях.

### Развертывание смарт-контракта в Base Sepolia

Чтобы развернуть смарт-контракт с помощью Foundry, вы можете использовать команду `forge create`. Команда требует указать смарт-контракт, который вы хотите развернуть, RPC URL сети, в которую вы хотите развернуть, и учетную запись, с которой вы хотите развернуть.

<Info>
Ваш кошелек должен быть пополнен ETH в Base Sepolia и Optimism Sepolia для покрытия комиссий за газ, связанных с развертыванием смарт-контракта. В противном случае развертывание завершится неудачей.

Чтобы получить тестовый ETH, см. [prerequisites](#prerequisites).
</Info>

Чтобы развернуть смарт-контракт `ExampleContract` в тестнет Base Sepolia, выполните следующую команду:

```bash
forge create ./src/ExampleContract.sol:ExampleContract --rpc-url $BASE_SEPOLIA_RPC --constructor-args $BASE_SEPOLIA_LZ_ENDPOINT --account deployer
```

Когда появится запрос, введите пароль, который вы установили ранее, при импорте приватного ключа вашего кошелька.

После выполнения команды выше контракт будет развернут в тестовой сети Base Sepolia. Вы можете просмотреть статус развертывания и контракт с помощью [block explorer](/base-chain/tools/block-explorers).

### Развертывание смарт-контракта в Optimism Sepolia

Чтобы развернуть смарт-контракт `ExampleContract` в тестнет Optimism Sepolia, выполните следующую команду:

```bash
forge create ./src/ExampleContract.sol:ExampleContract --rpc-url $OPTIMISM_SEPOLIA_RPC --constructor-args $OPTIMISM_SEPOLIA_LZ_ENDPOINT --account deployer
```

Когда появится запрос, введите пароль, который вы установили ранее, при импорте приватного ключа вашего кошелька.

После выполнения команды выше контракт будет развернут в тестовой сети Optimism Sepolia. Вы можете просмотреть статус развертывания и контракт с помощью [OP Sepolia block explorer](https://sepolia-optimism.etherscan.io/).

## Открытие каналов сообщений

После того как ваш контракт был развернут в Base Sepolia и Optimism Sepolia, вам нужно будет открыть каналы сообщений между двумя контрактами, чтобы они могли отправлять и получать сообщения друг от друга. Это делается путем вызова функции `setPeer` в контракте.

Функция `setPeer` ожидает следующие аргументы:

| Название    | Тип      | Описание                                                                                              |
| :------ | :-------- | :------------------------------------------------------------------------------------------------------- |
| `_eid`  | `uint32`  | The [endpoint ID](https://docs.layerzero.network/v2/deployments/deployed-contracts) цепи назначения.     |
| `_peer` | `bytes32` | Адрес контракта OApp в цепи назначения.                                                                  |

### Установка пиров (peers)

Foundry предоставляет инструмент командной строки `cast`, который можно использовать для взаимодействия с развернутыми смарт-контрактами и вызова их функций.

Чтобы установить пиры ваших контрактов `ExampleContract`, вы можете использовать `cast` для вызова функции `setPeer`, предоставляя [endpoint ID](https://docs.layerzero.network/v2/deployments/deployed-contracts) и адрес (в байтах) развернутого контракта в соответствующей цепи назначения.

Чтобы установить пир контракта Base Sepolia на контракт Optimism Sepolia, выполните следующую команду:

```bash
cast send <BASE_SEPOLIA_CONTRACT_ADDRESS> --rpc-url $BASE_SEPOLIA_RPC "setPeer(uint32, bytes32)" $OPTIMISM_SEPOLIA_LZ_ENDPOINT_ID <OPTIMISM_SEPOLIA_CONTRACT_ADDRESS> --account deployer
```

<Info>
Замените `<BASE_SEPOLIA_CONTRACT_ADDRESS>` на адрес контракта вашего развернутого контракта `ExampleContract` в Base Sepolia, а `<OPTIMISM_SEPOLIA_CONTRACT_ADDRESS>` на адрес контракта (в байтах) вашего развернутого контракта `ExampleContract` в Optimism Sepolia перед выполнением предоставленной команды `cast`.
</Info>

Чтобы установить пир контракта Optimism Sepolia на контракт Base Sepolia, выполните следующую команду:

```bash
cast send <OPTIMISM_SEPOLIA_CONTRACT_ADDRESS> --rpc-url $OPTIMISM_SEPOLIA_RPC "setPeer(uint32, bytes32)" $BASE_SEPOLIA_LZ_ENDPOINT_ID <BASE_SEPOLIA_CONTRACT_ADDRESS> --account deployer
```

<Info>
Замените `<OPTIMISM_SEPOLIA_CONTRACT_ADDRESS>` на адрес контракта вашего развернутого контракта `ExampleContract` в Optimism Sepolia, а `<BASE_SEPOLIA_CONTRACT_ADDRESS>` на адрес контракта (в байтах) вашего развернутого контракта `ExampleContract` в Base Sepolia перед выполнением предоставленной команды `cast`.
</Info>

## Отправка сообщений

После того как пиры установлены на каждом контракте, они теперь могут отправлять и получать сообщения друг от друга.

Отправка сообщения с использованием вновь созданного контракта ExampleContract может быть выполнена в три шага:

1. Построить [message options](https://docs.layerzero.network/v2/developers/evm/toolbox#building-message-options) для указания логики, связанной с транзакцией сообщения
2. Вызвать функцию `estimateFee` для оценки комиссии за газ для отправки сообщения
3. Вызвать функцию `sendMessage` для отправки сообщения

### Построение опций сообщения

Пользовательские функции `estimateFee` и `sendMessage` контракта `ExampleContract` обе требуют предоставления аргумента [message options](https://docs.layerzero.network/v2/developers/evm/toolbox#building-message-options) (`_options`).

Опции сообщения позволяют вам указать произвольную логику как часть транзакции сообщения, например, количество газа, которое [Executor](https://docs.layerzero.network/v2/concepts/permissionless-execution/executors) платит за доставку сообщения, порядок выполнения сообщений или отправку определенного количества газа на адрес назначения.

LayerZero предоставляет библиотеку [Solidity](https://github.com/LayerZero-Labs/LayerZero-v2/blob/ccfd0d38f83ca8103b14ab9ca77f32e0419510ff/oapp/contracts/oapp/libs/OptionsBuilder.sol#L12) и [TypeScript SDK](https://docs.layerzero.network/plugins#layerzerolabssg-sdk) для построения этих опций сообщения.

В качестве примера ниже приведен скрипт Foundry, который использует OptionsBuilder из библиотеки Solidity для генерации опций сообщения (в виде `bytes`), устанавливающих количество газа, которое Исполнитель заплатит при доставке сообщения, равным `200000` wei:

```solidity
pragma solidity ^0.8.0;

import {Script, console2} from "forge-std/Script.sol";
import { OptionsBuilder } from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol";

contract OptionsScript is Script {
    using OptionsBuilder for bytes;

    function setUp() public {}

    function run() public {
        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        console2.logBytes(options);
    }
}
```

Результат выполнения этого скрипта:

```bash
0x00030100110100000000000000000000000000030d40
```

Для этого руководства, вместо построения и генерации ваших собственных опций сообщения, вы можете использовать вывод в байтах, предоставленный выше.

<Info>
Подробное рассмотрение всех различных опций сообщений выходит за рамки этого руководства. Если вы заинтересованы узнать больше о различных опциях сообщений и том, как их строить, посетите [LayerZero developer documentation](https://docs.layerzero.network/v2/developers/evm/overview).
</Info>

### Оценка комиссии за газ

режде чем вы сможете отправить сообщение из вашего контракта в Base Sepolia, вам нужно оценить комиссию, связанную с отправкой сообщения. Вы можете использовать команду `cast` для вызова функции `estimateFee()` контракта `ExampleContract`.

Чтобы оценить комиссию за газ для отправки сообщения из Base Sepolia в Optimism Sepolia, выполните следующую команду:

```bash
cast send <BASE_SEPOLIA_CONTRACT_ADDRESS> --rpc-url $BASE_SEPOLIA_RPC "estimateFee(uint32, string, bytes)" $OPTIMISM_SEPOLIA_LZ_ENDPOINT_ID "Hello World" 0x00030100110100000000000000000000000000030d40 --account deployer
```

<Info>
Замените `<BASE_SEPOLIA_CONTRACT_ADDRESS>` на адрес контракта вашего развернутого контракта `ExampleContract` в Base Sepolia перед выполнением предоставленной команды `cast`.
</Info>

Команда выше вызывает `estimateFee(uint32, string, bytes, bool)`, предоставляя необходимые аргументы, включая: идентификатор конечной точки цепи назначения, текст для отправки и опции сообщения (сгенерированные в предыдущем разделе).

### Отправка сообщения

После того как вы получили расчетный газ для отправки вашего сообщения, вы теперь можете вызвать `sendMessage` и предоставить возвращенное значение как `msg.value`.

Например, чтобы отправить сообщение из Base Sepolia в Optimism Sepolia с расчетной комиссией за газ, выполните следующую команду:

```bash
cast send <BASE_SEPOLIA_CONTRACT_ADDRESS> --rpc-url $BASE_SEPOLIA_RPC --value <GAS_ESTIMATE_IN_WEI> "sendMessage(uint32, string, bytes)" $OPTIMISM_SEPOLIA_LZ_ENDPOINT_ID "Hello World" 0x00030100110100000000000000000000000000030d40 --account deployer
```

<Info>
Замените `<BASE_SEPOLIA_CONTRACT_ADDRESS>` на адрес контракта вашего развернутого контракта `ExampleContract` в Base Sepolia, а `<GAS_ESTIMATE_IN_WEI>` на оценку газа (в wei), возвращенную вызовом estimateFee, перед выполнением предоставленной команды `cast`.
</Info>

Вы можете просмотреть статус вашей кросс-чейн транзакции на [LayerZero Scan](https://layerzeroscan.com/).

### Получение сообщения

Как только сообщение будет отправлено и получено в цепи назначения, на контракте `ExampleContract` будет вызвана функция `_Receive`
