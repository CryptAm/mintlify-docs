---
title: Абстракция аккаунтов на Base с использованием Particle Network
description: Обзор модульного решения Particle Network «Смарт-кошелек как услуга», использующего абстракцию аккаунтов и социальные входы через различных провайдеров.
authors:
  - TABASCOatw
---

# Абстракция аккаунтов на Base с использованием Particle Network

Particle Network - это провайдер решения «Смарт-кошелек как услуга» (Smart Wallet-as-a-Service) на Base, предоставляющий модульный стек для абстракции аккаунтов, позволяющий разработчикам использовать различные Paymasters, Bundlers или смарт-аккаунты вместе с социальными входами.

Это руководство проведет вас через процесс использования Particle Network в вашем приложении на Base, создавая простой React-проект с использованием `create-react-app`, Particle Auth Core и AA SDK от Particle.

## Цели

К концу этого руководства вы сможете:

- Использовать Particle Auth Core для генерации аккаунта, управляемого извне (EOA), через социальный вход
- Назначить выбранный смарт-аккаунт для EOA, сгенерированного Particle Auth Core
- Настроить Bundler и Paymaster
- Создать и выполнить транзакцию без оплаты газа (gasless transaction)

## Предварительные требования

### Средства в кошельке

Для этого руководства требуется наличие ETH в сети Base Sepolia, который будет использоваться для демонстрации выполнения транзакции сжигания без газа.

- Чтобы пополнить ваш кошель ETH в сети Base Sepolia, посетите один из кранов (faucets), перечисленных на странице [краны Base](https://docs.base.org/base-chain/tools/network-faucets).

### Знакомство с современной фронтенд-разработкой

В этом примере вы будете создавать приложение на основе React с использованием [create-react-app]. Рекомендуется иметь некоторый уровень знакомства с основами работы с React.

## Понимание Particle Network

### Кошелек как услуга (Wallet-as-a-Service)

Particle Network предоставляет большой набор SDK, сосредоточенных на уменьшении трения, связанного с аккаунтами.

В данном случае, "account-based friction" относится к барьерам для входа, с которыми могут столкнуться некоторые пользователи Web3 при онбординге в приложение и начале управления кошельком.

Это трение, в контексте данного руководства, можно разделить на две отдельные категории:

1. Процесс входа. Часто децентрализованные приложения, ориентированные на потребителей, предпочитают потоки входа, которые не зависят от скачивания и управления пользователем традиционного кошелька, так как это может быть проблемой для некоторых.
2. Жесткость стандартных аккаунтов. Аккаунты, управляемые извне (EOA), часто довольно жестки в своей работе. Они защищены одним ключом и ограничены строгим набором функций, поэтому разработчики (и, следовательно, пользователи) ограничены относительно низкоуровневым взаимодействием с приложениями.

Кошелек как услуга (WaaS) направлен на решение первой из этих двух проблем - процесса входа. Решения WaaS предоставляют альтернативу стандартным кошелькам, обычно позволяя пользователям использовать приложения через аккаунты, созданные с помощью социальных входов (таких как Google, email или телефон). Интерфейсы для взаимодействия с этими аккаунтами также часто встраиваются в приложения, что приводит к последовательному, специфичному для приложения опыту.

Провайдеры WaaS, помимо Particle Network, включают [Web3Auth], [Privy], и [Magic], среди прочих.

### Абстракция аккаунтов (Account Abstraction)

Particle Network также стремится решить вторую проблему трения, описанную выше: гибкость аккаунтов.

Абстракция аккаунтов относится к переходу от стандартных структур аккаунтов, EOA, к смарт-аккаунтам. Смарт-аккаунты - это контракты, которые действуют как кошелек, предоставляя пользователям аккаунт, который ощущается эквивалентно EOA, но внутренне программируем (поскольку это смарт-контракт) и, следовательно, более гибок.

Самая популярная современная реализация абстракции аккаунтов - [ERC-4337], которая позволяет использовать абстракцию аккаунтов без каких-либо изменений протокола на уровне консенсуса. Это достигается с помощью многочисленных компонентов поддерживающей инфраструктуры, включая Bundler и Paymaster.

Particle Network описывает свой стек абстракции аккаунтов как модульный, подразумевая кросс-совместимость с любым провайдером Bundlers, Paymasters или смарт-аккаунтов. AA SDK от Particle Network запускает и использует собственные Bundler и Paymaster, со встроенной поддержкой Paymaster от [Biconomy]. Однако Particle упростил подключение к [external infrastructure and components], таким как Paymasters или Bundlers от провайдеров, таких как Stackup или Pimlico.

#### Кошелек как услуга + Абстракция аккаунтов

Использование абстракции аккаунтов напрямую с кошельком как услугой позволяет пользователям проходить онбординг через социальные входы во встроенные кошельки, которые используют смарт-аккаунты, а не EOA, что позволяет достичь большей степени гибкости.

Particle Network делает это, позволяя разработчикам использовать свой AA SDK вместе со своим SDK для кошелька как услуги (Particle Auth) для облегчения взаимодействия между обеими технологиями, как мы рассмотрим в этом руководстве.

<Info>
Чтобы узнать больше об абстракции аккаунтов и концепциях, описанных выше, см. [ERC-4337], или руководство Base [Introduction to Account Abstraction].
</Info>

## Настройка фронтенда

Это руководство проведет вас через процесс создания приложения на основе React с помощью шаблона `create-react-app`, как показано ниже.

### Создание React-проекта

Для начала нам нужно инициализировать стандартный проект `create-react-app` project.

В выбранной вами IDE выполните следующую команду, заменив `{name}` на имя вашего проекта.

```bash
npx create-react-app {name}
```

Это создаст React-проект в директории с именем, которое вы указали в `{name}`. По умолчанию эта директория должна содержать следующую структуру:

```bash
{name}/
├── node_modules/
├── public/
├── src/
├── .gitignore
├── package.json
├── package-lock.json
└── README.md
```

На протяжении этого руководства мы в основном будем работать с папкой `src` и файлами внутри нее. По умолчанию `src` будет содержать следующее:

```bash
src/
├── App.css
├── App.js
├── App.test.js
├── index.css
├── index.js
├── logo.svg
└── reportWebVitals.js
```

Эта структура не будет работать из коробки, так как наш пример использует JSX, расширение синтаксиса, которое требует специального типа файла. Таким образом, вам нужно изменить расширение файлов `App.js` и `index.js` на `.jsx` (JavaScript) или `.tsx` (TypeScript).

Мы будем использовать эти два файла, `App.tsx` и `index.tsx`, в этом руководстве.

## Конфигурация и инициализация Particle Network

### Установка зависимостей

Прежде чем перейти к самому приложению, важно рассмотреть несколько важных конфигураций, необходимых для правильной работы SDK от Particle Network.

В этом примере мы будем использовать три основные библиотеки от Particle, включая:

- `@particle-network/auth-core-modal`, для непосредственного инициирования социального входа и управления использованием встроенного кошелька.
- `@particle-network/aa`, для конфигурации, назначения и развертывания смарт-аккаунта.
- `@particle-network/chain`, чтобы позволить использовать Base в этом примере.

Чтобы добавить их в качестве зависимостей в ваш проект, выполните одну из двух следующих команд в корне вашего проекта.

```bash
yarn add @particle-network/auth-core-modal @particle-network/aa @particle-network/chains

# OR

npm install @particle-network/auth-core-modal @particle-network/aa @particle-network/chains
```

В дополнение к вышеуказанным библиотекам от `@particle-network`, мы будем использовать Ethers для основных функций, таких как получение баланса пользователя, отправка транзакции без газа и т.д.

Для простоты мы будем использовать Ethers v5.7.2, последний релиз перед обновлением до Ethers v6. Хотя, если вы хотите использовать более новую версию (v6), комментарии с указанием нового синтаксиса v6 будут оставлены в фрагментах кода на протяжении этого руководства.

Таким образом, вам нужно установить Ethers с помощью одной из следующих команд:

```bash
yarn add ethers@5.7.2

# OR

npm install ethers@5.7.2
```

### Настройка дашборда Particle Network

Как вы сейчас увидите, каждая библиотека от Particle Network требует трех ключевых значений для аутентификации. Это:

1. Ваш `projectId`, назначенный проекту, созданному через дашборд Particle.
2. Ваш `clientKey`, также назначенный проекту, созданному через дашборд, но служащий другой цели.
3. Ваш `appId`, полученный при создании приложения (внутри проекта) на дашборде.

Конфигурация как `@particle-network/auth-core-modal` так и `@particle-network/aa` потребует получения и использования этих трех значений.

Чтобы создать проект и приложение через дашборд Particle:

1. Перейдите по адресу https://dashboard.particle.network.
2. Создайте новую учетную запись (с помощью вашей электронной почты).
3. Нажмите "Add New Project" и введите имя вашего проекта.
4. Скопируйте и сохраните "Project ID" и "Client Key."
5. Создайте новое приложение. Для этого примера мы выберем "Web."
6. Снова введите имя вашего проекта, а также домен, на котором вы планируете разместить это приложение. Если у вас нет конкретного домена, можете использовать любой заполнитель (например, 'base.org'), так как это не повлияет на основные функциональные возможности.
7. Скопируйте "App ID", показанный после создания приложения.

Получив эти значения, рекомендуется присвоить их переменным окружения в вашем приложении, например `REACT_APP_PROJECT_ID`, `REACT_APP_CLIENT_KEY`, и `REACT_APP_APP_ID`.

### Конфигурация Particle Auth Core

Теперь, когда вы установили `@particle-network/auth-core-modal` (среди других зависимостей) и получили свой project ID, client key и app ID, вы готовы настроить и, следовательно, инициализировать SDK Particle Auth Core.

Как упоминалось, в этом руководстве мы будем работать с двумя файлами:

1. `App.jsx/tsx`, содержащий нашу основную логику приложения (например, инициирование социального входа и выполнение транзакции).
2. `index.jsx/tsx`, используемый в этом примере для конфигурации `AuthCoreContextProvider` из `@particle-network/auth-core-modal`, основного объекта конфигурации для Particle Auth Core.

`AuthCoreContextProvider` - это React-компонент, используемый для определения этих трех упомянутых значений, настройки модального окна встроенного кошелька и включения абстракции аккаунтов в нем. Это обернет наш основной компонент приложения (`App` из `App.jsx/tsx`), что позволит использовать Particle Auth Core через различные хуки внутри `App`.

Для этого `AuthCoreContextProvider` будет принимать следующие параметры:

- `projectId`, `clientKey`, и `appId`. Это обязательные значения, ранее полученные из [Particle dashboard].
- `erc4337`, используется для определения типа смарт-аккаунта, который вы собираетесь использовать, гарантируя его отображение и отражение в интерфейсе встроенного кошелька.
- `wallet`, для настройки интерфейса встроенного кошелька через ограничение поддерживаемых сетей, цветовых опций и т.д.

С учетом этого ниже приведен пример того, как может выглядеть ваш файл `index.jsx/tsx` при использовании `AuthCoreContextProvider`.

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';

import { AuthType } from '@particle-network/auth-core';
import { BaseSepolia } from '@particle-network/chains';
import { AuthCoreContextProvider } from '@particle-network/auth-core-modal';

import App from './App';

// Опционально, требуется для некоторых сред
import('buffer').then(({ Buffer }) => {
  window.Buffer = Buffer;
});
// -----

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <AuthCoreContextProvider
      options={{
        projectId: process.env.REACT_APP_PROJECT_ID,
        clientKey: process.env.REACT_APP_CLIENT_KEY,
        appId: process.env.REACT_APP_APP_ID,
        erc4337: {
          // Имя смарт-аккаунта, который вы хотите использовать
          // SIMPLE, BICONOMY, LIGHT, или CYBERCONNECT
          name: 'SIMPLE',
          // Версия используемого смарт-аккаунта
          // 1.0.0 для всего, кроме Biconomy, которая может быть 1.0.0 или 2.0.0
          version: '1.0.0',
        },
        wallet: {
          // Установите false, чтобы скрыть модальное окно встроенного кошелька
          visible: true,
          customStyle: {
            // Фиксирует выбор сети на Base Sepolia
            supportChains: [BaseSepolia],
          },
        },
      }}
    >
      <App />
    </AuthCoreContextProvider>
  </React.StrictMode>,
);
```

## Настройка вашего приложения

### Импорт и конфигурация хуков

Вторым основным компонентом этого приложения является `App.jsx/tsx`, который будет содержать логику для достижения следующего:

1. Конфигурация и назначение смарт-аккаунта (в данном примере SimpleAccount).
2. Создание пользовательского провайдера Ethers с использованием пользовательского объекта провайдера EIP-1193 с поддержкой AA.
3. Инициирование социального входа.
4. Выполнение транзакции без газа.

Для этого мы будем использовать комбинацию хуков (из `@particle-network/auth-core-modal`) и базовых функций Ethers, которые будут автоматически работать через AA с помощью пользовательского объекта провайдера EIP-1193.

Эти хуки включают `useEthereum` для получения стандартного объекта провайдера на основе EOA, `useConnect` для управления социальными входами и `useAuthCore` для получения информации о пользователе (после социального входа).

Чтобы начать создавать `App.jsx/tsx`, вам нужно определить соответствующие функции из этих хуков через процесс, аналогичный примеру ниже:

```tsx
import React, { useState, useEffect } from 'react';
import { useEthereum, useConnect, useAuthCore } from '@particle-network/auth-core-modal';
import { BaseSepolia } from '@particle-network/chains';
import { AAWrapProvider, SendTransactionMode, SmartAccount } from '@particle-network/aa';
import { ethers } from 'ethers';

import './App.css';

const App = () => {
  // Стандартный объект провайдера 1193 на основе EOA
  const { provider } = useEthereum();
  // Используется для инициирования социального входа и отключения пользователей (после входа)
  const { connect, disconnect } = useConnect();
  // Автоматически загружается с соответствующей информацией о пользователе после входа
  const { userInfo } = useAuthCore();
};
```

## Конфигурация смарт-аккаунта

### Выбор и определение смарт-аккаунта

EOA, сгенерированный в процессе социального входа, будет использоваться в качестве Signer для смарт-аккаунта, указанного в этой конфигурации, что затем будет отражено в модальном окне встроенного кошелька (через его предыдущий выбор в `AuthCoreContextProvider`).

Как упоминалось, Particle Network поддерживает различные смарт-аккаунты напрямую через свой AA SDK, включая:

- Light Account (от Alchemy).
- Biconomy V1 и V2.
- SimpleAccount (eth-infinitism).
- CyberConnect.

В данном случае мы будем использовать SimpleAccount. Однако обратите внимание, что вы можете изменить используемый смарт-аккаунт в любой момент с помощью одной строки кода. Эта строка кода существует в объекте `SmartAccount` (импортированном из `@particle-network/aa`). `SmartAccount` действует как центральная точка для инициализации смарт-аккаунта.

Чтобы настроить `SmartAccount`, вы будете использовать следующие параметры:

- `projectId`, `clientKey`, и `appId`. Они использовались в `AuthCoreContextProvider` и могут быть получены из [Particle dashboard] через ту же процедуру.
- `aaOptions`, который содержит `accountContracts`. Внутри `accountContracts`, вам нужно определить свойство, соответствующее смарт-аккаунту, который вы хотите использовать, т.е. `BICONOMY`, `LIGHT`, `CYBERCONNECT`, или `SIMPLE`.
  - Это свойство содержит `chainIds` и `version`.

См. фрагмент ниже для примера созданного объекта `SmartAccount`:

```tsx
import React, { useState, useEffect } from 'react';
import { useEthereum, useConnect, useAuthCore } from '@particle-network/auth-core-modal';
import { BaseSepolia } from '@particle-network/chains';
import { AAWrapProvider, SendTransactionMode, SmartAccount } from '@particle-network/aa';
import { ethers } from 'ethers';

import './App.css';

const App = () => {
  ...

  const smartAccount = new SmartAccount(provider, {
    projectId: process.env.REACT_APP_PROJECT_ID,
    clientKey: process.env.REACT_APP_CLIENT_KEY,
    appId: process.env.REACT_APP_APP_ID,
    aaOptions: {
      accountContracts: {
        SIMPLE: [{ chainIds: [BaseSepolia.id], version: '1.0.0' }]
        // BICONOMY: [{ chainIds: [BaseSepolia.id], version: '1.0.0' }]
        // BICONOMY: [{ chainIds: [BaseSepolia.id], version: '2.0.0' }]
        // LIGHT: [{ chainIds: [BaseSepolia.id], version: '1.0.0' }]
        // CYBERCONNECT: [{ chainIds: [BaseSepolia.id], version: '1.0.0' }]
      }
    }
  });
};
```

### Создание пользовательского объекта Ethers

Существует два основных механизма взаимодействия с смарт-аккаунтом, определенным ранее. Это:

1. Напрямую через созданный объект `SmartAccount` например, с помощью `{your object}.sendTransaction`.
2. Через библиотеку Web3, такую как Ethers или Web3.js. Эти библиотеки могут облегчить взаимодействие через стандартизированный объект провайдера, позволяя использовать последовательный синтаксис и настройку с любым кошельком или структурой аккаунта.

Как упоминалось, мы будем использовать Ethers в этом руководстве. Вы сможете использовать любой типичный метод Ethers, такой как `sendTransaction` или `getBalance` через провайдер с поддержкой AA, который мы создадим с помощью `AAWrapProvider` (импортирован из `@particle-network/aa`).

По сути, мы создадим экземпляр `AAWrapProvider`, передав ранее определенный объект `SmartAccount` вместе с объектом, представляющим выбранный метод оплаты газа. Это позволит Ethers напрямую загрузить смарт-аккаунт и выполнять транзакции/подписи через встроенный кошелек Particle.

Вы можете достичь этого одной строкой кода, например:

```tsx
// Для Ethers V6 используйте ethers.BrowserProvider; синтаксис ниже не будет работать.
const customProvider = new ethers.providers.Web3Provider(
  new AAWrapProvider(smartAccount, SendTransactionMode.Gasless),
  'any',
);
```

`SendTransactionMode` имеет три варианта. Это:

1. `SendTransactionMode.Gasless`, который будет запрашивать спонсирование газа для каждой транзакции, отправленной через Ethers. По умолчанию это будет через Omnichain Paymaster от Particle. Если у вас недостаточно USDT, внесенных в Paymaster для покрытия комиссий за газ, или если транзакция не соответствует вашим условиям спонсирования (установленным на дашборде Particle), пользователь заплатит комиссии за газ самостоятельно.
2. `SendTransactionMode.UserPaidNative`, метод по умолчанию, используемый, если `SendTransactionMode` отсутствует в `AAWrapProvider`. Это заставляет пользователя платить комиссии за газ самостоятельно.
3. `SendTransactionMode.UserSelect`, который позволяет пользователю выбрать механизм оплаты комиссий за газ (токен ERC-20, нативный токен или запрос спонсирования).

В этом примере мы используем `SendTransactionMode.Gasless`. Поскольку этот пример использует Base Sepolia, все транзакции будут автоматически спонсироваться.

## Инициирование социального входа

### Вызов функции connect

На этом этапе вы настроили Particle Auth Core, инициализировали выбранный смарт-аккаунт и создали пользовательский провайдер Ethers для выполнения ончейн-взаимодействия.

Как отмечалось ранее, одним из основных преимуществ кошелька как услуги является возможность онбординга пользователей через их социальные аккаунты. В данном случае социальный вход пользователя напрямую создаст или войдет в смарт-аккаунт (если он уже создал его через Particle Auth), позволяя немедленно использовать абстракцию аккаунтов.

Чтобы программно инициировать процесс социального входа, вам нужно использовать функцию `connect`, определенную из хука `useConnect` импортированного ранее (из `@particle-network/auth-core-modal`).

При вызове `connect`, пользователь пройдет процесс социального входа, после чего будет сгенерирован EOA (через MPC-TSS) и использован в качестве signer для смарт-аккаунта.

`connect` принимает следующие параметры:

- `socialType`, конкретный механизм социального входа, через который вы хотите провести пользователей. Если оставить пустой строкой, будет показано общее модальное окно социального входа. В противном случае используйте строки, такие как 'google', 'twitter', 'email' и т.д.
- `chain`, объект (импортированный из `@particle-network/chains`) соответствующий сети, которую вы хотите использовать. В этом примере это будет `BaseSepolia`.

В идеале следует установить некоторую логику, чтобы убедиться, что connect не вызывается, если пользователь уже вошел в систему. Это можно сделать, вызывая `connect` только при условии, что `userInfo` (из `useAuthCore`) не определен, что указывает на то, что пользователь не вошел в систему.

Ниже приведен пример вызова `connect` (в рамках условия, описанного выше).

```tsx
const handleLogin = async (authType) => {
  if (!userInfo) {
    await connect({
      socialType: authType,
      chain: BaseSepolia,
    });
  }
};
```

В большинстве приложений `connect` (или `handleLogin` в этом примере) будет привязан к кнопке "Login" или "Connect", как будет сделано здесь.

## Выполнение транзакции без газа

### Создание транзакции

Поскольку мы используем Ethers в этом руководстве, создание и выполнение транзакции без газа (по сути без газа благодаря ранее определенному `SendTransactionMode`) идентично потоку, с которым вы, вероятно, уже знакомы. Однако важно отметить, что транзакции, отправленные через абстракцию аккаунтов ERC-4337, не следуют стандартным структурам транзакций; они называются UserOperations (пользовательские операции).

Обычно UserOperations следуют низкоуровневым, альтернативным структурам. Хотя при использовании `AAWrapProvider` преобразование между простым объектом транзакции (с `to`, `value`, `data` и т.д.) в полную UserOperation обрабатывается автоматически, позволяя вам отправлять транзакции как обычно.

Таким образом, мы создадим простую транзакцию (`tx`), соответствующую следующей структуре:

- `to`, адрес получателя. Для этого примера мы можем сжечь небольшое количество ETH в сети Base Sepolia, что означает, что получателем будет `0x000000000000000000000000000000000000dEaD`.
- `value`, отправляемое значение в wei. Из-за деноминации по умолчанию в wei это будет установлено как `ethers.utils.parseEther("0.001")`.

Если вы планируете взаимодействовать с контрактом, `data` также может быть заполнен (или в Ethers можно построить объект `Contract`).

Следовательно, ваш объект `tx` должен выглядеть так:

```tsx
const executeUserOp = async () => {
    ...

    const tx = {
      to: "0x000000000000000000000000000000000000dEaD",
      value: ethers.utils.parseEther("0.001"),
    };

    ...
};
```

### Выполнение транзакции

Теперь, когда вы определили стандартный объект транзакции, вам нужно его выполнить. Опять же, благодаря использованию Ethers это довольно просто.

Мы будем использовать объект `signer` полученный из `{your provider}.getSigner()` чтобы вызвать метод `sendTransaction` который просто принимает объект `tx` который мы создали мгновение назад.

При вызове `signer.sendTransaction(tx)`, пользователю будет предложено подтвердить транзакцию (подписать хэш UserOperation) через всплывающее окно, встроенное в приложение. После этого транзакция будет немедленно отправлена в сети Base Sepolia.

Чтобы отразить хэш транзакции после его подтверждения в блокчейне, вы можете вызвать метод `wait` для переменной, в которую вы сохранили результат `signer.sendTransaction(tx)`. Результирующий объект будет содержать значение `transactionHash`.

См. пример ниже для визуализации этого процесса:

```tsx
const executeUserOp = async () => {
  const signer = customProvider.getSigner();

  const tx = {
    to: '0x000000000000000000000000000000000000dEaD',
    value: ethers.utils.parseEther('0.001'),
  };

  const txResponse = await signer.sendTransaction(tx);
  const txReceipt = await txResponse.wait();

  return txReceipt.transactionHash;
};
```

## Отображение в JSX

Теперь вы инициировали социальный вход (через `handleLogin`), назначили смарт-аккаунт (через `SmartAccount`), и выполнили транзакцию без газа (через `executeUserOp`).

Чтобы представить все это пользователю и позволить ему взаимодействовать с этими функциями самостоятельно, вам нужно сопоставить `handleLogin` и `executeUserOp` с JSX вашего компонента `App`. Это отформатирует фронтенд, с которым взаимодействует пользователь, для тестирования этого приложения.

По сути, это отображает либо "Sign in with Google" или "Sign in with Twitter" через пользовательские кнопки, которые показываются только если пользователь не вошел в систему (определяется через состояние `userInfo`). После входа пользователь может либо вызвать `executeUserOp`, либо `disconnect` (который был определен из `useConnect`).

Ниже приведен пример того, как ваш файл `App.jsx/tsx` может выглядеть на этом этапе. Внизу этого фрагмента вы найдете JSX:

```tsx
import React, { useState, useEffect } from 'react';

import { useEthereum, useConnect, useAuthCore } from '@particle-network/auth-core-modal';
import { BaseSepolia } from '@particle-network/chains';
import { AAWrapProvider, SmartAccount, SendTransactionMode } from '@particle-network/aa';

import { ethers } from 'ethers';

import './App.css';

const App = () => {
  const { provider } = useEthereum();
  const { connect, disconnect } = useConnect();
  const { userInfo } = useAuthCore();

  // Инициализирует и назначает смарт-аккаунт для EOA, полученного в результате социального входа
  const smartAccount = new SmartAccount(provider, {
    projectId: process.env.REACT_APP_PROJECT_ID,
    clientKey: process.env.REACT_APP_CLIENT_KEY,
    appId: process.env.REACT_APP_APP_ID,
    aaOptions: {
      accountContracts: {
        SIMPLE: [{ chainIds: [BaseSepolia.id], version: '1.0.0' }],
      },
    },
  });

  // Позволяет взаимодействовать со смарт-аккаунтом через Ethers
  const customProvider = new ethers.providers.Web3Provider(
    new AAWrapProvider(smartAccount, SendTransactionMode.Gasless),
    'any',
  );

  // Инициирует социальный вход в соответствии с authType
  const handleLogin = async (authType) => {
    if (!userInfo) {
      await connect({
        socialType: authType,
        chain: BaseSepolia,
      });
    }
  };

  // Выполняет безгазовое сжигание 0.001 ETH
  const executeUserOp = async () => {
    const signer = customProvider.getSigner();

    const tx = {
      to: '0x000000000000000000000000000000000000dEaD',
      value: ethers.utils.parseEther('0.001'),
    };

    const txResponse = await signer.sendTransaction(tx);
    const txReceipt = await txResponse.wait();

    return txReceipt.transactionHash;
  };

  // The JSX
  return (
    <div className="App">
      <div className="logo-section">
        <img src="https://i.imgur.com/EerK7MS.png" alt="Logo 1" className="logo logo-big" />
        <img src="https://i.imgur.com/1RV3pMV.png" alt="Logo 2" className="logo" />
      </div>
      {!userInfo ? (
        <div className="login-section">
          <button className="sign-button" onClick={() => handleLogin('google')}>
            Sign in with Google
          </button>
          <button className="sign-button" onClick={() => handleLogin('twitter')}>
            Sign in with Twitter
          </button>
        </div>
      ) : (
        <div className="profile-card">
          <h2>{userInfo.name}</h2>
          <div className="button-section">
            <button className="sign-message-button" onClick={executeUserOp}>
              Execute User Operation
            </button>
            <button className="disconnect-button" onClick={() => disconnect()}>
              Logout
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default App;
```

После завершения всего вы готовы запустить ваше приложение для тестирования. Для этого выполните следующие шаги:

1. Перейдите в корень вашего проекта.
2. Запустите либо `npm run start` или `yarn start`.
3. После запуска войдите с помощью вашего Google или Twitter.
4. Пополните адрес, отображаемый в модальном окне кошелька в правом нижнем углу.
5. Нажмите «Execute User Operation».

## Заключение

Поздравляем! Вы только что создали приложение с нуля, проводя онбординг пользователей в смарт-аккаунты через социальные входы с использованием Particle Network.

Чтобы узнать больше об использовании Particle Network на Base, ознакомьтесь со следующими ресурсами:

- [Biconomy Guide (which uses Particle Network)]
- [Account Abstraction on Base]
- [Particle Network Documentation]
- [Particle Network 101: Developer Experience]

[create-react-app]: https://create-react-app.dev
[Base Faucets]: https://docs.base.org/base-chain/tools/network-faucets
[Web3Auth]: https://web3auth.io
[Privy]: https://docs.base.org/tutorials/account-abstraction-with-privy-and-base-paymaster/
[Magic]: https://magic.link
[ERC-4337]: https://eips.ethereum.org/EIPS/eip-4337
[Biconomy]: https://docs.base.org/guides/account-abstraction-with-biconomy
[external infrastructure and components]: https://blog.particle.network/announcing-our-smart-wallet-as-a-service-modular-stack-upgrading-waas-with-erc-4337
[Introduction to Account Abstraction]: https://docs.base.org/cookbook/account-abstraction/account-abstraction-on-base-using-privy-and-the-base-paymaster
[Particle dashboard]: https://dashboard.particle.network
[Biconomy Guide (which uses Particle Network)]: https://docs.base.org/cookbook/account-abstraction/account-abstraction-on-base-using-biconomy
[Account Abstraction on Base]: https://docs.base.org/tools/account-abstraction
[Particle Network Documentation]: https://developers.particle.network
[Particle Network 101: Developer Experience]: https://blog.particle.network/particle-network-101-developer-experience-edition

