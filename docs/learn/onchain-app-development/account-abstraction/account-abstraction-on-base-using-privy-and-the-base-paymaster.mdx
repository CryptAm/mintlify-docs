---
title: 'Абстракция аккаунтов на Base с использованием Privy и Base Paymaster'
slug: /account-abstraction-with-privy-and-base-paymaster
description: Руководство, которое учит, как внедрить абстракцию аккаунтов в проект на Base с использованием Privy и Base paymaster.
author: Brian Doyle and Aaron Hayslip
---

# Абстракция аккаунтов на Base с использованием Privy и Base Paymaster

Это руководство покажет вам, как использовать [Privy], [Alchemy's Account Kit], и [Base Paymaster], чтобы позволить вашим пользователям использовать ончейн-приложения без необходимости создавать кошелек самостоятельно или даже платить комиссию за газ!

## Цели

К концу этого руководства вы должны уметь:

### Введение в абстракцию аккаунтов

- Объяснить, как абстракция аккаунтов может улучшить пользовательский опыт в ончейн-приложениях
- Описать разницу между контрактными аккаунтами и EOA, ограничения контрактных аккаунтов и как EIP-4337 использует UserOperation для смягчения этих ограничений
- Описать, как работает абстракция аккаунтов, и как пользователи взаимодействуют со смарт-контрактными кошельками

### Введение в Privy

- Реализовать быстрый старт Privy для добавления ончейн-аутентификации в приложение NextJS
- Сравнить прогрессивную стратегию аутентификации Privy с традиционной аутентификацией на основе кошельков
- Использовать контекст `PrivyProvider` и хук `usePrivy` от Privy для реализации базовой аутентификации через email, SMS, EOA и/или социальные сети
- Использовать встроенные кошельки (Embedded Wallets) Privy, чтобы позволить пользователям выполнять действия, основанные на кошельках, без необходимости подключаться к внешнему кошельку или покидать ваше приложение

### Реализация Paymaster

- Описать, как третья сторона может использовать _paymaster_ для спонсирования газа
- Модифицировать пример [paymaster example] от Privy для Base, чтобы он работал в другом приложении, используя EOA для того, чтобы позволить пользователю вызвать функцию смарт-контракта без требования оплаты газа со стороны пользователя

## Предварительные требования

### 1. Будьте знакомы с современной фронтенд-разработкой

В этом руководстве мы будем работать с React-фронтендом, построенным на [Next.js]. Хотя вам не нужно быть экспертом, мы предполагаем, что вы знакомы с основами.

### 2. Иметь общее понимание EVM и разработки смарт-контрактов

Это руководство предполагает, что вы достаточно уверенно пишете базовые смарт-контракты. Если вы только начинаете, перейдите к нашим гайдам [Base Learn] и начинайте учиться!

## Введение в абстракцию аккаунтов

[ERC-4337], также известный как _Абстракция аккаунтов_, — это стандарт, который позволяет смарт-контрактам инициировать транзакции, что позволяет внедрять любую логику, которую пользователи хотят реализовать, непосредственно в сам смарт-контрактный кошелек для выполнения в сети Ethereum.

Абстракция аккаунтов имеет потенциал стать революционным изменением для пользовательского опыта в ончейн-приложениях, и многие считают, что она сыграет ключевую роль в привлечении следующего миллиарда пользователей в ончейн.

### Проблема, которую решает абстракция аккаунтов

Ончейн-приложения сложны в использовании для многих людей, так как они требуют длительного процесса адаптации для среднего интернет-пользователя, который еще не в ончейн.

Например, предварительные шаги, которые пользователь должен пройти, прежде чем сможет использовать ончейн-приложение:

- Создать кошелек (Coinbase Wallet, Metamask и т.д.)
- Безопасно сохранить мнемоническую фразу кошелька, не потеряв и не скомпрометировав ее
- Подписать немного пугающее сообщение для подключения к ончейн-приложению
- Попытаться что-либо сделать в приложении и получить всплывающее окно с запросом на подтверждение транзакции
- Попытаться сделать это, узнать, что транзакции стоят газа, и что у него его нет
- Узнать, что газ - это комиссия, которую пользователи должны платить в ETH для использования ончейн-приложений
- Попытаться купить ETH, возможно, купив не ту версию ETH не в той сети
- Повторить попытку транзакции
- Повторять, пока не будет найден правильный путь

Для массового внедрения ончейн-приложений этот запутанный и отталкивающий процесс должен измениться.

Именно здесь на помощь приходит абстракция аккаунтов. Она позволяет улучшить процесс адаптации и использования для ваших пользователей:

- Пользователь переходит в ончейн-приложение и аутентифицируется (используя email, EOA или социальные сети)
- Пользователь использует приложение
- Транзакции происходят "под капотом" через смарт-контрактный кошелек, а разработчик приложения спонсирует комиссии за газ пользователя до тех пор, пока тот не адаптируется.

Подводя итог, абстракция аккаунтов позволяет смарт-контрактным аккаунтам инициировать пользовательские операции, аналогично тому, как EOA инициирует транзакцию. Однако, в отличие от EOA, смарт-контрактные аккаунты программируемы и могут обеспечивать ряд впечатляющих функций, таких как:

- **Спонсируемые транзакции**: Позволяют владельцам приложений покрывать комиссии за газ пользователей с помощью paymaster или позволяют пользователю использовать что-то отличное от ETH (например, USDC) для оплаты газа.
- **Произвольная логика верификации**: Верифицировать транзакции с помощью пользовательской логики.
- **Восстановление аккаунта**: Создавать функции восстановления аккаунта на случай потери приватных ключей.
- **Пакетирование транзакций**: Изменять пользовательский опыт так, чтобы несколько транзакций можно было отправить одновременно.

### Обзор ERC-4337 - Абстракция аккаунтов

Термин "Абстракция аккаунтов" происходит из [ERC-4337]. Сам документ сложен для чтения, но одна из заявленных целей предложения:

> позволить пользователям использовать смарт-контрактные кошельки, содержащие произвольную логику верификации, вместо EOA в качестве основного аккаунта. Полностью устранить любую необходимость для пользователей также иметь EOA (как того требуют текущие SC кошельки и EIP-3074)

Другими словами, предложение стремится позволить пользователям использовать _смарт-контрактные кошельки_ **вместо** EOA для транзакций в ончейн.

<Info>
Privy обеспечивает беспрепятственную адаптацию и создание кошельков для пользователей, абстрагируясь от сложностей управления приватными ключами. Узнайте больше в [Privy documentation](https://docs.privy.io/).
</Info>

На первый взгляд, вы можете спросить себя, решают ли смарт-контрактные аккаунты нашу проблему. В чем разница между смарт-контрактным аккаунтом (или контрактным аккаунтом) и _внешним аккаунтом_ (Externally Owned Account)?

Согласно [ethereum.org], различия следующие:

**Внешний аккаунт (EOA)**

- Создание аккаунта ничего не стоит.
- Может инициировать транзакции.
- Транзакции между внешними аккаунтами могут быть только переводами ETH/токенов.
- Состоит из криптографической пары ключей: публичного и приватного, которые контролируют активность аккаунта.

**Контрактные аккаунты**

- Создание контракта стоит денег, потому что вы используете сетевое хранилище.
- Могут отправлять транзакции только в ответ на полученную транзакцию.
- Транзакции от внешнего аккаунта к контрактному аккаунту могут запускать код, который может выполнять множество различных действий, таких как перевод токенов или даже создание нового контракта.
- Контрактные аккаунты не имеют приватных ключей. Вместо этого они управляются логикой смарт-контрактного кода.

Смарт-контрактные кошельки _могли бы_ решить наши проблемы, **но**, как указано выше, они не могут инициировать транзакции. Поскольку они не могут инициировать транзакции, пользователям все еще нужны EOA, и эти EOA все еще должны платить за газ ETH.

Было два варианта решения этой проблемы:

1. Изменить протокол - хардфорк!

2. Изменить транзакции на более раннем этапе (ERC-4337)

В двух словах, ERC-4337 не меняет то, как работают транзакции Ethereum. Криптографически подписанные инструкции от аккаунтов по-прежнему инициируют транзакции для обновления состояния сети Ethereum.

Что меняет ERC-4337, так это все, что происходит _ранее_ этой подписанной транзакции. Для этого он вводит новый _слой пользовательских намерений_, который действует как прокси для EOA. Этот слой позволяет пользователям инициировать транзакции с помощью высоконастраиваемых смарт-контрактных кошельков, но без использования EOA. Сеть Ethereum по-прежнему получает то, что получала раньше - подписанные транзакции.

Результат - лучший опыт для пользователя без изменения протокола Ethereum.

### Как работает абстракция аккаунтов

При обычных транзакциях Ethereum EOA инициирует и подписывает транзакцию. Эта транзакция отправляется в публичный мемпул Ethereum, проверяется и добавляется в блок, попадая в ончейн.

Обратите внимание, что следующие шаги в основном происходят **до** всего этого.

#### 1. **Создание смарт-контрактного кошелька**

Сначала для пользователя должен быть создан новый смарт-контрактный кошелек. Этим кошельком владеет его создатель, который назначается _подписантом_ (signer). Этот подписант должен проверять все его будущие операции.

Этот кошелек может иметь различные функции, но он должен как минимум уметь проверять `UserOperation` с помощью функции `validateUserOp`. `validateUserOp` будет проверять подпись каждого `UserOperation`, увеличивать nonce и обрабатывать комиссии операции.

#### 2. **Создание Пользовательской Операции**

Со смарт-контрактного аккаунта создаются `UserOperation`. Это еще не транзакции, а скорее представляют намерения пользователя. Эти намерения могут представлять любую ончейн-операцию пользователя.

`UserOperation` включает детали транзакции, такие как отправитель, nonce, лимит газа, максимальная комиссия за газ, данные paymaster (если применимо) и подпись.

#### 3. **Генерация подписи**:

Затем `UserOperation` подписывается с использованием приватного ключа, связанного с инициирующим аккаунтом. Эта подпись служит для аутентификации транзакции и подтверждения того, что она действительно была инициирована владельцем смарт-контрактного аккаунта.

#### 4. **Альтернативный мемпул**:

ERC-4337 вводит _альтернативный мемпул_, где операции хранятся до тех пор, пока их не заберет _Бандлер_. Альтернативный мемпул не сильно отличается от пула транзакций, обычно используемого в Ethereum, но этот мемпул существует на более раннем этапе транзакции и содержит пользовательские операции, тогда как мемпул Ethereum содержит подписанные транзакции.

#### 5. **Бандлер (Bundler) и отправка операции:**:

Ноды в сети Ethereum могут выступать в роли _Бандлера_, задача которого заключается в сборе нескольких подписанных `UserOperation` и объединении их в одну транзакцию, называемую bundle transaction. Эти bundle transactions затем направляются в универсальный смарт-контракт, называемый _Точкой входа_ (EntryPoint).

Отправка подписанного `UserOperation` в контракт EntryPoint может быть выполнена напрямую или через _paymaster_ - контракт, который соглашается покрывать стоимость операций для определенных пользователей.

#### 6. **Валидация операции**:

Бандлер запускает функцию `handleOps` в смарт-контракте EntryPoint, который получает bundle transaction. Затем EntryPoint вызывает `validateUserOp` для каждого аккаунта в этой bundle transaction.

Каждый смарт-контрактный кошелек затем должен реализовать дополнительную функцию и выполнить фактическую операцию, отправленную контрактом EntryPoint.

#### 7. **Выполнение операции**:

После того как операция проверена и комиссии обработаны, операция выполняется в сети Ethereum.

## Введение в Privy

[Privy] упрощает аутентификацию и управление пользователями в ончейн-приложениях, объединяя ончейн- и оффчейн-данные пользователей. В рамках подготовки к углублению в пример приложения с Base Paymaster, этот урок охватит основы Privy.

В этом руководстве вы быстро запустите и рассмотрите пример приложения, где пользователи могут аутентифицироваться с помощью [Privy].

### Обзор Privy

Privy описывает себя как "простой набор инструментов для прогрессивной аутентификации в web3". В этом приложении вы в основном будете использовать Privy для его возможностей аутентификации и работы с пользователями, но некоторые из самых популярных функций Privy включают:

**Варианты аутентификации**: Privy позволяет разработчикам настраивать способ аутентификации пользователей. Это может быть криптокошелек, email-адрес, номер телефона или профили в социальных сетях. Удобно, что Privy обрабатывает сессии и предоставляет все необходимые методы аутентификации.

**Прогрессивная адаптация**: Privy создает объект `user` для каждой сессии. До аутентификации этот объект `user` равен `null`, но по мере взаимодействия пользователя с вашим приложением он будет постепенно связывать больше пользовательской информации с этим объектом. Например, пользователи могут начать с аутентификации по email, а позже добавить адрес своего кошелька или любую другую информацию, которую требует приложение.

**Встроенные кошельки**: Встроенные кошельки - это "самокастодиальные кошельки Ethereum, встроенные в ваше приложение. Это позволяет вашим пользователям выполнять действия, основанные на кошельках, никогда не покидая ваш сайт. Встроенные кошельки — это самый простой способ разблокировать полный опыт вашего продукта для пользователей, у которых нет собственного кошелька или которые не хотят его подключать". Разработчики могут просто настроить Privy на автоматическое создание встроенного кошелька при `login` или они могут быть предварительно созданы на стороне сервера.

<Warning>
Встроенные кошельки по-прежнему являются EOA, и их не следует путать со _смарт-контрактными кошельками_. У пользователя могут быть и те, и другие. Во время разработки это разделение может привести к запутанным ситуациям, когда `msg.sender` - это **не** тот адрес, который вы ожидали.
</Warning>

### Быстрый старт Privy

Как и в случае с большинством фронтенд-библиотек для подключения к ончейну, вы можете использовать [Privy's Quick Start], чтобы быстро начать разработку на их платформе. В этом примере вы будете использовать стартер NextJS.

#### Настройка

Сначала перейдите в репозиторий: [https://github.com/privy-io/create-next-app] и клонируйте его.

```bash
git clone https://github.com/privy-io/create-next-app
```

Затем перейдите в папку `cd create-next-app` и установите зависимости с помощью `yarn`.

#### Установка вашего App ID

Для использования Privy вам понадобятся ваши собственные переменные окружения. В терминале выполните:

```bash
cp .env.example .env.local
```

Это создаст файл `.env.local` в корне вашего проекта. Именно сюда вы добавите ваш Privy App ID:

```text
NEXT_PUBLIC_PRIVY_APP_ID=<your-privy-app-id>
```

<Info>
Примечание - чтобы получить App ID, вам нужно запросить его и получить доступ на [https://console.privy.io/]. Этот процесс может занять некоторое время, но для сообщества Base Privy ускорит его! Разработчики могут отправить email на `base@privy.io` с указанием:

- Названия вашего приложения
- Email-адреса, который вы хотите использовать в качестве администратора
- Краткого описания того, что вы создаете

</Info>

#### Запуск приложения

Наконец, запустите `yarn dev` и перейдите по адресу [http://localhost:3000], чтобы увидеть стартовое приложение.

### Пошаговое руководство по входу в Privy

Прежде чем изучать код, протестируйте приложение. Сначала вы должны увидеть эту страницу входа:

![Privy Login Page](/images/account-abstraction/privy-login-page.png)

После нажатия "Log in" вы увидите следующее модальное окно:

![Privy Login Modal](/images/account-abstraction/privy-login-modal.png)

По умолчанию вы можете войти с помощью кошелька или email.

После входа в систему вы будете перенаправлены на страницу `/dashboard`, где демонстрационное приложение позволит вам подключить ряд других аккаунтов к вашему объекту `user`:

![Privy Dashboard Page](/images/account-abstraction/privy-dashboard-page.png)

Если вы перейдете на [console.privy.io](https://console.privy.io/), вы увидите, что Privy хранит всех ваших пользователей и их данные здесь.

![Privy Console](/images/account-abstraction/privy-console.png)

### PrivyProvider

Углубляясь в код, сначала взгляните на `PrivyProvider` внутри `_app.jsx`:

```tsx
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
  onSuccess={() => router.push('/dashboard')}
>
  <Component {...pageProps} />
</PrivyProvider>
```

`PrivyProvider` использует React Context и оборачивает любые компоненты, которые будут использовать хук `usePrivy`.

Кроме того, здесь вы можете передать необязательное свойство `config` для включения дополнительных методов аутентификации.

Добавьте свойство `config` в `<PrivyProvider />` в `_app.jsx` с параметрами входа `'github'` и `'sms'`:

```tsx
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
  onSuccess={() => router.push('/dashboard')}
  config={{
    loginMethods: ['github', 'sms'],
  }}
>
  <Component {...pageProps} />
</PrivyProvider>
```

Обновите страницу, чтобы увидеть, что теперь аутентификация возможна только через Github или SMS:

![Privy Login Methods](/images/account-abstraction/privy-login-methods.png)

Полный список `loginMethods` вы можете найти в документации по [`PrivyClientConfig`].

### Хук `usePrivy`

Основной метод, который вы будете использовать для задействования функций аутентификации Privy, - это `usePrivy`. Откройте `pages/dashboard.tsx`, чтобы увидеть методы, декомпозированные из `usePrivy` в стартовом проекте, и то, как они используются.

Полный список полей и методов, возвращаемых из `usePrivy`, [documented here].

### Хук `useWallets`

Для доступа к данным кошелька текущего аутентифицированного пользователя используйте хук `useWallets`:

```tsx
import { ConnectedWallet, useWallets } from '@privy-io/react-auth';

const { wallets } = useWallets();

// wallets = [
//   {
//     "address": "0x<address>",
//     "type": "wallet",
//     "verifiedAt": "2023-11-28T19:01:41.000Z",
//     "chainType": "ethereum",
//     "chainId": "eip155:84531",
//     "walletClient": "unknown",
//     "walletClientType": "coinbase_wallet",
//     "connectorType": "coinbase_wallet"
//   },
//   {
//     "address": "0x<address>",
//     "type": "wallet",
//     "verifiedAt": "2023-11-28T20:09:23.000Z",
//     "chainType": "ethereum",
//     "chainId": "eip155:1",
//     "walletClient": "unknown",
//     "walletClientType": "metamask",
//     "connectorType": "injected"
//   },
// ],
```

Как видите, пользователь может подключить несколько кошельков к Privy, включая встроенные кошельки.

### Встроенные кошельки

Наконец, настройте ваше стартовое приложение на создание встроенного кошелька для ваших пользователей при входе в систему.

Как указано в документации Privy,

> Встроенные кошельки - это самокастодиальные кошельки Ethereum, встроенные в ваше приложение. Это позволяет вашим пользователям выполнять действия, основанные на кошельках, никогда не покидая ваш сайт. Встроенные кошельки — это самый простой способ разблокировать полный опыт вашего продукта для пользователей, у которых нет собственного кошелька или которые не хотят его подключать.

При настройке вашего приложения на создание встроенных кошельков при входе в систему у вас есть 2 варианта:

- `users-without-wallets`: Это создаст встроенные кошельки для всех пользователей, которые вошли не с помощью внешнего кошелька.
- `all-users`: Это создаст дополнительный встроенный кошелек для всех пользователей, независимо от того, подключили ли они внешний кошелек.

Внутри `_app.tsx`, обновите ваш `PrivyProvider`:

```tsx
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
  onSuccess={() => router.push('/dashboard')}
  config={{
    embeddedWallets: {
      createOnLogin: 'all-users'
    }
  }}
>
```

Выйдите из своего приложения, затем войдите снова и посмотрите, что у вашего пользователя появился дополнительный `linkedAccount`, который является встроенным кошельком Privy:

```tsx
{
  "address": "0xD5063967BA703D485e3Ca40Ecd61882dfa5F49b2",
  "type": "wallet",
  "verifiedAt": "2023-11-28T20:52:22.000Z",
  "chainType": "ethereum",
  "chainId": "eip155:1",
  "walletClient": "privy",
  "walletClientType": "privy",
  "connectorType": "embedded",
  "recoveryMethod": "privy"
},
```

Больше информации о встроенных кошельках Privy, включая информацию об адресах, подписании транзакций, пополнении кошелька и т.д., можно найти здесь:[https://docs.privy.io/guide/frontend/embedded/overview]

## Реализация Paymaster

A _paymaster_ - это тип смарт-контрактного аккаунта, введенный в [ERC-4337], который может оплачивать газ от имени другого аккаунта. В этом пошаговом руководстве вы измените пример, созданный [Privy], перенесете его в другое ончейн-приложение и используете для вызова функции смарт-контракта. По пути вы столкнетесь и разрешите некоторые из запутанных подводных камней, связанных с работой со смарт-контрактными аккаунтами.

<Warning>
Приведенное ниже руководство не учитывает недавние изменения в [Base Paymaster]. Пожалуйста, обратитесь к связанному репозиторию и внесите корректировки. Мы скоро обновим руководство!
</Warning>

### Обзор примера

Начните с изучения [paymaster example]. Адрес в разделе `about` на странице Github ссылается на развернутую версию приложения. Это то же приложение, что вы получаете из [Privy's Quick Start], с добавлением кнопки минта (версии могут быть немного старше).

В приложении доступна только аутентификация через социальные сети, поэтому войдите, используя свою учетную запись Google или email. Вы увидите панель управления с добавлением кнопки `Mint NFT` вверху.

Нажмите кнопку, и вы увидите уведомление (toast), информирующее вас об обновлениях статуса транзакции. Обратите внимание, что это происходит **без** необходимости подтверждать транзакцию или пополнять кошелек!

Нажмите, чтобы увидеть транзакцию, когда она будет завершена, и откроется BaseScan. Если вы пропустили, отминтьте еще один NFT, вы же не платите за газ!

### Обзор транзакции и контракта

Страница транзакции должна выглядеть довольно стандартно. Из нее видно, что NFT был создан [NFT Contract] и передан на адрес смарт-кошелька, указанный на панели управления. Копнув немного глубже, вы увидите некоторые вещи, которые могут отличаться от того, что вы ожидаете.

#### Переданные токены и NFT-контракт

В разделе `ERC-721 Tokens Transferred` нажмите на ссылку `NFT Name (NFT)`, чтобы открыть страницу обзора токена. Вы увидите список переводов, скорее всего, ваш будет наверху. Нажмите на адрес контракта, чтобы открыть [view for the contract itself].

Вы можете удивиться, увидев, что для этого контракта указано очень мало транзакций, несмотря на список переводов, который вы видите на странице токена, или на вкладке `Events`. В настоящее время Etherscan и BaseScan не отображают транзакции, выполненные через paymaster.

<Warning>
Проводники блокчейна (blockchain explorers) — это поставщики услуг, которые предоставляют информацию о состоянии различных блокчейнов. Они **не** являются источником истины.

Возможно, что ончейн-активность отсутствует в этих сервисах.

</Warning>

#### Бандлер (отправитель транзакции)

Вернитесь к сводке транзакции и посмотрите на поле `From:`. В нем будет указан адрес `0x1e6754b227c6ae4b0ca61d82f79d60660737554a`. Что это за адрес? Это не адрес вашего смарт-кошелька или адрес подписанта. Если вы отминтите еще один NFT с другого входа в систему, вы получите того же отправителя.

Этот адрес - [bundler], специальная нода, которая собирает пользовательские операции из альтернативного мемпула в одну транзакцию и отправляет их в единый контракт [EntryPoint].

#### Точка входа (EntryPoint)

Контракт EntryPoint для Base Goerli находится по адресу `0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789`. Странно, но в вашем квитанции о транзакции вы увидите, что транзакция включает перевод ETH **из** Точки входа **в** бандлер. Эта транзакция -- то, как бандлер получает компенсацию за предоставление услуги по сборке пользовательских операций и превращению их в транзакции -- EntryPoint вычисляет газ, использованный пользовательскими операциями, умножает его на процент комиссии и отправляет бандлеру.

### Обзор кода примера

Вернитесь к [paymaster example] и ознакомьтесь с файлом readme. Раздел _Copying into your code_ перечисляет три файла, которые вам нужно скопировать для реализации paymaster в вашем собственном приложении. Все три подробно задокументированы в комментариях. Вам также стоит посмотреть, как демонстрационное приложение использует их для вызова функции.

#### `SmartAccountContext.tsx`

Первый файл, [`hooks/SmartAccountContext.tsx`] использует провайдер контекста React для создания ` SmartAccountProvider`` и передачи его в ваше приложение. Вы можете увидеть его использование в  `\_app.tsx`, с обычным `PrivyProvider` вокруг него. Подробно изучите файл.

Начиная со строки 63, экспортированный `SmartAccountProvider` выполняет следующее:

1. Получает кошельки пользователя и находит его кошелек Privy. Этот кошелек предоставляется и, при необходимости, создается `PrivyProvider`.
2. Устанавливает переменные состояния для управления и обмена статусом подключения и самим смарт-аккаунтом.
3. Инициализирует RPC-клиент для [Base Paymaster] (на Goerli). URL жестко задан в `lib/constants.ts`.
4. Инициализирует ERC-4337 RPC-клиент для сети Alchemy. Именно из этой сети берется адрес бандлера.
5. Создает смарт-кошелек. В данном случае `signer` - это ваш EOA встроенный кошелек, созданный Privy и полученный на первом шаге.
6. Адрес EOA отображается в примере приложения как `YOUR SIGNER ADDRESS`.
7. Инициализирует провайдер Alchemy для подписанта смарт-аккаунта, используя [Account Kit] от Alchemy.
8. Это создает смарт-аккаунт и его адрес, который отображается в примере приложения как `YOUR SMART WALLET ADDRESS`.

Наконец, функция `sendSponsoredUserOperation` принимает традиционную транзакцию, превращает ее в пользовательскую операцию, добавляет данные для paymaster, чтобы оплатить газ, подписывает ее и отправляет. Фух!

Если вы хотите глубже погрузиться во внутреннюю работу этого процесса, ознакомьтесь с вспомогательными функциями в [`user-operations.ts`].

#### Как вызвать функцию смарт-контракта с помощью Paymaster

Откройте [`pages/dashboard.tsx`] и посмотрите на функцию `onMint` в строке 32. Эта функция используется как обработчик `oncClick` для кнопки `Mint` в верхней части панели управления.

Если вы привыкли работать с wagmi, процесс отправки и ожидания подтверждения транзакции может показаться немного ручным. Большая часть этого будет знакомой, если вы использовали viem напрямую или работали с _Ethers_.

Когда пользователь нажимает, приложение сначала создает `RpcTransactionRequest` от viem для функции `mint` в смарт-контракте. `smartContractAddress` предоставляется `SmartAccountProvider`, а `ABI` и адрес контракта `NFT_ADDRESS` загружаются из `lib/constants.ts`:

```tsx
{
  from: smartAccountAddress,
  to: NFT_ADDRESS,
  data: encodeFunctionData({
    abi: ABI,
    functionName: "mint",
    args: [smartAccountAddress],
  }),
}
```

Затем приложение обновляет компонент уведомления (toast), чтобы информировать пользователей, пока оно `await`s сначала `userOpHash`, затем `transactionHash`, что указывает на успешное завершение транзакции. Затем оно обновляет ссылку в уведомлении, чтобы отправить пользователя на эту транзакцию в BaseScan Goerli.

### Реализация Paymaster в вашем собственном приложении

Создайте новый проект, используя шаблон от Privy [`create-next-app`], и выполните инструкции по настройке в файле readme.

Добавьте переменную окружения для `NEXT_PUBLIC_ALCHEMY_API_KEY` и вставьте в нее API-ключ для приложения Base Goerli. Если вам нужен ключ, перейдите на страницу [add an app] и создайте новое.

#### Копирование и обновление исходных файлов

Скопируйте папки `hooks` и `lib` в ваш новый проект. Вам нужно будет установить несколько дополнительных зависимостей. Используйте `npm` или `yarn`, чтобы добавить:

- viem
- react-dom
- @alchemy/aa-accounts
- @alchemy/aa-alchemy
- @alchemy/aa-core

Откройте `SmartAccountContext.tsx` в вашем проекте. Вы увидите ошибку для `getDefaultLightAccountFactory`. Имя этой функции было обновлено до `getDefaultLightAccountFactoryAddress`. Измените его в импорте и там, где оно используется в файле при вызове `LightSmartContractAccount`.

#### Обновление для использования кошелька пользователя

В настоящее время приложение настроено на поиск и использование встроенного кошелька Privy пользователя в качестве подписанта. Чтобы изменить это, измените создание `SmartAccountProvider`. Вместо того, чтобы находить кошелек Privy пользователя:

```tsx
// Старый код для изменения

// Получить список всех кошельков (EOA), которые пользователь подключил к вашему сайту
const { wallets } = useWallets();
// Найти встроенный кошелек, найдя запись в списке с `walletClientType`, равным 'privy'
const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');
```

Просто возьмите первый кошелек из списка (для продакшн-приложения вам захочется сделать что-то более элегантное):

```tsx
// Обновленный код

// Получить список всех кошельков (EOA), которые пользователь подключил к вашему сайту
const { wallets } = useWallets();

// Взять первый кошелек из списка
// TODO: Реализовать возможность позволить пользователю выбрать другой кошелек
const wallet = wallets[0];
```

Затем обновите вызов внизу `useEffect` к `createSmartWallet`, если есть `embeddedWallet`, чтобы вместо этого создавать его, если есть `wallet`, используя этот `wallet`. Вам также нужно будет обновить зависимость в массиве зависимостей.

```tsx
useEffect(() => {
  // Другой код

  if (wallet) createSmartWallet(wallet);
}, [wallet?.address]);
```

#### Настройка PrivyProvider и добавление SmartAccountProvider

По умолчанию `PrivyProvider` позволяет входить с помощью кошелька или email-адреса. Чтобы ограничить только кошельком, обновите config. Вы также можете установить цепь по умолчанию здесь. Для этого вам нужно будет импортировать `baseGoerli`.

Вам также нужно импортировать и обернуть приложение с помощью `SmartAccountProvider`, импортированного из `hooks/SmartAccountContext.tsx`.

<Warning>
Пакет `@alchemy/aa-core` также экспортирует `SmartAccountProvider`, и этот экспорт имеет приоритет, когда VSCode пытается помочь вам, автоматически добавляя импорт. Вы поймете, что взяли не тот, если `SmartAccountProvider` выдаст ошибку:

```text
'SmartAccountProvider' cannot be used as a JSX component.
Its instance type 'SmartAccountProvider<Transport>' is not a valid JSX element.
```

</Warning>

```tsx
<PrivyProvider
  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}
  onSuccess={() => router.push('/dashboard')}
  config={{
    loginMethods: ['wallet'],
    defaultChain: baseGoerli,
  }}
>
  <SmartAccountProvider>
    <Component {...pageProps} />
  </SmartAccountProvider>
</PrivyProvider>
```

#### Проверка прогресса

Возьмите фрагмент из оригинальной демо-версии, который отображает адреса пользователя, и добавьте его в `dashboard.tsx` в новом проекте:

```tsx
<p className="mt-6 font-bold uppercase text-sm text-zinc-600">
  Your Smart Wallet Address
</p>
<a
  className="mt-2 text-sm text-zinc-500 hover:text-violet-600"
  href={`${BASE_GOERLI_SCAN_URL}/address/${smartAccountAddress}#tokentxnsErc721`}
>
  {smartAccountAddress}
</a>
<p className="mt-6 font-bold uppercase text-sm text-zinc-600">
  Your Signer Address
</p>
<a
  className="mt-2 text-sm text-zinc-500 hover:text-violet-600"
  href={`${BASE_GOERLI_SCAN_URL}/address/${eoa?.address}`}
>
  {eoa?.address}
</a>
```

Вставьте его выше `<p>` для окна `User Object`.

Вам нужно будет импортировать `BASE_GOERLI_SCAN_URL` из `constants.ts`. Хук `useSmartAccount` возвращает `smartAccountProvider` и `eoa`. Импортируйте его и добавьте под хуком `usePrivy`. Они вам пока не нужны, но все же декомпозируйте `smartAccountProvider` и `sendSponsoredUserOperation`:

```tsx
const router = useRouter();
const {
  ready,
  authenticated,
  user,
  logout,
  linkEmail,
  linkWallet,
  unlinkEmail,
  linkPhone,
  unlinkPhone,
  unlinkWallet,
  linkGoogle,
  unlinkGoogle,
  linkTwitter,
  unlinkTwitter,
  linkDiscord,
  unlinkDiscord,
} = usePrivy();
const { smartAccountAddress, smartAccountProvider, sendSponsoredUserOperation, eoa } =
  useSmartAccount();
```

Запустите приложение. Теперь вы увидите свой знакомый адрес кошелька как `YOUR SIGNER ADDRESS`!

<Warning>
Иногда приложение путается в состоянии входа после внесения изменений в `config`. Если вы видите кнопку `Log In`, но нажатие на нее ничего не делает, попробуйте вручную перейти по адресу `localhost:3000/dashboard` или очистить кеш.
</Warning>

#### Вызов функции смарт-контракта

Вы изменили основу приложения, чтобы позволить вам использовать Base Goerli Paymaster с вашим обычным кошельком в качестве подписанта. Теперь пришло время вызвать функцию смарт-контракта.

Начните с использования функции `mint` из оригинального примера. В компоненте `DashboardPage` добавьте переменную состояния, содержащую пустой элемент:

```tsx
const [transactionLink, setTransactionLink] = useState(<></>);
```

Затем добавьте вариант оригинальной функции `onMint`, которая устанавливает эту переменную и из которой удален код, связанный с уведомлением (toast).

**Примечание:** обязательно измените адрес вашего кошелька в `args`, чтобы NFT был отправлен на адрес вашего EOA-кошелька!

```tsx
const onMint = async () => {
  // Кнопка минта отключена, если любой из этих параметров не определен
  if (!smartAccountProvider || !smartAccountAddress) return;

  try {
    // Из `RpcTransactionRequest` viem (например, вызов метода `mint` ERC-721),
    // построить и отправить пользовательскую операцию. Комиссии за газ будут спонсироваться Base Paymaster.
    const userOpHash = await sendSponsoredUserOperation({
      from: smartAccountAddress,
      to: NFT_ADDRESS,
      data: encodeFunctionData({
        abi: ABI,
        functionName: 'mint',
        args: [eoa?.address],
      }),
    });

    // Как только у нас есть хэш пользовательской операции, следим за ним, пока транзакция не
    // будет подтверждена.
    const transactionHash = await smartAccountProvider.waitForUserOperationTransaction(userOpHash);

    setTransactionLink(
      <a href={`${BASE_GOERLI_SCAN_URL}/tx/${transactionHash}`}>
        Successfully minted! Click here to see your transaction.
      </a>,
    );
  } catch (error) {
    setTransactionLink(<p>{'Mint failed with error: ' + error}</p>);
  }
};
```

Наконец, выше места, где вы добавили адреса, добавьте кнопку для вызова функции и отображения ссылки на транзакцию:

```tsx
<button
  onClick={onMint}
  className="rounded-md bg-violet-600 px-4 py-2 text-sm text-white hover:bg-violet-700 disabled:bg-violet-400"
  disabled={!smartAccountProvider || !smartAccountAddress}
>
  Mint NFT
</button>;
{
  transactionLink;
}
```

Запустите его и убедитесь, что он работает. Для завершения процесса вам нужна полная квитанция о транзакции, поэтому ожидайте, что это может занять до 10 или 15 секунд.

<Warning>
Для простоты мы удалили код, отключающий кнопку во время минта. Вам нужно будет реализовать собственное решение, чтобы не запутать своих пользователей!
</Warning>

#### Вызов другой функции

[Base Paymaster] на Goerli очень разрешительный. Чтобы вызвать другую функцию, все, что вам нужно сделать, это изменить `RpcTransactionRequest` в `sendSponsoredUserOperation`, чтобы он соответствовал адресу, abi, имени функции и аргументам вашей функции в вашем смарт-контракте.

Например, чтобы вызвать функцию claim в контракте Weighted Voting, который мы использовали в других руководствах, вам просто нужно импортировать в стиле Hardhat [artifact] для контракта и использовать его для вызова функции:

```tsx
const userOpHash = await sendSponsoredUserOperation({
  from: smartAccountAddress,
  to: weightedVoting.address as `0x${string}`,
  data: encodeFunctionData({
    abi: weightedVoting.abi,
    functionName: 'claim',
  }),
});
```

<Warning>
Функция в этом примере может быть вызвана только один раз для каждого адреса. Затем она завершится ошибкой, потому что один кошелек не может получить более одной партии токенов.
</Warning>

## Заключение

В этой статье мы исследовали преобразующий потенциал абстракции аккаунтов для экосистемы Ethereum, подчеркнув, как она позволяет смарт-контрактным аккаунтам инициировать транзакции без изменения основного протокола. Эта инновация в сочетании с использованием Privy для оптимизированной адаптации пользователей и безопасного управления данными знаменует собой значительный шаг вперед в снижении трения при адаптации к ончейн-приложениям. Через практическую реализацию с использованием Privy и [Base Paymaster], we demonstrated мы продемонстрировали, как пользователи могут выполнять ончейн-действия без оплаты комиссий за газ, показывая адаптивность и ориентированность на пользователя этих технологий. Это руководство не только проливает свет на технические аспекты работы абстракции аккаунтов, но также иллюстрирует ее практическое применение для улучшения пользовательского опыта в блокчейне.

[ERC-4337]: https://eips.ethereum.org/EIPS/eip-4337
[ethereum.org]: https://ethereum.org/en/developers/docs/accounts/#key-differences
[Base Learn]: https://base.org/learn
[Next.js]: https://nextjs.org/
[Base Paymaster]: https://github.com/base-org/paymaster
[Privy]: https://www.privy.io/
[Alchemy's Account Kit]: https://www.alchemy.com/account-kit
[Privy]: https://www.privy.io/
[https://docs.privy.io/guide/frontend/embedded/overview]: https://docs.privy.io/guide/frontend/embedded/overview
[Alchemy's Account Kit]: https://www.alchemy.com/account-kit
[Privy's Quick Start]: https://docs.privy.io/guide/quickstart
[https://github.com/privy-io/create-next-app]: https://github.com/privy-io/create-next-app
[`PrivyClientConfig`]: https://docs.privy.io/reference/react-auth/modules#privyclientconfig
[documented here]: https://docs.privy.io/reference/react-auth/interfaces/PrivyInterface
[securely stored]: https://docs.privy.io/guide/security#user-data-management
[paymaster example]: https://github.com/privy-io/base-paymaster-example/blob/main/README.md
[ERC-4337]: https://eips.ethereum.org/EIPS/eip-4337
[NFT Contract]: https://goerli.basescan.org/address/0x6527e5052de5521fe370ae5ec0afcc6cd5a221de
[view for the contract itself]: https://goerli.basescan.org/address/0x6527e5052de5521fe370ae5ec0afcc6cd5a221de
[Base Paymaster]: https://github.com/base-org/paymaster
[EntryPoint]: https://github.com/eth-infinitism/account-abstraction/releases
[bundler]: https://www.alchemy.com/overviews/what-is-a-bundler
[`create-next-app`]: https://github.com/privy-io/create-next-app
[add an app]: https://dashboard.alchemy.com/apps
[Account Kit]: https://www.alchemy.com/blog/introducing-account-kit
[`hooks/SmartAccountContext.tsx`]: https://github.com/privy-io/base-paymaster-example/blob/main/hooks/SmartAccountContext.tsx
[`user-operations.ts`]: https://github.com/privy-io/base-paymaster-example/blob/main/lib/user-operations.ts
[`pages/dashboard.tsx`]: https://github.com/privy-io/base-paymaster-example/blob/main/pages/dashboard.tsx
[artifact]: https://gist.github.com/briandoyle81CB/2c2849b5723058792bece666f0a318cb

