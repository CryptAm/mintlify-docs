---
title: Как работает хранилище
sidebarTitle: Обзор хранилища
description: Введение в работу хранилища в Ethereum
hide_table_of_contents: false
---

В этой статье мы углубимся в работу хранилища Ethereum, исследуем нюансы порядка объявления переменных и предоставим примеры эффективных и неэффективных практик использования хранилища для создания оптимизированных смарт-контрактов.

---

## Цели:

К концу этого урока вы должны уметь:

- Схематично изображать, как данные контракта хранятся в блокчейне (Контракт -> Блокчейн)
- Упорядочивать объявления переменных для эффективного использования хранилища
- Схематично изображать, как переменные в контракте хранятся (Переменная -> Контракт)

---

## Введение

Создание эффективных смарт-контрактов требует глубокого понимания того, как работает хранилище в Ethereum. При проектировании контракта необходимо учитывать требования к хранилищу, включая типы необходимого хранилища, стоимость газа, связанную с операциями хранения, и эффективное управление хранилищем. Плохие практики управления хранилищем могут привести к раздутым контрактам, потребляющим чрезмерное количество газа, делая их выполнение более дорогим. Следуя лучшим практикам управления хранилищем, вы сможете создавать лаконичные, эффективные и экономичные контракты.

---

## Хранилище данных смарт-контракта

### Хранилище типа "ключ-значение"

Смарт-контракты в Ethereum хранят и управляют данными, используя модель хранилища типа "ключ-значение", где каждый элемент данных идентифицируется уникальным ключом и сопровождается соответствующим значением.

На этой диаграмме ключи (адреса пользователей) являются уникальными идентификаторами, используемыми для индексации соответствующих значений (балансов):

<Frame>
![Key Value Store](/images/learn/introduction-to-solidity/key-value-store.png)
</Frame>

Эту модель можно сравнить со словарем или картой, где ключ служит индексом, а значение представляет данные, связанные с этим индексом. Однако хранилище "ключ-значение" имеет отличительные характеристики, которые делают его более оптимальным выбором для смарт-контрактов в Ethereum.

- **Простота:** Оно просто и понятно, что облегчает реализацию и поддержку внутри контракта.

- **Масштабируемость:** Оно обладает высокой масштабируемостью, что делает его хорошо подходящим для управления большими объемами данных, характерными для приложений и смарт-контрактов. Эта масштабируемость помогает поддерживать уровень производительности даже при росте требований к хранилищу.

- **Фиксированные блоки:** Хранение данных в фиксированных 32-байтовых блоках оптимизирует пространство хранилища и обеспечивает более эффективные вычисления расположения данных. Эта особенность особенно полезна в контексте Ethereum, где стоимость хранения является важным фактором.

- **Эффективное хранение и извлечение:** Оно оптимизировано для эффективного хранения и извлечения больших объемов данных, что необходимо для быстрого доступа к сохраненной информации.

- **Безопасность и неизменяемость:** В отличие от других моделей хранения, которые могут допускать прямое манипулирование данными, хранилища "ключ-значение" в среде Ethereum обеспечивают целостность и безопасность данных через модификации на основе транзакций. Эта особенность соответствует децентрализованной и не требующей доверия природе технологии блокчейна.

- **Эффективность по газу:** В Ethereum каждая операция при выполнении смарт-контракта потребляет газ. Модель хранилища "ключ-значение" спроектирована так, чтобы быть эффективной по газу, минимизируя потребление газа для операций хранения и извлечения, тем самым снижая общую стоимость выполнения контракта.

- **Совместимость с децентрализованными средами:** Оно особенно подходит для децентрализованных сред, где важны согласованность, целостность и безопасность данных. Дизайн модели изначально решает проблемы, возникающие в многопоточных или конкурентных средах, где несколько процессов или функций могут одновременно пытаться получить доступ или изменить одни и те же данные.

### Типы хранилища

Существует три основных типа хранилища в смарт-контрактах Ethereum: storage, memory, and stack. Каждый тип имеет свое конкретное применение и характеристики, что делает их подходящими для разных аспектов выполнения смарт-контракта.

#### Хранилище

Хранилище - это наиболее постоянная и дорогая форма хранения данных. Данные, хранящиеся в storage контракта, сохраняются между выполнениями транзакций и доступны для любой функции внутри смарт-контракта. Это хранилище также видно в блокчейне и может быть прочитано внешними источниками, что делает его подходящим для хранения важной и долговременной информации, связанной с состоянием контракта.

Ключевые атрибуты storage:

- **Постоянное:** Данные остаются в storage даже после завершения выполнения контракта, обеспечивая непрерывность состояния между несколькими транзакциями.

- **Дорогое:** Хранение и изменение данных в storage потребляет больше газа по сравнению с другими расположениями данных, делая его дорогим с точки зрения комиссий за транзакции.

- **Видимо в блокчейне:** Данные storage общедоступны и могут быть прочитаны внешними сторонами.

Рассмотрим следующий контракт:

```solidity
contract StorageDemo {
    // Объявляем переменную состояния для хранения данных в storage
    uint256 public storedData;

    // Функция для обновления переменной storedData в storage
    function updateData(uint256 newData) public {
        storedData = newData;
    }
}
```

Контракт включает переменную состояния storedData, которая хранится в `storage` контракта. Модификатор видимости `public` позволяет любому получить доступ к этой переменной. Контракт также включает публичную функцию `updateData`, которую может вызвать любой для изменения значения `storedData` в `storage`.

Любые изменения, внесенные в `storedData` в storage, сохранятся между несколькими транзакциями и будут видны любому, кто читает блокчейн. Обратите внимание, что storage дороже других расположений данных, поэтому важно использовать его осмотрительно, чтобы минимизировать затраты на газ.

#### Память

Память - это временное и более доступное расположение данных. Оно используется для сохранения данных во время выполнения одной транзакции. Как только транзакция завершена, память очищается, и любые данные в ней теряются. Memory подходит для хранения промежуточных переменных и временных данных, которые не нужно сохранять между несколькими транзакциями.

Ключевые атрибуты memory:

- **Временное:** Данные в memory доступны только во время выполнения одной транзакции и теряются после ее завершения.

- **Менее дорогое:** Сохранение и изменение данных в memory потребляет меньше газа по сравнению с storage, делая его более экономичным для временных данных.

- **Не видимо в блокчейне:** Данные memory недоступны внешним сторонам и остаются ограниченными выполнением транзакции.

Рассмотрим следующий контракт:

```solidity
contract MemoryDemo {
    // Объявляем переменную состояния для хранения данных в storage
    uint256 public storedData;

    // Функция для обновления переменной storedData в memory
    function updateData(uint256 newData) public {
        // Объявляем переменную memory для хранения новых данных
        uint256 tempData = newData;

        // Присваиваем значение переменной memory переменной storage
        storedData = tempData;
    }
}
```

В контракте мы объявляем переменную `tempData` в `memory` и присваиваем ей входной параметр `newData` для обновления ее значения. Затем переменная `tempData` присваивается переменной `storedData` для обновления ее значения в storage.

В отличие от storage, данные, хранящиеся в memory, не сохраняются между транзакциями и доступны только во время выполнения функции. Однако доступ и изменение данных в memory менее затратны, чем в storage, что делает его более эффективным вариантом при работе с временными данными. Кроме того, любые данные, хранящиеся в memory, не видны в блокчейне и не могут быть прочитаны внешними сторонами.

#### Стек

Stack - это еще одна форма временного хранения данных, специально используемая для хранения аргументов функций, локальных переменных и промежуточных значений во время выполнения функции. Стек следует структуре "последним пришел - первым ушел" (LIFO), что означает, что последний добавленный элемент будет удален первым. Этот тип хранилища высокоэффективен, но имеет ограниченное пространство, что делает его подходящим для манипуляций с данными в небольших масштабах во время выполнения функции.

Stack - это внутренняя структура данных, используемая EVM (Ethereum Virtual Machine) для вычислений во время выполнения транзакций. Когда транзакция выполняется EVM, байткод смарт-контракта загружается в память, и EVM использует стек для отслеживания промежуточных результатов и выполнения операций.

В Solidity разработчики не взаимодействуют со стеком напрямую, но могут оптимизировать свой код, чтобы наилучшим образом использовать его и минимизировать количество газа, используемого во время выполнения транзакции. Это может включать использование более эффективных алгоритмов или структур данных, а также избегание ненужных операций, которые могут увеличить глубину стека.

Ключевые атрибуты stack:

- **Временное:** Как и memory, данные stack доступны только во время выполнения одной транзакции и теряются после ее завершения.

- **Высокоэффективное:** Операции со стеком потребляют минимальное количество газа, делая его наиболее экономичным вариантом хранения для манипуляций с данными в небольших масштабах.

- **Структура LIFO:** Стек следует порядку "последним пришел - первым ушел", что позволяет эффективно управлять аргументами функций, локальными переменными и промежуточными значениями.

- **Ограниченное пространство:** Стек имеет максимальную глубину 1024, ограничивая количество элементов, которые он может содержать в данный момент.

- **Ограниченная видимость:** Только 16 верхних элементов в стеке доступны, ограничивая количество переменных и других элементов, которые могут быть в области видимости одновременно.

Давайте сравним две версии функции и проанализируем их эффективность по газу с учетом использования стека и потребления газа:

```solidity
contract GasEfficiencyDemo {
    uint256 public result;

    // Менее эффективная
    function sumLessEfficient(uint256 a, uint256 b) public {
        uint256 temp = a + b;
        result = temp;
    }

    // Более эффективная
    function sumMoreEfficient(uint256 a, uint256 b) public {
        result = a + b;
    }
}
```

В функции `sumLessEfficient` сумма двух входных аргументов `a` и `b` сначала присваивается временной переменной `temp`, а затем переменной состояния `result`. Этот дополнительный шаг вводит лишнюю переменную в стек, что требует больше газа для операций со стеком и увеличивает общее потребление газа.

В отличие от этого, функция `sumMoreEfficient` напрямую присваивает сумму входных аргументов `a` и `b` переменной состояния `result`. Это устраняет необходимость во временной переменной и уменьшает использование стека, приводя к меньшему потреблению газа для операций со стеком и более эффективному по газу выполнению.

Хотя разница в потреблении газа между этими двумя функциями может быть незначительной для такого простого примера, принцип минимизации использования стека и оптимизации кода для снижения потребления газа важен для разработки эффективных смарт-контрактов. Избегая ненужных переменных и операций, вы можете улучшить эффективность по газу ваших функций и снизить стоимость их выполнения в EVM.

## Хранение переменных

### Упаковка переменных (Variable Packing)

Как мы узнали, минимизация объема хранилища контракта может существенно снизить затраты на газ. Чтобы сделать хранилище более эффективным, Ethereum использует концепцию, называемую упаковкой переменных.

Упаковка переменных - это процесс размещения нескольких меньших переменных в один слот хранилища для оптимизации использования хранилища. Слот хранилища - это контейнер фиксированного размера, который может содержать до 32 байт данных. Компилятор Solidity Ethereum автоматически упаковывает меньшие переменные вместе, если они могут поместиться в один слот хранилища.

<Frame>
![Variable Packing](/images/learn/introduction-to-solidity/variable-packing.png)
</Frame>

### Порядок объявления переменных

При объявлении переменных в контракте их порядок может влиять на потребление газа контрактом. Вы можете оптимизировать хранилище, объявляя переменные схожего размера вместе, чтобы они могли быть упакованы в один слот хранилища.

Давайте проиллюстрируем, как это работает:

```solidity
contract StoragePackingExample {
    uint8 a; // 1 байт
    uint8 b; // 1 байт
    uint256 c; // 32 байта
}
```

В этом примере компилятор автоматически упакует `a` и `b` в один слот хранилища, так как они обе являются 1-байтовыми переменными и могут поместиться в один 32-байтовый слот хранилища. Однако `c` требует отдельного слота хранилища из-за своего размера (32 байта).

<Frame>
![Variable Order Optimized](/images/learn/introduction-to-solidity/variable-order-optimized.png)
</Frame>

Если бы эти переменные были не в правильном порядке, контракт не использовал бы преимущества упаковки переменных. Переменные занимали бы больше места в хранилище и потенциально потребляли бы больше газа для выполнения контракта.

Рассмотрим неэффективный пример:

```solidity
contract StoragePackingBadExample {
    uint8 a; // 1 байт
    uint256 b; // 32 байта
    uint8 c; // 1 байт
}
```

В этом контракте переменные объявлены не в оптимальном порядке, и компилятор будет хранить эти переменные следующим образом:

<Frame>
![Variable Order Inefficient](/images/learn/introduction-to-solidity/variable-order-inefficient.png)
</Frame>

Чтобы в полной мере использовать упаковку переменных, важно группировать переменные одного размера вместе и избегать смешивания размеров переменных. Делая это, компилятор может хранить их более эффективно, уменьшая общее использование хранилища контрактом. Эта оптимизация не только снизит затраты на газ, связанные с хранилищем, но и улучшит скорость выполнения контракта.

---

## Заключение

Создание эффективных и оптимизированных смарт-контрактов в Ethereum требует глубокого понимания того, как работает хранилище. Смарт-контракты используют модель хранилища "ключ-значение" для управления и хранения данных, которая проста, масштабируема, эффективна по газу и подходит для децентрализованных сред. Существует три типа хранилища в смарт-контрактах Ethereum: storage, memory и stack, каждый со своими характеристиками. Разработчики могут оптимизировать использование хранилища с помощью упаковки переменных и упорядочивания объявлений переменных на основе их размера. Следуя лучшим практикам управления хранилищем, разработчики могут создавать контракты, которые являются лаконичными, эффективными, экономичными и улучшают скорость их выполнения.

---

## Смотрите также

- [Understanding Ethereum Smart Contract Storage](https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/)
- [What is Smart Contract Storage Layout](https://docs.alchemy.com/docs/smart-contract-storage-layout)


[ethereum in depth, part 2]: https://blog.openzeppelin.com/ethereum-in-depth-part-2-6339cf6bddb9/
[ethereum yellow paper]: https://ethereum.github.io/yellowpaper/paper.pdf

