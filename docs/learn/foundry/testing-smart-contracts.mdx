---
title: 'Foundry: Тестирование смарт-контрактов'
slug: /intro-to-foundry-testing
author: Edson Alcala
description: Руководство, которое научит, как тестировать ваши смарт-контракты с помощью Foundry.
---

# Тестирование смарт-контрактов с помощью Foundry

В этом руководстве вы узнаете, как тестировать ваши смарт-контракты с помощью [Foundry] - набора инструментов для разработки смарт-контрактов.

## Цели обучения

После изучения этого руководства вы сможете:

- Понять повышенную важность тестирования в разработке смарт-контрактов
- Писать и выполнять тесты, написанные на Solidity, используя Forge Standard Library с Foundry
- Использовать `cheatcodes`, которые предоставляет Foundry, для тестирования ваших смарт-контрактов

## Обзор

Тестирование - это критически важный аспект разработки смарт-контрактов, обеспечивающий надежность и безопасность вашего кода. Поскольку невозможно исправить смарт-контракт после развертывания, вы должны тщательно и полностью протестировать свой код. Foundry предоставляет надежную структуру тестирования, которая позволяет разработчикам создавать комплексные тестовые наборы для своих проектов с использованием Solidity.

## Мой первый тест с Foundry

Рассмотрим тест по умолчанию, который предоставляет команда `forge init hello_foundry_in_base` в стартовом проекте Foundry.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0);
    }

    function testIncrement() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testSetNumber(uint256 x) public {
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }
}
```

Обратите внимание на следующее:

- Файлы тестов Foundry именуются по шаблону: `<ContractName>.t.sol`
- Файлы тестов смарт-контрактов именуются по шаблону: `<ContractName>Test`
- Все тесты наследуются от `forge-std/Test.sol`.
- Все тесты содержат публичную функцию `setUp`, которая выполняется перед каждым тестом. Это похоже на хук `beforeEach` в мире Mocha/Typescript.
- Тестовые случаи начинаются с ключевого слова `test` например, `testIncrement`.
- Функции тестовых случаев являются публичными.

Для получения дополнительной информации о написании тестов в Foundry вы можете следовать официальному руководству по [написанию тестов][Writing tests]

Чтобы запустить тест в Foundry, выполните:

```bash
$ forge test
```

Вы должны увидеть в терминале:

```bash
Running 2 tests for test/Counter.t.sol:CounterTest
[PASS] testIncrement() (gas: 28334)
[PASS] testSetNumber(uint256) (runs: 256, μ: 27565, ~: 28343)
Test result: ok. 2 passed; 0 failed; finished in 13.57ms
```

## Использование Cheatcodes

Foundry включает набор [cheatcodes], которые представляют собой специальные инструкции, доступные с помощью экземпляра `vm` в ваших тестах. Читкоды позволяют выполнять различные задачи, включая:

- Управление состоянием блокчейна
- Тестирование откатов (reverts)
- Тестирование событий (reverts)
- Изменение номера блока
- Изменение идентификатора
- И многое другое!

Для начала используйте читкод для изменения `msg.sender` в ваших тестах и добавьте несколько журналов консоли, импортировав контракт `forge-std/console.sol`.

Контракт `Counter` должен выглядеть следующим образом:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/console.sol";

contract Counter {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        console.log("The sender is %s", msg.sender);
        number = newNumber;
    }

    function increment() public {
        console.log("The sender is %s", msg.sender);
        number++;
    }
}
```

Если вы запустите тесты, используя `forge test`, вы увидите следующее:

```bash
Running 2 tests for test/Counter.t.sol:CounterTest
[PASS] testIncrement() (gas: 31531)
[PASS] testSetNumber(uint256) (runs: 256, μ: 30684, ~: 31540)
Test result: ok. 2 passed; 0 failed; finished in 19.64ms
```

Кажется, журналы не отображаются. Причина в том, что команда `forge test` включает флаг, который позволяет вам включать больше деталей журналов, созданных во время выполнения тестов.

Вы можете управлять этим, включая различные уровни флага verbose -- `-vv` до `-vvvvv`. Для получения дополнительной информации об уровне детализации вы можете обратиться к разделу документации Foundry.

Запустите `foundry test -vv`. Вы должны увидеть:

```bash
Running 2 tests for test/Counter.t.sol:CounterTest
[PASS] testIncrement() (gas: 31531)
Logs:
  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496
  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496

[PASS] testSetNumber(uint256) (runs: 256, μ: 30607, ~: 31540)
Logs:
  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496

Test result: ok. 2 passed; 0 failed; finished in 17.89ms
```

Теперь измените тестовый файл, используя читкод `prank`, который позволяет изменить `msg.sender` следующей транзакции. Вы также будете использовать читкод `addr`, который позволяет генерировать адрес, используя любой приватный ключ, который может быть простым шестнадцатеричным числом.

Добавьте несколько операторов `console.log`, чтобы лучше понять поток выполнения.

Код должен выглядеть так:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        console.log("Calling on Setup");
        counter.setNumber(0);
    }

    function testIncrement() public {
        console.log("Calling on testIncrement");
        vm.prank(vm.addr(0x01));
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testSetNumber(uint256 x) public {
        console.log("Calling on testSetNumber");
        vm.prank(vm.addr(0x02));
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }
}
```

Затем, если вы запустите команду `forge test -vv`, вы должны увидеть:

```bash
Running 2 tests for test/Counter.t.sol:CounterTest
[PASS] testIncrement() (gas: 35500)
Logs:
  Calling on Setup
  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496
  Calling on testIncrement
  The sender is 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf

[PASS] testSetNumber(uint256) (runs: 256, μ: 34961, ~: 35506)
Logs:
  Calling on Setup
  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496

Test result: ok. 2 passed; 0 failed; finished in 48.75ms
```

Обратите внимание, как вы вызываете cheatcode `vm.prank` перед вызовом функций `counter.increment()` и `counter.setNumber(x)`. Это позволяет вам указать конкретный адрес, который станет `msg.sender` в контракте. Поскольку `vm.prank` принимает адрес, вы просто генерируете адрес с помощью читкода `vm.addr`, передавая простое шестнадцатеричное число, которое является действительным приватным ключом.

## Заключение

Поздравляем! Вы успешно завершили первый шаг в вашем пути тестирования смарт-контрактов с помощью Foundry. Продвигаясь вперед, продолжайте исследовать его богатые функции и возможности. Возможность писать комплексные тесты и использовать читкоды обеспечивает надежность и безопасность ваших смарт-контрактов.

Удачного кодирования и тестирования с Foundry!

[Foundry]: https://book.getfoundry.sh/
[Writing tests]: https://book.getfoundry.sh/forge/writing-tests
[cheatcodes]: https://book.getfoundry.sh/forge/cheatcodes
[Logs and Traces]: https://book.getfoundry.sh/forge/tests?highlight=vvv#logs-and-traces

