---
sidebarTitle: Обзор
title: 'Обзор Solidity'
description: Обзор языка программирования Solidity.
hide_table_of_contents: false
---

import { Danger } from "/snippets/danger.mdx";

В этой статье вы узнаете о происхождении и истории Solidity, где найти документацию, и рассмотрите некоторые особенности, которые делают программирование на Solidity относительно уникальным. Вы также узнаете, как начать разработку!

---

## Цели

К концу этого урока вы сможете:

- Описать, почему такие языки, как Solidity, используются для написания смарт-контрактов
- Дать обзор истории (и темпов изменений) Solidity, а также его сильных и слабых сторон

---

## Введение в Solidity

Solidity - это язык высокого уровня, используемый для разработки смарт-контрактов, совместимых с виртуальной машиной Ethereum (EVM). Он объектно-ориентированный, строго типизированный и позволяет возвращать несколько значений (вариативные возвраты). Solidity был [вдохновлен][inspired] рядом языков, особенно C++. По сравнению с другими языками Solidity меняется очень быстро. Ознакомьтесь с [релизами][releases], чтобы увидеть, насколько быстро!

### Документация

[Solidity Docs] (Документация) подробна и полезна. Это руководство будет регулярно ссылаться на нее, и она должна быть вашим основным источником информации, связанной с любыми компонентами языка. Как и с любой версионированной документацией, всегда дважды проверяйте, что версия, на которую вы ссылаетесь, соответствует версии, с которой вы разрабатываете.

### Происхождение в двух словах

Solidity был разработан командой Solidity проекта Ethereum и впервые представлен в 2014 году на DevCon0. Первоначальной целью было создание простого в использовании языка для разработки смарт-контрактов. Отличный [обзор истории][history overview] можно найти в блоге команды.

### Что он на самом деле делает

Solidity очень похож на языки программирования, к которым вы привыкли, в том смысле, что это язык высокого уровня, относительно удобочитаемый для человека, который затем компилируется в байт-код, читаемый EVM. Например, это:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

contract Hello {
    function HelloWorld() public pure returns (string memory) {
        return "Hello World!";
    }
}
```

компилируется в это:

```text
0x608060405234801561001057600080fd5b50610173806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80637fffb7bd14610030575b600080fd5b61003861004e565b604051610045919061011b565b60405180910390f35b60606040518060400160405280600c81526020017f48656c6c6f20576f726c64210000000000000000000000000000000000000000815250905090565b600081519050919050565b600082825260208201905092915050565b60005b838110156100c55780820151818401526020810190506100aa565b60008484015250505050565b6000601f19601f8301169050919050565b60006100ed8261008b565b6100f78185610096565b93506101078185602086016100a7565b610110816100d1565b840191505092915050565b6000602082019050818103600083015261013581846100e2565b90509291505056fea2646970667358221220575a1ec2ade1712a7a3a4e91cc5d83212207e4a5c70f5b2bc50079ee65ad29b364736f6c63430008110033
```

Как видите, первый пример немного легче читать!

---

## Программирование для Ethereum на Solidity

На первый взгляд написание кода для EVM с использованием Solidity не сильно отличается от других языков программирования. Вы пишете код, организованный в функции, и эти функции выполняются при вызове, часто принимая аргументы и возвращая значения. Однако есть ряд необычных особенностей, которые заставят вас думать немного иначе. Кроме того, EVM - это гораздо меньший, медленный и менее мощный компьютер, чем настольный или даже мобильный.

### Комиссии за газ (Gas Fees)

Каждая [операция][operation] которую выполняет ваш код, стоит газа, за который платят ваши пользователи. Вы, вероятно, уже хорошо разбираетесь в _[time complexity]_ и знаете, как сократить операцию до O(log(n)), когда у вас нет выбора, кроме как запустить что-то с O(2^n), и что иногда вложенные циклы for работают "брррр". Эти ограничения и практики все еще применяются, но в Solidity каждая неэффективность напрямую стоит вашим пользователям денег, что может сделать ваше приложение более дорогим и менее привлекательным, чем необходимо.

Когда вы изучали _сложность по времени_, вы, вероятно, слышали термин сложность по памяти один раз, а потом о нем больше не упоминали. Это потому, что обычно вычисления дороги, а хранение практически бесплатно. В EVM все наоборот. Минимум **20 000** газа стоит инициализация переменной и минимум **5 000** — ее изменение. Между тем, стоимость сложения двух чисел составляет **3** газа. Это означает, что часто гораздо дешевле многократно вычислять значение, которое рассчитывается из других значений, чем вычислить его один раз и сохранить.

Вы также должны быть осторожны, чтобы писать код с предсказуемыми путями выполнения. Каждая транзакция отправляется с лимитом газа, и различные фреймворки, такие как _ethers.js_, стараются его оценить. Если эта оценка неверна, транзакция завершится неудачей, но **она все равно будет стоить газа, использованного до момента сбоя**!

### Ограничение размера контракта

[EIP-170] ввел ограничение размера скомпилированного байт-кода для смарт-контрактов Ethereum в **24 КиБ** (24 576 Б). Прочитайте это предложение еще раз, так как вы, вероятно, не привыкли думать в таких маленьких числах!

Хотя нет точного соотношения строк кода к размеру скомпилированного байт-кода, вы ограничены развертыванием контрактов размером примерно 300-500 строк на Solidity.

К счастью, есть несколько способов обойти это ограничение. Контракты могут предоставлять свои функции для вызова другими контрактами, хотя это влечет дополнительные затраты. Используя это, вы можете написать набор контрактов, предназначенных для совместной работы, или даже использовать контракты, уже развернутые другими. Вы также можете использовать более продвинутые решения, такие как [EIP-2535].

### Ограничение стека

Программы, написанные для компьютеров или мобильных устройств, часто работают с сотнями переменных одновременно. EVM работает со стеком, который может содержать 1024 значения, но он может обращаться только к верхним 16.

Есть много последствий этого ограничения, но самое распространенное, с которым вы столкнетесь, — это ошибка «Стек слишком глубокий» (Stack too Deep), потому что вы пытаетесь работать со слишком большим количеством переменных одновременно.

В Solidity/EVM ваши функции ограничены в общей сложности 16 переменными, которые являются входными, выходными или инициализированными функцией.

### Постоянство

После развертывания смарт-контракты постоянны и не могут быть изменены никем, **даже их создателем(-ями)**! Их буквально невозможно отредактировать. Если создатели контракта обнаружат уязвимость, они ничего не смогут с этим поделать, кроме как вывести средства — если контракт позволяет это!

В результате стандартной практикой является проведение аудита смарт-контракта экспертом перед развертыванием.

### Темп изменений

Файлы Solidity всегда начинаются с лицензии и версии:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;
```

Одна из причин этого в том, что темп разработки Solidity **очень** высок, и изменения не всегда обратно совместимы. В результате компилятор должен знать, какую версию использовать при преобразовании кода Solidity в байт-код.

Ознакомьтесь с [changelog], чтобы увидеть некоторые недавние дополнения и исправления.

---

## Среды разработки

Мы рассмотрим два инструмента, которые можно использовать для разработки на Solidity.

### Remix

Мы начнем с [Remix], онлайн-IDE, похожей на Codepen, Replit или CodeSandbox. Remix - отличное место для начала, потому что он работает из коробки, имеет ряд демонстрационных контрактов и отличные инструменты отладки. Дополнительную информацию можно найти на сайте [Remix Project].

<Frame>
![Remix Home](/images/learn/introduction-to-solidity/remix-home.png)
</Frame>

<Danger>
**БУДЬТЕ ОЧЕНЬ ВНИМАТЕЛЬНЫ** при использовании Remix, так как им также могут пользоваться мошенники. Сам Remix предупредит вас об этом, так что будьте бдительны! Один из распространенных мошеннических приемов - убедить вас вставить и развернуть код, который якобы является каким-то автоматическим генератором денег, например, инструментом для стейкинга или ботом.

Если вы вставите и запустите код, который не понимаете, вы можете потерять все активы с вашего текущего подключенного кошелька. Вы также должны быть осторожны, всегда переходя напрямую на `remix.ethereum.org`. Более опытные разработчики предпочитают использовать статические версии Remix, развернутые на [IPFS], но будьте осторожны. Также существуют скомпрометированные развертывания, используемые в качестве части мошенничества!
</Danger>


### Hardhat

[Hardhat] - это среда разработки, которая позволяет разрабатывать и тестировать Solidity на вашем локальном компьютере. Он включает инструменты отладки и модульного тестирования и имеет экосистему плагинов, разработанных сторонними разработчиками, которые упрощают разработку и развертывание. Среди прочего, эти плагины могут помочь вам развернуть контракты, увидеть размер скомпилированного байт-кода и даже увидеть покрытие модульных тестов.

Мы представим Hardhat и локальную разработку после основ.

## Настройка Remix

Следующий урок исследует один из демонстрационных контрактов в [Remix]. Откройте его и ознакомьтесь с краткой информацией для начала, если вы впервые на сайте. Затем откройте или создайте новую рабочую область, используя шаблон `Default`.

**Удалите** все, кроме папки contracts и контракта `1_Storage.sol` внутри этой папки. Вы также можете оставить `.prettierrc.json`, если хотите.

<Frame>
![Delete](/images/learn/introduction-to-solidity/delete.png)
</Frame>

---

## Заключение

На первый взгляд Solidity очень похож на другие языки программирования; большинству разработчиков не составит труда писать знакомые операции. Однако есть некоторые критически важные свойства, о которых нужно помнить. Операции намного дороже, чем в других средах, особенно хранение. Вы можете использовать большинство привычных вам практик, но вы ограничены очень маленькими размерами контрактов и размером стека. Наконец, помните, что вы всегда должны использовать отдельный кошелек для разработки. Если вы допустите ошибку, вы можете потерять все, что в нем есть!

---

## Смотрите также

[Solidity Docs](https://docs.soliditylang.org/en/v0.8.17/)

[inspired]: https://docs.soliditylang.org/en/v0.8.17/language-influences.html
[releases]: https://github.com/ethereum/solidity/releases
[Solidity Docs]: https://docs.soliditylang.org/en/v0.8.17/
[history overview]: https://blog.soliditylang.org/2020/07/08/solidity-turns-5/
[operation]: https://ethereum.org/en/developers/docs/evm/opcodes/
[time complexity]: https://en.wikipedia.org/wiki/Time_complexity
[EIP-170]: https://eips.ethereum.org/EIPS/eip-170
[EIP-2535]: https://eips.ethereum.org/EIPS/eip-2535
[changelog]: https://github.com/ethereum/solidity/blob/develop/Changelog.md
[Remix]: https://remix.ethereum.org/
[IPFS]: https://ipfs.tech/
[Remix Project]: https://remix-project.org/
[Hardhat]: https://hardhat.org/
