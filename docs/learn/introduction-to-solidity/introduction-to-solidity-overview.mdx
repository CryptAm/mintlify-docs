---
title: 'Обзор'
description: Обзор этого модуля.
hide_table_of_contents: false
---

Курс, который вы собираетесь начать, предназначен для быстрого и тщательного обучения концепциям и языку веб3 разработчиков веб2. Он специально подчеркивает сходства и различия между веб3 и веб2 и содержит справочную информацию, практические занятия с кодом и самостоятельные упражнения.

Эта программа **не** подходит для людей, которые вообще новички в программировании. Хотя объяснения подробные, они часто предполагают, что вы знакомы с базовыми концепциями. Мы не будем учить вас тому, что такое массивы и как они используются, но мы покажем, как они работают в этой среде.

## Предварительные требования

Перед этими уроками вы должны:

- Иметь несколько лет опыта работы программистом на объектно-ориентированном языке
- Быть знакомым с использованием и свойствами блокчейна Ethereum и EVM
- В идеале быть знакомым по крайней мере с одним [curly-bracket] языком программирования

---

## Цели

К концу этого модуля вы сможете:

- **Введение в Solidity**
  - Описать, почему такие языки, как Solidity, используются для написания смарт-контрактов
  - Дать обзор истории (и темпов изменений) Solidity, а также его сильных и слабых сторон
  - Развернуть и протестировать демонстрационный контракт Storage.sol в Remix
- **Контракты и базовые функции**
  - Создать простой контракт «Hello World»
  - Классифицировать основные типы данных
  - Перечислить основные различия между типами данных в Solidity по сравнению с другими языками
  - Сравнить и сопоставить знаковые и беззнаковые целые числа
  - Написать чистую (pure) функцию, которая принимает аргумент и возвращает значение
- **Развертывание смарт-контрактов в тестовой сети**
  - Описать использование и свойства тестовой сети Ethereum
  - Сравнить и сопоставить Ropsten, Rinkeby, Goerli и Sepolia
  - Развернуть контракт в тестовой сети Sepolia и взаимодействовать с ним в Etherscan
- **Управляющие структуры**
  - Управлять потоком кода с помощью if, else, while и for
  - Перечислить уникальные ограничения для управления потоком в Solidity
- **Хранилище в Solidity**
  - Схематично изобразить, как данные контракта хранятся в блокчейне (Контракт -> Блокчейн)
  - Упорядочивать объявления переменных для эффективного использования хранилища
  - Схематично изобразить, как переменные в контракте хранятся (Переменная -> Контракт)
- **Массивы в Solidity**
  - Создать, затем сохранить и извлечь значения в массивах хранилища (storage) и памяти (memory)
  - Описать разницу между массивами в хранилище и в памяти
  - Схематично изобразить, как хранятся массивы
  - Написать функцию, которая может возвращать отфильтрованное подмножество массива
- **Тип Mapping**
  - Создать тип данных Map (словарь)
  - Схематично изобразить хранение типа данных Mapping
  - Помнить, что присваивание типа данных Map не такое гибкое, как для других типов данных/в других языках
  - Ограничивать вызовы функций с помощью глобальной переменной msg.sender
  - Помнить, что в EVM нет защиты от коллизий, и почему это (вероятно) нормально
- **Продвинутые функции**
  - Описать, чем чистые (pure) и просматривающие (view) функции отличаются от функций, изменяющих хранилище
  - Классифицировать функции как public, private, internal или external в зависимости от их использования
  - Использовать модификаторы для эффективного добавления функциональности к нескольким функциям
  - Использовать require, чтобы написать функцию, которую можно использовать только тогда, когда переменная установлена в 'True'
- **Структуры**
  - Создать структуру (пользовательский тип), содержащую несколько различных типов данных
  - Объявлять члены структуры для максимальной эффективности хранения
  - Описать ограничения, связанные с присваиванием структур в зависимости от типов, которые они содержат
- **Наследование**
  - Написать смарт-контракт, который наследует от другого контракта
- **Импорты**
  - Импортировать и использовать код из другого файла
- **Ошибки**
  - Отлаживать распространенные ошибки Solidity, включая откат выполнения (execution reverted), недостаток газа (out of gas), переполнение стека (stack overflow), переполнение/потерю значения (value overflow/underflow), выход индекса за пределы диапазона (index out of range) и т.д.
- **New Keyword**
  - Написать контракт, который создает новый контракт с помощью ключевого слова new

---

[curly-bracket]: https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages
