---
title: Модификаторы функций
sidebarTitle: Руководство по модификаторам
description: Создавайте пользовательские модификаторы функций для эффективного изменения функциональности.
hide_table_of_contents: false
---

Модификаторы функций позволяют вам эффективно изменять поведение функций. В некотором смысле это похоже на наследование, но есть ограничения, особенно в области видимости переменных.

---

## Цели

К концу этого урока вы должны уметь:

- Использовать модификаторы для эффективного добавления функциональности к нескольким функциям

---

## Добавление простого модификатора OnlyOwner

По умолчанию `public` функции могут быть вызваны **кем угодно**, без ограничений. Часто это желательно. Вы хотите, чтобы любой пользователь мог видеть, какие NFT выставлены на продажу на вашей платформе, регистрироваться для использования сервиса или читать различные элементы, хранящиеся в состоянии.

Однако будет множество функций, которые вы не хотите, чтобы любой пользователь мог выполнять, таких как установка комиссии за использование приложения или вывод всех средств из контракта! Распространенный паттерн для защиты этих функций - использование `modifierов`, чтобы гарантировать, что только владелец может вызывать эти функции.

<Warning>
Для продакшен приложения вам понадобится более надежная реализация `onlyOwner`, например [one provided by OpenZeppelin].
</Warning>


### Добавление владельца

Адрес развертывающего контракт не включен как доступное свойство. Чтобы сделать его доступным, добавьте его как переменную состояния и присвойте `msg.sender` в `constructor`.

<Accordion title="Показать код">
```solidity
contract Modifiers {
    address owner;

    constructor () {
        owner = msg.sender;
    }
}
```
</Accordion>


### Создание модификатора `onlyOwner`

[Modifiers] очень похожи на функции и объявляются с помощью ключевого слова `modifier`. Модификатор может выполнять любой код Solidity, включая функции, и ему разрешено изменять состояние. Модификаторы должны иметь специальный символ `_`, который служит заполнителем для места, где будет выполняться код, содержащийся в модифицируемой функции.

Создайте простой модификатор `onlyOwner`, который возвращает `error` `NotOwner` с адресом отправителя, если отправитель не является владельцем.

<Accordion title="Показать код">
```solidity
error NotOwner(address _msgSender);
```

```solidity
modifier onlyOwner {
    if (msg.sender != owner) {
        revert NotOwner(msg.sender);
    }
    _;
}
```
</Accordion>

Протестируйте ваш `modifier`, добавив функцию, которая его использует:

<Accordion title="Показать код">
```solidity
function iOwnThis() public view onlyOwner returns (string memory) {
    return "You own this!";
}
```
</Accordion>

Для тестирования разверните ваш контракт и вызовите функцию `iOwnThis`. Вы должны увидеть сообщение "Вы владеете этим!".

Затем переключите Account и попробуйте снова вызвать функцию. Вы должны увидеть ошибку в консоли:

```text
call to Modifiers.iOwnThis errored: VM error: revert.

revert
	The transaction has been reverted to the initial state.
Error provided by the contract:
NotOwner
Parameters:
{
 "_msgSender": {
  "value": "0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db"
 }
}
Debug the transaction to get more information.
```

<Warning>
Всегда проверяйте вывод вызова функции в консоли. Результат, который появляется под кнопкой для функции, удобен, но он **не** очищается и не изменяется, если последующий вызов откатывается.
</Warning>


---

## Модификаторы и переменные

Модификаторы могут иметь параметры, которые, по сути, работают так же, как и в функциях. Эти параметры могут быть независимыми значениями, или они могут совпадать с аргументами, предоставленными при вызове функции.

### Модификаторы с параметрами

Параметры модификаторов могут быть аргументами, предоставленными функциям, которые они модифицируют. Вы можете выполнять вычисления и вызывать ошибки на основе этих значений.

```solidity
error NotEven(uint number);

modifier onlyEven(uint _number) {
    if(_number % 2 != 0) {
        revert NotEven(_number);
    }
    _;
}

function halver(uint _number) public pure onlyEven(_number) returns (uint) {
    return _number / 2;
}
```

### Независимая область видимости

Хотя `modifier` используются для модификации функций и могут иметь общие входные данные, у них отдельные области видимости. Следующий пример не будет работать:

```solidity
// Плохой пример кода, не работает
modifier doubler(uint _number) {
    _number *= 2;
    _;
}

function modifierDoubler(uint _number) public pure doubler(_number) returns (uint) {
    return _number; // Возвращает исходное число, НЕ число * 2
}
```

---

## Заключение

`modifier` функций - это эффективный и переиспользуемый способ добавления проверок, вызова ошибок и управления выполнением функций. В этом уроке вы увидели примеры того, как их можно использовать для прерывания выполнения при определенных условиях. Вы также узнали, что у них отдельные области видимости, и их нельзя использовать для изменения переменных внутри функции, которую они модифицируют.

[one provided by OpenZeppelin]: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
