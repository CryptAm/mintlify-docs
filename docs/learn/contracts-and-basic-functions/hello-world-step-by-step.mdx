---
sidebarTitle: Руководство Hello World
title: Hello World
description: Напишите свой первый контракт на Solidity.
hide_table_of_contents: false
---

По традиции мы начнем программирование с варианта "Hello World", написанного в виде смарт-контракта. Здесь нет консоли для вывода\*, поэтому вместо этого мы напишем контракт, который приветствует отправителя, используя предоставленное им имя.

\*Вы сможете использовать `console.log` с _Hardhat_, но с некоторыми ограничениями.

---

## Цели обучения

После изучения этого урока вы сможете:

- Создать простой контракт "Hello World" 
- Перечислить основные различия между типами данных в Solidity по сравнению с другими языками
- Выбрать соответствующую видимость для функции

---

## Hello World

Написание "Hello World" в смарт-контракте требует немного больше размышлений, чем в других языках. Ваш код развернут удаленно, но он не работает на сервере, где вы можете получить доступ к логам, или на вашем локальном компьютере, где у вас есть доступ к консоли. Один из способов сделать это - написать функцию, которая возвращает "Hello World".

### Создание контракта

Чтобы создать контракт:

1. Создайте новую рабочую область в Remix.
2. Назовите ее `Hello World` и удалите папку `.deps`.
3. Оставьте `.prettierrc.json` и нажмите на значок настроек в левом нижнем углу.
4. Снимите галочку с верхней опции _Generate contract metadata..._
5. Откройте плагин _Solidity Compiler_ и включите _Auto compile_.
6. Создайте новую папку с именем `contracts`, а внутри этой папки создайте файл с именем `hello-world.sol`.

Файлы Solidity обычно начинаются с комментария, содержащего [_SPDX-License-Identifier_]. Это не требование, но есть несколько преимуществ в этом. Во-первых, все, что вы развертываете в блокчейне, является публичным. Это не означает, что вы отдаете все, что развертываете, бесплатно, и не означает, что вы имеете право использовать код из любого развернутого контракта. Лицензия определяет разрешенное использование и, как правило, защищена международными законами об авторском праве, как и любой другой код.

Если вы не хотите указывать лицензию, вы можете указать `UNLICENSED`. Распространенные лицензии с открытым исходным кодом, такие как `MIT` и `GPL-3.0`, также популярны. Добавьте свой идентификатор лицензии:

```Solidity
// SPDX-License-Identifier: MIT
```

Под идентификатором лицензии вам нужно указать, какую [version] Solidity компилятор должен использовать для компиляции вашего кода. Если к моменту прочтения этого руководства версия продвинулась дальше, вам следует попробовать использовать самую последнюю версию. Это может привести к неожиданным ошибкам, но это отличная практика для работы в реальных условиях!

```Solidity
pragma solidity 0.8.17;
```

Наконец, добавьте `contract` с именем `HelloWorld`. В итоге у вас должно получиться:

```Solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

contract HelloWorld {

}
```

### Функция SayHello

Добавьте функцию в ваш контракт с именем `SayHello`:

```Solidity
function SayHello() {

}
```

Вы получите синтаксическую ошибку компилятора: _No visibility specified. Did you intend to add "public"?_.

Является ли `public` наиболее подходящим [visibility specifier]?

Он сработает, но вы не будете вызывать эту функцию изнутри контракта, поэтому `external` более уместен.

Вам также нужно указать тип возвращаемого значения, и мы решили, что эта функция должна возвращать строку. Вы узнаете больше об этом позже, но в Solidity многие из более сложных типов требуют от вас указания, являются ли они `storage` или `memory`. Затем вы можете заставить вашу функцию возвращать строку `"Hello World!"`.

Не забудьте точку с запятой. В Solidity они обязательны!

У вас должно получиться:

```Solidity
function SayHello() external returns (string memory) {
    return "Hello World!";
}
```

Перед развертыванием проверьте плагин `Compiler`. У вас есть последнее предупреждение:

> Warning: Function state mutability can be restricted to pure

[Modifiers] используются для изменения поведения функции. Модификатор `pure` предотвращает возможность функции изменять или даже обращаться к состоянию. Хотя это и не обязательно, использование этих модификаторов может помочь вам и другим программистам понимать намерение и влияние функций, которые вы пишете. Ваша окончательная функция должна быть похожа на:

```Solidity
function SayHello() external pure returns (string memory) {
    return "Hello World!";
}
```

### Развертывание и тестирование

Подтвердите, что на значке плагина компилятора есть зеленая галочка, а затем переключитесь на плагин _Deploy_ & _Run Transactions_.

Нажмите кнопку _Deploy_, и ваш контракт должен появиться в разделе _Deployed Contracts_. Откройте его, а затем нажмите кнопку _SayHello_. Сработало?

Вы должны увидеть ваше сообщение под кнопкой. Другой вариант увидеть возвращаемое значение для вашей функции `HelloWorld` - развернуть запись в консоли. Вы должны увидеть декодированный вывод:

```text
{
	"0": "string: Hello World!"
}
```

---

## Приветствие

Теперь давайте изменим вашу функцию приветствия, чтобы она приветствовала пользователя по имени, а не просто говорила "Hello World!"

### Первая попытка

Вы, вероятно, ожидаете, что это будет довольно просто. Начните с изменения имени функции (или добавления новой) на `Greeter` и добавьте параметр для `string memory _name`. Подчеркивание - это распространенное соглашение для обозначения функций и переменных как внутренних для их области видимости. Это помогает вам различать переменную хранилища и переменную памяти, которая существует только в пределах вызова.

Наконец, попробуйте создать возвращаемую строку, подобно тому, как вы могли бы сделать в другом языке, с помощью `"Hello " + _name`. У вас должно получиться:

```Solidity
// Плохой пример кода: Не работает
function Greeter(string memory _name) external pure returns (string memory) {
    return "Hello " + _name + "!";
}
```

К сожалению, это не работает в Solidity. Сообщение об ошибке, которое вы получаете, немного сбивает с толку:

> TypeError: Operator + not compatible with types literal_string "Hello" and string memory.

Вы могли бы подумать, что есть какая-то ошибка приведения типов или преобразования, которую можно решить, явно преобразовав строковый литерал в string memory, или наоборот. Это отличная интуиция. Solidity - очень явный язык.

Однако вы получаете похожую ошибку с `"Hello " + "world"`.

Конкатенация строк возможна в Solidity, но она немного сложнее, чем в большинстве языков, и не без причины. Работа со строками стоит большого количества газа, поэтому обычно лучше обрабатывать такого рода операции на фронтенде.

### План B

Мы все еще хотим вернуть что-то с именем, предоставленным пользователем, поэтому давайте попробуем что-то немного другое. Solidity - _вариативный_ язык, что означает, что он позволяет функциям возвращать более одного значения.

Измените объявление возвращаемого значения: `returns (string memory, string memory)`

Теперь ваша функция может возвращать [tuple] содержащий две строки!

`return ("Hello", _name)`;

Разверните и протестируйте ваш контракт. Вы должны получить _декодированный вывод_ с:

```text
{
	"string _name": "Your Name"
}
```

### Полный пример кода

```solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

contract HelloWorld {

    function SayHello() external pure returns (string memory) {
        return "Hello World!";
    }

    // Плохой пример кода: Не работает
    // function Greeter(string memory _name) external pure returns (string memory) {
    //     return "Hello " + _name;
    // }

    function Greeter(string memory _name) external pure returns (string memory, string memory) {
        return ("Hello", _name);
    }
}
```

---

## Заключение

Поздравляем! Вы написали и протестировали свой первый смарт-контракт! Вы выбрали лицензию и версию Solidity. Вы объявили контракт и добавили функцию, которая возвращает значение.

Вы также узнали больше о некоторых способах, которыми Solidity сложнее для работы, чем другие языки, и о дополнительных элементах, которые иногда нужно указывать для функций и типов.

---


[_SPDX-License-Identifier_]: https://spdx.org/licenses/
[version]: https://docs.soliditylang.org/en/v0.8.17/layout-of-source-files.html?#version-pragma
[visibility specifier]: https://docs.soliditylang.org/en/v0.8.17/cheatsheet.html?#function-visibility-specifiers
[modifiers]: https://docs.soliditylang.org/en/v0.8.17/cheatsheet.html?#modifiers
[tuple]: https://en.wikipedia.org/wiki/Tuple
