---
title: Базовые типы
description: Введение в базовые типы в Solidity.
hide_table_of_contents: false
---

import { Danger } from "/snippets/danger.mdx";

В Solidity присутствует большинство базовых [типов][types], к которым вы привыкли в других языках, но их свойства и использование часто немного отличаются от других языков и, вероятно, гораздо более ограничены. В частности, Solidity - очень **явный** язык и в большинстве случаев не позволит вам делать допущения.

---

## Цели обучения

После изучения этого урока вы сможете:

- Классифицировать базовые типы данных
- Перечислить основные различия между типами данных в Solidity по сравнению с другими языками
- Сравнить и противопоставить знаковые и беззнаковые целые числа

---

## Общие свойства

В Solidity [типы][types] всегда должны иметь значение и никогда не бывают `undefined`, `null` или `none`. Из-за этого каждый тип имеет значение по умолчанию. Если вы объявляете переменную без присвоения значения, она вместо этого получит значение по умолчанию для этого типа. Это свойство может привести к коварным ошибкам, пока вы к нему не привыкнете.

```solidity
uint defaultValue;
uint explicitValue = 0;

// (defaultValue == explicitValue) <-- true
```

Типы можно преобразовывать из одного типа в другой, но не так свободно, как вы могли бы ожидать. Например, чтобы преобразовать `uint256` в `int8`, нужно выполнить преобразование дважды:

```solidity
uint256 first = 1;
int8 second = int8(int256(first));
```

<Danger>
Защита от переполнения/потери значимости (описанная ниже) не обеспечивает защиту при преобразовании типов.

```solidity
uint256 first = 256;
int8 second = int8(int256(first)); // <- Значение, сохраненное в second, равно 0
```
</Danger>


## Логический тип (Boolean)

[Booleans] могут иметь значение `true` или `false`. В Solidity нет концепции truthy или falsey, и небулевые значения по замыслу не могут быть преобразованы в логические. Краткое обсуждение в этом [issue] объясняет почему и раскрывает философию этого решения.

### Логические операторы

Стандартные логические операторы (`!`, `&&`, `||`, `==`, `!=`) применяются к логическим значениям. Правила короткого замыкания действительно применяются, что иногда можно использовать для экономии газа, поскольку если первый оператор в `&&` равен `false` или в `||` равен `true`, второй не будет вычисляться. Например, следующий код выполнится без ошибки, несмотря на деление на ноль во втором выражении.

```solidity
// Плохой код для примера. Не используйте.
uint divisor = 0;
if(1 < 2 || 1 / divisor > 0) {
    // Сделать что-то...
}
```

Вы не можете использовать какие-либо варианты `>` или `<` с логическими значениями, потому что они не могут быть неявно или явно преобразованы в тип, который использует эти операторы.

---

## Числа

В Solidity существует несколько типов для знаковых и беззнаковых [integers], которые игнорируются не так часто, как в других языках, из-за потенциальной экономии газа при хранении меньших чисел. Поддержкаr [fixed point numbers] находится в разработке, но не полностью реализована по состоянию на версию `0.8.17`.

Числа с плавающей точкой не поддерживаются и вряд ли будут. Плавающая точность включает в себя присущий элемент неоднозначности, который не подходит для явных сред, таких как блокчейны.

### Минимум, максимум и переполнение

Минимальные и максимальные значения для каждого типа можно получить с помощью `type(<type>).min` и `type(<type>).max`. Например, `type(uint).min` это **0**, и `type(uint).max` равно **2^256-1**.

Переполнение или потеря значимости приведет к _откату_ (revert) транзакции, если только это не происходит в блоке кода, помеченном как [unchecked].

### `uint` vs. `int`

В Solidity общепринятой практикой является предпочтение `uint` перед `int`, когда известно, что значение никогда (или не должно) быть ниже нуля. Эта практика помогает писать более безопасный код, требуя от вас объявлять, должно ли данное значение быть отрицательным. Используйте `uint` для значений, которые не должны быть отрицательными, таких как индексы массивов, балансы счетов и т.д., и `int` для значений, которым нужно быть отрицательными.

### Варианты целых чисел

Меньшие и большие варианты целых чисел существуют во многих языках, но во многих случаях вышли из моды, отчасти потому, что память и хранилище относительно дешевы. Solidity поддерживает размеры с шагом восемь от `uint8` до `uint256`, и то же самое для `int`.

Целые числа меньшего размера используются для оптимизации расхода газа при операциях с хранилищем, но за это есть цена. EVM работает с 256-битными словами, поэтому операции с типами данных меньшего размера должны сначала быть преобразованы, что стоит газа.

`uint` является псевдонимом для `uint256` и может считаться типом по умолчанию.

### Операторы

Операторы сравнения (`<=`, `<`, `==`, `!=`, `>=`, `>`) и арифметические операторы (`+`, `-`, `*`, `/`, `%`, `**`) присутствуют и работают как ожидается. Вы также можете использовать побитовые операторы и операторы сдвига.

Варианты `uint` и `int` можно сравнивать напрямую, например `uint8` и `uint256`, но для сравнения `uint` с `int` необходимо преобразовать одно из значений.

```solidity
uint first = 1;
int8 second = 1;

if(first == uint8(second)) {
    // Сделать что-то...
}
```

---

## Адреса (Addresses)

Тип [address] - это относительно уникальный тип, представляющий адрес кошелька или контракта. Он хранит 20-байтовое значение, подобное тому, которое мы исследовали, когда вы развертывали свой контракт _Hello World_ в _Remix_. `address payable` - это вариант `address`, который позволяет использовать методы `transfer` и `send`. Это различие помогает предотвратить отправку Ether или других токенов в контракт, который не предназначен для их получения. Если бы это произошло, Ether был бы потерян.

Адреса **не** являются строками и не требуют кавычек при представлении в литеральной форме, но разрешены преобразования из `bytes20` и `uint160`.

```solidity
address existingWallet = 0xd9145CCE52D386f254917e481eB44e9943F39138;
```

### Члены адресов

Адреса содержат ряд функций. `balance` возвращает баланс адреса, а `transfer`, упомянутый выше, можно использовать для отправки `ether`.

```solidity
function getBalance(address _address) public view returns(uint) {
    return _address.balance;
}
```

Позже вы узнаете о `call`, `delegatecall` и `staticcall`, которые можно использовать для вызова функций, развернутых в других контрактах.

---

## Контракты

Когда вы объявляете [contract], вы определяете тип. Этот тип можно использовать для создания экземпляра одного контракта в качестве локальной переменной внутри второго контракта, что позволяет второму взаимодействовать с первым.

---

## Байтовые массивы и строки

[Byte arrays] бывают как фиксированного, так и динамического размера. Они содержат последовательность байтов. Массивы немного сложнее, чем в других языках, и будут подробно рассмотрены позже.

### Строки 

Строки в Solidity являются массивами, а не отдельным типом. Вы не можете объединять их с помощью `+`, но начиная с версии 0.8.12 вы можете использовать `string.concat(first, second)`. Они ограничены печатными символами и escape-последовательностями. Преобразование других типов данных в `string` в лучшем случае сложно, а иногда невозможно.

Вообще говоря, вы должны быть осмотрительны при работе со строками внутри смарт-контракта. Не бойтесь использовать их, когда это уместно, но по возможности создавайте и отображайте сообщения на фронтенде, а не тратьте газ на их сборку на бэкенде.

---

## Перечисления 

[Enums] позволяют применять удобочитаемые метки к списку беззнаковых целых чисел.

```solidity
enum Flavors { Vanilla, Chocolate, Strawberry, Coffee }

Flavors chosenFlavor = Flavors.Coffee;
```

Перечисления могут быть явно преобразованы в `uint` и из `uint`, но не неявно. Они ограничены 256 элементами.

---

## Константы и неизменяемые переменные

[constant and immutable] позволяют объявлять переменные, которые нельзя изменить. Оба приводят к экономии газа, потому что компилятору не нужно резервировать слот хранилища для этих значений.

По состоянию на версию _0.8.17_ `constant` и `immutable` не полностью реализованы. Оба поддерживаются для [value types], а `constant` также можно использовать со строками.

### Константы 

Константы можно объявлять на уровне файла или на уровне контракта. В Solidity модификаторы указываются после объявления типа. Необходимо инициализировать значение при объявлении константы. Согласно конвенции, для констант используется SCREAMING_SNAKE_CASE.

```solidity
uint constant NUMBER_OF_TEAMS = 10;

contract Cars {
    uint constant NUMBER_OF_CARS = 20;
}
```

При компиляции компилятор заменяет каждый экземпляр константной переменной ее литеральным значением.

### Неизменяемые переменные

Ключевое слово immutable используется для объявления переменных, которые устанавливаются один раз в конструкторе, а затем никогда не изменяются:

```solidity
contract Season {
    immutable numberOfRaces;

    constructor(uint _numberOfRaces) {
        numberOfRaces = _numberOfRaces;
    }
}
```

---

## Заключение

Вы узнали об использовании и некоторых уникальных особенностях общих типов переменных в Solidity. Вы увидели, как обрабатывается переполнение и потеря значимости и как это поведение можно переопределить. Вы узнали, почему беззнаковые целые числа используются чаще, чем в других языках, почему числа с плавающей точкой отсутствуют, и познакомились с некоторыми особенностями работы со строками. Наконец, вы познакомились с типами данных адреса и контракта.

---

[types]: https://docs.soliditylang.org/en/v0.8.17/types.html
[Booleans]: https://docs.soliditylang.org/en/v0.8.17/types.html#booleans
[issue]: https://github.com/ethereum/solidity/issues/1200
[integers]: https://docs.soliditylang.org/en/v0.8.17/types.html#integers
[fixed point numbers]: https://docs.soliditylang.org/en/v0.8.17/types.html#fixed-point-numbers
[unchecked]: https://docs.soliditylang.org/en/v0.8.17/control-structures.html#unchecked
[address]: https://docs.soliditylang.org/en/v0.8.17/types.html#address
[contract]: https://docs.soliditylang.org/en/v0.8.17/types.html#contract-types
[Byte arrays]: https://docs.soliditylang.org/en/v0.8.17/types.html#fixed-size-byte-arrays
[Enums]: https://docs.soliditylang.org/en/v0.8.17/types.html#enums
[constant and immutable]: https://docs.soliditylang.org/en/v0.8.17/contracts.html?constant-and-immutable-state-variables#constant-and-immutable-state-variables
[value types]: https://docs.soliditylang.org/en/v0.8.17/types.html#value-types
