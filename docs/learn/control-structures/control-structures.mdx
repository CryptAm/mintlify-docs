---
title: Управляющие структуры
sidebarTitle: Обзор
description: Узнайте, как управлять потоком выполнения кода в Solidity.
hide_table_of_contents: false
---


Solidity поддерживает многие знакомые управляющие структуры, но они имеют дополнительные ограничения и особенности из-за стоимости газа и необходимости установки максимального количества газа, которое можно потратить в данной транзакции.

---

## Цели обучения

После изучения этого урока вы сможете:

- Управлять потоком выполнения кода с помощью `if`, `else`, `while`, и `for`
- Перечислить уникальные ограничения для управления потоком в Solidity
- Использовать `require` для написания функции, которую можно использовать только когда переменная установлена в `true`
- Написать оператор `revert` для прерывания выполнения функции в определенном состоянии
- Использовать `error` для более эффективного управления потоком, чем с помощью `require`

---

## Управляющие структуры

Solidity поддерживает базовые условные и итеративные [control structures], которые встречаются в других языках с фигурными скобками, но **не поддерживает** более продвинутые операторы, такие как `switch`, `forEach`, `in`, `of`, и т.д.

Solidity поддерживает `try`/`catch`, но только для вызовов других контрактов.

<Warning>
[Yul] это язык промежуточного уровня, который может быть встроен в контракты Solidity и документирован в рамках документации по Solidity. Yul **содержит** оператор `switch`, что может сбивать с толку при поиске.
</Warning>


### Примеры условных управляющих структур

Операторы  `if`, `else if`, и `else`, работают как ожидается. Фигурные скобки могут быть опущены для однострочных тел, но мы рекомендуем избегать этого, так как это менее явно.

```solidity
function ConditionalExample(uint _number) external pure returns (string memory) {
    if(_number == 0) {
        return "The number is zero.";
    } else if(_number % 2 == 0) {
        return "The number is even and greater than zero.";
    } else {
        return "The number is odd and is greater than zero.";
    }
}
```

### Итеративные управляющие структуры

Ключевые слова `while`, `for`, и `do` функционируют так же, как и в других языках. Вы можете использовать `continue`, чтобы пропустить остаток цикла и начать следующую итерацию. `break` завершит выполнение цикла, а `return` можно использовать для выхода из функции и возврата значения в любой точке.

<Note>
Вы можете использовать `console.log`, импортировав `import "hardhat/console.sol";`. Это потребует пометить иначе `pure` контракты как `view`.
</Note>


```solidity
uint times; // Значение по умолчанию — 0!
for(uint i = 0; i <= times; i++) {
    console.log(i);
}

uint timesWithContinue;
for(uint i = 0; i <= timesWithContinue; i++) {
    if(i % 2 == 1) {
        continue;
    }
    console.log(i);
}

uint timesWithBreak;
for(uint i = 0; i <= timesWithBreak; i++) {
    // Всегда останавливаться на 7
    if(i == 7) {
        break;
    }
    console.log(i);
}

uint stopAt = 10;
while(stopAt <= 10) {
    console.log(i);
    stopAt++;
}

uint doFor = 10;
do {
    console.log(i);
    doFor++;
} while(doFor <= 10);
```

---

## Обработка ошибок

Solidity содержит набор относительно уникальных встроенных функций и ключевых слов для обработки [ошиибок][errors]. Они гарантируют выполнение определенных требований и полностью прерывают все выполнение функции, откатывая любые изменения состояния, произошедшие во время выполнения функции. Вы можете использовать эти функции, чтобы помочь защитить безопасность ваших контрактов и ограничить их выполнение.

Подход может показаться отличным от других сред. Если ошибка произойдет в середине высокорискованной транзакции, такой как перевод миллионов долларов токенов, вы **не хотите**, чтобы выполнение продолжалось, частично завершалось или поглощало ошибки.

### Revert и Error

Ключевое слово `revert` останавливает и откатывает выполнение. Оно должно использоваться в паре с пользовательской `error`. Revert следует использовать для предотвращения операций, которые логически допустимы, но не должны быть разрешены по бизнес-причинам. Это **не** ошибка, если срабатывает `revert`. Примеры, где `revert` и `error` использовались бы для контроля операций, включают:

- Разрешение доступа к функциональности только определенным отправителям
- Предотвращение вывода депозита до определенной даты
- Разрешение вводов при определенных условиях состояния и запрет их при других

Пользовательские `error` могут быть объявлены без параметров, но они гораздо полезнее, если вы их включаете:

```solidity
error OddNumberSubmitted(uint _first, uint _second);
function onlyAddEvenNumbers(uint _first, uint _second) public pure returns (uint) {
    if(_first % 2 != 0 || _second % 2 != 0) {
        revert OddNumberSubmitted(_first, _second);
    }
    return _first + _second;
}
```

При срабатывании `error` предоставляет значения в указанных параметрах. Эта информация очень полезна при отладке и/или для передачи информации на фронтенд, чтобы сообщить пользователю, что произошло:

```text
call to HelloWorld.onlyAddEvenNumbers errored: VM error: revert.

revert
	Транзакция была откачена до исходного состояния.
Ошибка, предоставленная контрактом:
OddNumberSubmitted
Parameters:
{
 "_first": {
  "value": "1"
 },
 "_second": {
  "value": "2"
 }
}
Отладьте транзакцию, чтобы получить больше информации.
```

Вы также встретите `revert`, используемое как функция, возвращающая строковую ошибку. Этот устаревший шаблон был сохранен для поддержания совместимости со старыми контрактами:

```solidity
function oldRevertAddEvenNumbers(uint _first, uint _second) public pure returns (uint) {
    if(_first % 2 != 0 || _second % 2 != 0) {
        // Устаревшее использование revert, не используйте
        revert("One of the numbers is odd");
    }
    return _first + _second;
}
```

Сообщение об ошибке здесь менее полезно:

```text
Вызов HelloWorld.oldRevertAddEvenNumbers завершился ошибкой: Ошибка VM: revert.

revert
	Транзакция была откачена до исходного состояния.
Причина, предоставленная контрактом: "Одно из чисел нечетное".
Отладьте транзакцию, чтобы получить больше информации.
```

### Require

Функция `require` выходит из употребления, потому что она использует больше газа, чем шаблон выше. Вам все равно следует ознакомиться с ней, потому что она присутствует в бесчисленных контрактах, руководствах и примерах.

`require` принимает логическое условие и строковую ошибку в качестве аргументов. Более эффективно по газу разделять логические операторы, если они не взаимозависимы. Другими словами, не используйте `&&` или `||` в `require`, если можете этого избежать.

Например:

```solidity
function requireAddEvenNumbers(uint _first, uint _second) public pure returns (uint) {
    // Устаревший шаблон, не используйте
    require(_first % 2 == 0, "First number is not even");
    require(_second % 2 == 0, "Second number is not even");

    return _first + _second;
}
```

Сообщение об ошибке будет содержать только первую неудачную проверку. Если вы отправите `1` и `3` в эту функцию, ошибка будет содержать только первое сообщение:

```test
Вызов HelloWorld.requireAddEvenNumbers завершился ошибкой: Ошибка VM: revert.

revert
	Транзакция была откачена до исходного состояния.
Причина, предоставленная контрактом: "Первое число нечетное".
Отладьте транзакцию, чтобы получить больше информации.
```

### Assert и Panic

Ключевое слово `assert` выбрасывает ошибку `panic`, если срабатывает. `Panic` - это тот же тип ошибки, который возникает при попытке деления на ноль или доступа к массиву за пределами границ. Оно используется для тестирования внутренних ошибок и никогда не должно срабатывать при нормальных операциях, даже с ошибочным вводом. У вас есть ошибка, которую следует исправить, если assert выбрасывает исключение:

```solidity
function ProcessEvenNumber(uint _validatedInput) public pure {
    // Если assert сработает, проверка ввода не удалась. Этого никогда не должно
    // происходить!
    assert(_validatedInput % 2 == 0);
    // Сделать что-то...
}
```

Вывод здесь не так полезен, поэтому вы можете предпочесть использовать один из шаблонов выше.

```text
Вызов HelloWorld.ProcessEvenNumber завершился ошибкой: Ошибка VM: revert.

revert
	Транзакция была откачена до исходного состояния.
Примечание: Вызываемая функция должна быть payable, если вы отправляете значение, и отправляемое значение должно быть меньше вашего текущего баланса.
Отладьте транзакцию, чтобы получить больше информации.
```

---

## Заключение

В этом уроке вы узнали, как управлять потоком выполнения кода с помощью стандартных условных и итеративных операторов. Вы также узнали об уникальных ключевых словах, которые Solidity использует для генерации ошибок и сброса изменений, если одно из них сработало. Вы познакомились как с новыми, так и с устаревшими методами написания ошибок и узнали разницу между `assert` и `require`.



[switch]: https://docs.soliditylang.org/en/v0.8.17/yul.html?#switch
[yul]: https://docs.soliditylang.org/en/v0.8.17/yul.html
[control structures]: https://docs.soliditylang.org/en/v0.8.17/control-structures.html
[errors]: https://docs.soliditylang.org/en/v0.8.17/control-structures.html#error-handling-assert-require-revert-and-exceptions
