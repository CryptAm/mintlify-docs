---
title: Массивы
sidebarTitle: Руководство по массивам
description: Обзор того, как работают массивы в Solidity.
hide_table_of_contents: false
---

Массивы в Solidity - это коллекции элементов одного типа, доступные по индексу, как и в любом другом языке. В отличие от других языков, существует три типа массивов - `storage`, `memory` и `calldata`. Каждый из них имеет свои свойства и ограничения.

---

## Цели обучения

После изучения этого урока вы сможете:

- Описать разницу между массивами storage, memory и calldata

---

## Storage, Memory, and Calldata

Ключевые слова `storage`, `memory` или `calldata` требуются при объявлении новой переменной . Это ключевое слово определяет , где хранится переменная и как долго она будет существовать.

### Storage

Ключевое слово `storage` используется для назначения переменных состояния, которые становятся частью блокчейна как часть хранилища вашего контракта. Они остаются назначенными до изменения в течение всего времени жизни контракта.

Storage **очень дорогой** по сравнению с большинством других сред. Минимальная стоимость в новом слоте хранилища составляет 20000 газа, хотя обновление этого значения после первоначального назначения дешевле (~5000+ газа).

Эта стоимость не является причиной бояться использования storage. В долгосрочной перспективе написание чистого, поддерживаемого и логичного кода всегда будет стоить дешевле, чем прыжки через обручи для экономии газа здесь и там. Просто будьте так же внимательны с хранилищем в EVM, как и с вычислениями в большинстве других сред.

### Memory

Ключевое слово `memory` создает временные переменные, которые существуют только в пределах области видимости, в которой они созданы. Memory менее затратен, чем storage, хотя это относительно. Часто бывают обстоятельства, когда дешевле работать напрямую в storage, чем конвертировать в memory и обратно. Копирование из одного места в другое может быть довольно дорогим!

### Calldata

Место хранения `calldata` - это где хранятся аргументы функций. Оно неизменяемо, и документация Solidity рекомендует использовать его там, где это возможно, чтобы избежать ненужного копирования, потому что его нельзя изменить. Вы узнаете больше об этом позже, но это может помочь предотвратить запутанные ошибки при вызове функции из другого контракта, который принимает значения из `storage` этого контракта.

---

## Места хранения массивов

Массивы ведут себя по-разному в зависимости от их места хранения. Поведение при присваивании также зависит от места хранения. [quote the docs]:

> - Присваивания между `storage` и `memory` (или из `calldata`) всегда создают независимую копию.
>
> - Присваивания из `memory` в `memory` создают только ссылки. Это означает, что изменения в одной переменной memory также видны во всех других переменных memory, которые ссылаются на те же данные.
>
> - Присваивания из `storage` в **локальную** переменную `storage` также только присваивают ссылку.
>
> - Все другие присваивания в `storage` всегда копируют. Примерами этого случая являются присваивания переменным состояния или членам локальных переменных типа storage struct, даже если сама локальная переменная является всего лишь ссылкой.

### Массивы Storage

_Массивы_ в `storage` передаются по ссылке. Другими словами, если вы назначите массив storage полдюжины имен, любые изменения, которые вы внесете, всегда будут изменять исходный, базовый массив storage.

```solidity
contract StorageArray {
    // Переменные, объявленные на уровне класса, всегда `storage`
    uint[] arr = [1, 2, 3, 4, 5];

    function function_1() public {
        uint[] storage arr2 = arr;

        arr2[0] = 99; // <- arr теперь [99, 2, 3, 4, 5];
    }
}
```

Вы не можете использовать массив `storage` в качестве параметра функции, и вы не можете написать функцию, которая `return` массив `storage`.

Массивы storage являются динамическими, если они не объявлены с явным размером. Однако их функциональность ограничена по сравнению с другими языками. Функция `.push(value)` работает как ожидается. Функция `.pop()` удаляет последнее значение массива, но она не возвращает это значение. Вы также не можете использовать `.pop()` с индексом для удаления элемента из середины массива или для удаления более чем одного элемента.

Вы можете использовать ключевое слово `delete` с массивом. Применение его ко всему массиву сбросит массив к нулевой длине. Вызов его для элемента внутри массива сбросит это значение к значению по умолчанию. Он **не изменит** размер массива!

```solidity
uint[] arr_2 = [1, 2, 3, 4, 5];
function function_2(uint _num) public returns(uint[] memory) {
    arr_2.push(_num); // <- arr_2 это [1, 2, 3, 4, 5, <_num>]

    delete arr_2[2];  // <- arr_2 это [1, 2, 0, 4, 5, <_num>]

    arr_2.pop();  // <- arr_2 это [1, 2, 0, 4, 5] (_num НЕ возвращается by .pop())

    delete arr_2; // <- arr_2 это []

    return arr_2; // <- возвращает []
}
```

Массивы storage неявно преобразуемы в массивы `memory`.

### Массивы Memory

Массивы, объявленные как `memory`, являются временными и существуют только в пределах области видимости, в которой они созданы. Массивы в `memory` не являются динамическими и должны объявляться с фиксированным размером. Это можно сделать во время компиляции, объявив размер внутри `[]`, или во время выполнения, используя ключевое слово `new`. Наконец, массивы `memory` могут быть неявно приведены из массивов `storage`.

```solidity
function function_3(uint _arrSize) public {
    uint[5] memory arrSizeFive;
    uint[] memory arrWithCustomSize = new uint[](_arrSize);
    uint[] memory localCopyOfArr = arr;
    // ...сделать что-то
}
```

Шаблон объявления влияет на стоимость газа, хотя имейте в виду, что первые два примера пусты и будут стоить дополнительный газ в зависимости от того, как они в конечном итоге заполняются.

```solidity
function declareMemoryArrays() public view {
    uint[5] memory simpleArr; // эта строка стоит 135 газа
    uint[] memory emptyArr = new uint[](5); // Эта строка стоит 194 газа
    uint[] memory arrCopy = arr; // Эта строка стоит 13166 газа
}
```

Отсутствие динамических массивов `memory` может потребовать некоторых ухищрений, если вам нужно создать массив, размер которого изначально неизвестен. В зависимости от конкретных потребностей задачи допустимыми решениями для фильтрации массива и возврата меньшего массива могут быть:

- Двойной проход по большему массиву, сначала для подсчета количества, затем для копирования соответствующих элементов
- Отслеживание количества элементов, удовлетворяющих условию X, с помощью переменной storage, затем создание массива с помощью `<type>[] memory filteredArray = new <type>[](numX);`
- Использование нескольких структур данных для отслеживания ссылок на разные подмножества

### Массивы Calldata

Массивы в `calldata` доступны только для чтения. В остальном они функционируют так же, как и любые другие массивы.

[slices] массивов в настоящее время реализованы только для массивов `calldata`.

---

## Заключение

В этом уроке вы узнали о различиях между местами хранения данных `memory`, `storage` и `calldata`. Вы также узнали, как они применяются к массивам, причем каждый из них имеет свои свойства, ограничения и стоимость.

---


[data location]: https://docs.soliditylang.org/en/v0.8.17/types.html?highlight=calldata#data-location
[reference type]: https://docs.soliditylang.org/en/v0.8.17/types.html?highlight=array#reference-types
[store a value]: https://github.com/wolflo/evm-opcodes/blob/main/gas.md#a7-sstore
[quote the docs]: https://docs.soliditylang.org/en/v0.8.17/types.html?#data-location-and-assignment-behaviour
[slices]: https://docs.soliditylang.org/en/v0.8.17/types.html?#array-slices
