---
title: Фильтрация массива
sidebarTitle: Фильтрация массивов
description: Изучите техники фильтрации массива.
hide_table_of_contents: false
---

В этом упражнении вы исследуете два различных решения для фильтрации массива в Solidity. Сделав это, вы лучше поймете ограничения, присутствующие при работе с массивами, и получите возможность изучить и сравнить стоимость газа разных подходов.

---

## Цели обучения

После изучения этого урока вы сможете:

- Написать функцию, которая может возвращать отфильтрованное подмножество массива

---

## Решение первого подхода

### Настройка

Создайте новую рабочую область в Remix и добавьте файл `ArrayDemo.sol` содержащий `contract` `ArrayDemo`. Инициализируйте массив, содержащий числа от 1 до 10. Добавьте заглушку для функции `getEvenNumbers`,которая возвращает `uint[] memory`.

```solidity
contract ArrayDemo {
    uint[] public numbers = [1,2,3,4,5,6,7,8,9,10];

    function getEvenNumbers() external view returns(uint[] memory) {
        // TODO
    }
}
```

<Warning>
Вам не нужно объявлять размер возвращаемого массива memory. Обычно вы и не хотите этого делать, если только результаты не всегда будут одного известного размера.
</Warning>


### Поиск количества четных чисел

Нам нужно инициализировать массив `memory` для хранения результатов, но чтобы это сделать, нам нужно знать, какого размера его создать. Не поддавайтесь соблазну подсчитать количество четных чисел в `numbers`, потому что что произойдет, если мы изменим его позже?

Простое и очевидное решение - просто пройтись по `numbers` и подсчитать, сколько четных чисел присутствует. Вы могли бы добавить эту функциональность в `getEvenNumbers()`, но она может быть полезна и в других местах, поэтому лучшей практикой было бы разделить эти обязанности на другую функцию.

Попробуйте написать ее самостоятельно. Она должна:

- Создать переменную `uint` для хранения результатов
- Пройтись по всем значениям в `numbers` и увеличить это число, если значение четное
- Вернуть результат

У вас должно получиться что-то вроде:

<Accordion title="Reveal code">

```solidity
function _countEvenNumbers() internal view returns(uint) {
    uint result = 0;

    for(uint i = 0; i < numbers.length; i++) {
        if(numbers[i] % 2 == 0) {
            result++;
        }
    }

    return result;
}
```
</Accordion>

Символ `_` перед именем функции - это практика, используемая некоторыми разработчиками в Solidity и других языках, чтобы визуально указать, что эта функция предназначена только для внутреннего использования.

### Возврат только четных чисел

Теперь, когда у нас есть метод, чтобы узнать, какого размера должен быть возвращаемый массив в `getEvenNumbers()`, мы можем просто пройтись по `numbers` и добавить четные числа в массив для возврата.

Завершите функцию самостоятельно. Она должна:

- Определить количество результатов и создать массив такого размера
- Пройтись по массиву numbers и, если данное число четное, добавить его в следующий неиспользованный индекс в массиве результатов

У вас должно получиться что-то вроде:

<Accordion title="Reveal code">

```solidity

function getEvenNumbers() external view returns(uint[] memory) {
    uint resultsLength = _countEvenNumbers();
    uint[] memory results = new uint[](resultsLength);
    uint cursor = 0;

    for(uint i = 0; i < numbers.length; i++) {
        if(numbers[i] % 2 == 0) {
            results[cursor] = numbers[i];
            cursor++;
        }
    }

    return results;
}

```

</Accordion>

Вы заметили предупреждение компилятора о `view`? Вы не изменяете состояние, поэтому должны пометить функцию соответствующим образом.

### Тестирование функции

Разверните свой контракт и протестируйте функцию. Вы должны получить возврат `[2,4,6,8,10]`. Общая стоимость газа составит около 63 947, в зависимости от того, использовали ли вы те же вспомогательные переменные и т.д.

---

## Оптимизация функции

Кажется неэффективным проходить по одному и тому же массиву дважды. Что если вместо этого мы будем отслеживать, сколько четных чисел ожидать. Таким образом, нам нужно будет пройтись только один раз, экономя газ! Верно?

Есть только один способ выяснить.

### Отслеживание соответствующих данных

Добавьте переменную уровня контракта `numEven` и инициализируйте ее значением 5 - количеством четных чисел в массиве. Измените `getEvenNumbers()`, чтобы использовать `numEven` вместо функции `_countEvenNumbers()`. Теперь она должна выглядеть так:

<Accordion title="Reveal code">

```solidity
function getEvenNumbers() external view returns(uint[] memory) {
    uint resultsLength = numEven; // <- Изменено здесь
    uint[] memory results = new uint[](resultsLength);
    uint cursor = 0;

    for(uint i = 0; i < numbers.length; i++) {
        if(numbers[i] % 2 == 0) {
            results[cursor] = numbers[i];
            cursor++;
        }
    }

    return results;
}
```

</Accordion>

Повторно разверните и протестируйте. Успех, функция теперь стоит всего около 57 484 газа для выполнения! За исключением того, что есть загвоздка. Помните, что обновление `numEven` будет стоить около 5000 газа каждый раз, когда массив добавляет четное число.

### Более реалистичный учет

Как мы рассмотрели выше, в реальном примере мы не объявляли бы массив заранее, он изменялся бы со временем. Немного более реалистичный пример - заполнение массива с помощью функции.

Измените объявление `numbers` и `numEven` так, чтобы они имели соответствующие значения по умолчанию для начала.

```solidity
uint[] public numbers;
uint numEven;
```

Добавьте новую функцию `debugLoadArray`, которая принимает аргумент `uint` с именем `_number` и заполняет массив, проходясь `_number` раз, добавляя каждое число в массив. **Пока _не_ обновляйте** `numEven`.

<Accordion title="Reveal code">

```solidity
function debugLoadArray(uint _number) external {
    for(uint i = 0; i < _number; i++) {
        numbers.push(i);
    }
}
```

</Accordion>

Протестируйте функцию, загрузив **10** чисел. Загрузка массива стоит около 249 610 газа. Теперь добавьте функциональность, чтобы **также** увеличивать `numEven`, когда добавляемое число четное. Мы не можем просто вычислить его, потому что хотя числа в отладочной функции последовательны, в реальном использовании они могут не быть таковыми.

<Accordion title="Reveal code">

```solidity
function debugLoadArray(uint _number) external {
    for(uint i = 0; i < _number; i++) {
        numbers.push(i);
        if(i % 2 == 0) {
            numEven++;
        }
    }
}
```

</Accordion>

**Обязательно повторно разверните** и попробуйте снова с **10** числами. На этот раз стоимость составила около 275 335 газа. Это почти на 26 000 газа больше в попытке сэкономить 5 000 газа, необходимых для запуска `_countEvenNumbers()`.

### Взгляд на общую картину

А что насчет большего количества? Что, если в массиве тысяча чисел? А миллион?

Начнем с 500, больше сломает симуляцию EVM Remix и/или вызовет ошибку нехватки газа, потому что мы приближаемся к лимиту газа для всего блока.

**Закомментируйте** оператор `if` в `debugLoadArray`, который проверяет четные числа, и загрузите 500 чисел. Remix EVM должен справиться с этим, но он может зависнуть на мгновение или даже упасть. (Вы также можете провести этот эксперимент с 250 числами вместо 500.)

```solidity
function debugLoadArray(uint _number) external {
    for(uint i = 0; i < _number; i++) {
        numbers.push(i);
        // if(i % 2 == 0) {
        //    numEven++;
        //}
    }
}
```

Вы получите результат около 11 323 132 газа для загрузки массива. Это много! Целевой общий газ для одного блока - 15 миллионов, а лимит — 30 миллионов.

Попробуйте снова с кодом для увеличения `numEven`. Вы должны получить около 11 536 282, или увеличение примерно на 213 150 газа.

Теперь протестируйте `getEvenNumbers()`, используя `numEven` против использования `_countEvenNumbers()`. С `numEven` это должно стоить около 1 578 741 газа для поиска четных чисел. Используя `_countEvenNumbers()`, эта стоимость увеличивается до 1 995 579 газа, увеличение на 416 838 газа.

### Что лучше?

Как это часто бывает с кодом, это зависит. Вы могли бы подумать, что эксперимент делает все очевидным. Оплата 213к газа авансом для отслеживания `_numEven` приводит к экономии более 400к газа при фильтрации четных чисел. Еще лучше, вы могли бы понять, что разница в первоначальной стоимости будет распределена между всеми вашими пользователями со временем, делая ее почти незначительной. Вы также могли бы подумать, что возможно, функция фильтрации будет вызываться десятки раз на каждую загрузку 500 чисел.

Это все важные соображения, которые вы должны оценивать при разработке вашего кодового решения для бизнес-задачи. Последний критический элемент для рассмотрения заключается в том, что стоимость газа для чтения из блокчейна возникает только в том случае, если это другой контракт вызывает функцию. Не стоит никакого газа вызывать функции `view` или `pure` из фронтенда или приложения.

Если `getEvenNumbers` никогда не будет вызываться другим контрактом, то использование `numEven` может стоить больше без какой-либо пользы!

---

## Заключение

В этом уроке вы исследовали несколько различных подходов к проблеме. Вы научились фильтровать массив, но что более важно, вы узнали некоторые специфические соображения в разработке блокчейна. Наконец, вы увидели, что добавление 500 целых чисел в массив, обычно тривиальная операция, является очень большой и очень дорогой на EVM.
