---
title: События
sidebarTitle: Пошаговое руководство
description: События в Solidity
hide_table_of_contents: false
---

В этой статье вы узнаете, как работают события в Solidity, рассмотрев практические примеры и распространенные варианты использования событий.

<Warning>
Это руководство было перемещено в рамках реорганизации! Оно предполагает, что вы используете Hardhat. Все в этом уроке будет работать с небольшими изменениями, если вы работаете в Foundry или Remix.
</Warning>


---

## Цели обучения

После изучения этого урока вы сможете:

- Создавать и вызывать событие
- Перечислять распространенные варианты использования событий
- Понимать разницу между событиями и хранилищем смарт-контракта

---

## Обзор

Понимание того, как работают события в Solidity, важно в мире разработки смарт-контрактов. События предоставляют мощный способ создания событийно-ориентированных приложений в блокчейне. Они позволяют уведомлять внешние стороны, такие как оффчейн-приложения, пользовательские интерфейсы и любые объекты, которые хотят прослушивать события определенного контракта.

В этом руководстве вы узнаете, как объявлять, вызывать и использовать события, получив знания, необходимые для улучшения функциональности и пользовательского опыта ваших децентрализованных приложений.

## Что такое события?

Согласно официальной документации Solidity, [события][events]:

> _...абстракция над функциональностью журналирования EVM. Приложения могут подписываться и прослушивать эти события через RPC-интерфейс клиента Ethereum._

> _...при их вызове они приводят к сохранению аргументов в журнале транзакции — специальной структуре данных в блокчейне. Эти журналы связаны с адресом контракта, который их создал, включаются в блокчейн и остаются там, пока доступен блок (навсегда, на данный момент, но это может измениться в будущем)._

Другими словами, события - это абстракция, которая позволяет хранить информацию журнала транзакции в блокчейне.

## Ваше первое событие в Solidity

Начните с создания первого события в контракте `Lock.sol`, который по умолчанию включен в Hardhat.

Событие называется `Created` и включает адрес создателя и сумму, отправленную во время создания смарт-контракта. Затем `emit` (вызовите) событие в конструкторе:

```solidity
emit Created(msg.sender, msg.value);
```

Контракт выглядит так:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

contract Lock {
    uint public unlockTime;
    address payable public owner;

    event Created(address owner, uint amount);

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);

        emit Created(msg.sender, msg.value);
    }
}
```

События могут быть определены на уровне файла или как наследуемые члены контрактов (включая интерфейсы). Вы также можете определить событие в интерфейсе:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

interface ILock {
    event Created(address owner, uint amount);
}

contract Lock is ILock {
    uint public unlockTime;
    address payable public owner;

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);

        emit Created(msg.sender, msg.value);
    }
}
```

Вы можете протестировать событие, упростив исходный тестовый файл следующим кодом:

```solidity
import {
  time,
} from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { ethers } from "hardhat";

describe("Lock tests", function () {
  describe("Deployment", function () {
    it("Should set the right unlockTime", async function () {
      const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
      const ONE_GWEI = 1_000_000_000;

      const lockedAmount = ONE_GWEI;
      const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

      // Контракты развертываются с использованием первого подписанта/аккаунта по умолчанию
      const [owner] = await ethers.getSigners();

      // Но мы делаем это явно, используя подписанта owner
      const LockFactory = await ethers.getContractFactory("Lock", owner);
      const lock = await LockFactory.deploy(unlockTime, { value: lockedAmount });

      const hash = await lock.deploymentTransaction()?.hash
      const receipt = await ethers.provider.getTransactionReceipt(hash as string)

      console.log("Sender Address", owner.address)
      console.log("Receipt.logs", receipt?.logs)

      const defaultDecoder = ethers.AbiCoder.defaultAbiCoder()
      const decodedData = defaultDecoder.decode(['address', 'uint256'], receipt?.logs[0].data as string)
      console.log("decodedData", decodedData)
    });
  });
});
```

Обратите внимание, что предыдущий код выводит адрес отправителя и журналы, поступающие из квитанции транзакции. Вы также декодируете поле `receipts.logs[0].data`, которое содержит информацию, созданную событием, но не в удобочитаемом виде, так как она закодирована. По этой причине вы можете использовать `AbiCoder` для декодирования сырых данных.

Запустив `npx hardhat test`, вы должны увидеть следующее:

```solidity
  Lock tests
    Deployment
Sender Address 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Receipt.logs [
  Log {
    provider: HardhatEthersProvider {
      _hardhatProvider: [LazyInitializationProviderAdapter],
      _networkName: 'hardhat',
      _blockListeners: [],
      _transactionHashListeners: Map(0) {},
      _eventListeners: []
    },
    transactionHash: '0xad4ff104036f23096ea5ed165bff1c3e1bc0f53e375080f84bce4cc108c28cee',
    blockHash: '0xb2117cfd2aa8493a451670acb0ce14228b06d17bf545cd7efad6791aeac83c05',
    blockNumber: 1,
    removed: undefined,
    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
    data: '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000000000000000000000000000000000003b9aca00',
    topics: [
      '0x0ce3610e89a4bb9ec9359763f99110ed52a4abaea0b62028a1637e242ca2768b'
    ],
    index: 0,
    transactionIndex: 0
  }
]
decodedData Result(2) [ '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', 1000000000n ]
      ✔ Should set the right unlockTime (1008ms)
```

Обратите внимание, что значение `f39fd6e51aad88f6f4ce6ab8827279cfffb92266` закодировано в свойстве data, и это адрес отправителя.

## Темы событий

Еще одна важная особенность: события могут быть индексированными путем добавления атрибута indexed к объявлению события.

Например, если вы измените интерфейс следующим образом:

```solidity
interface ILock {
    event Created(address indexed owner, uint amount);
}
```

Затем, если вы снова запустите `npx hardhat test`, может возникнуть ошибка, потому что декодирование предполагает, что поле data содержит `address` и `uint256`. Но, добавив атрибут indexed, вы указываете, что события будут добавлены в специальную структуру данных, известную как "темы" (topics). Темы имеют некоторые ограничения: максимальное количество индексированных параметров может быть до трех, а тема может содержать только одно слово (32 байта).

Затем вам нужно изменить строку декодирования в тестовом файле на следующую:

```solidity
const decodedData = defaultDecoder.decode(['uint256'], receipt?.logs[0].data as string)
```

Затем вы должны увидеть квитанцию как:

```solidity
 Lock tests
    Deployment
Sender Address 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Receipt.logs [
  Log {
    provider: HardhatEthersProvider {
      _hardhatProvider: [LazyInitializationProviderAdapter],
      _networkName: 'hardhat',
      _blockListeners: [],
      _transactionHashListeners: Map(0) {},
      _eventListeners: []
    },
    transactionHash: '0x0fd52fd72bca26879474d3e512fb812489111a6654473fd288c6e8ec0432e09d',
    blockHash: '0x138f74df5637315099d31aedf5bf643cf95c2bb7ae923c21fcd7f0075cb55324',
    blockNumber: 1,
    removed: undefined,
    address: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
    data: '0x000000000000000000000000000000000000000000000000000000003b9aca00',
    topics: [
      '0x0ce3610e89a4bb9ec9359763f99110ed52a4abaea0b62028a1637e242ca2768b',
      '0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266'
    ],
    index: 0,
    transactionIndex: 0
  }
]
decodedData Result(1) [ 1000000000n ]
      ✔ Should set the right unlockTime (994ms)
```

Обратите внимание на свойство topics, которое теперь содержит адрес отправителя: `f39fd6e51aad88f6f4ce6ab8827279cfffb92266`.

## Распространенные варианты использования событий

События Solidity имеют несколько распространенных вариантов использования, которые описаны в следующих разделах.

### Уведомления пользователей

События могут использоваться для уведомления пользователей или внешних систем о определенных действиях контракта.

### Журналирование

События в основном используются для регистрации значительных изменений внутри контракта, обеспечивая прозрачную и проверяемую историю происходящего.

### Восстановление исторического состояния

События могут быть ценными для воссоздания исторического состояния контракта. Записывая и анализируя созданные журналы событий, вы можете воссоздать прошлые состояния, предлагая прозрачную и проверяемую историю действий и изменений контракта.

### Отладка и мониторинг

События необходимы для отладки и мониторинга поведения контракта, поскольку они предоставляют способ наблюдения за тем, что происходит в блокчейне.

Возможность использовать события для воссоздания исторических состояний обеспечивает важную функцию аудита и прозрачности, позволяя пользователям и внешним сторонам проверять историю и действия контракта. Хотя это не распространенный вариант использования, это мощная возможность, которая может быть особенно полезной в определенных контекстах.

## События против хранилища смарт-контракта

Хотя возможно полагаться на события для полного воссоздания состояния определенного контракта, есть несколько других вариантов, которые следует рассмотреть.

Существующие сервисы, такие как [The Graph], которые позволяют индексировать и создавать GraphQL-конечные точки для ваших смарт-контрактов и генерировать сущности на основе пользовательской логики. Однако вы должны платить за этот сервис, поскольку добавляете промежуточный слой в свое приложение. Это имеет следующие преимущества:

- возможность просто запрашивать одну конкретную конечную точку для получения всей необходимой информации
- ваши пользователи будут платить меньше комиссий за газ из-за минимизации использования хранилища в вашем контракте

Но хранение всей информации внутри смарт-контракта и полное полагание на него для доступа к данным может создать больше сложностей, поскольку не все данные доступны для прямого запроса. Преимущества этого подхода включают:

- вашему приложению требуется только адрес смарт-контракта для доступа ко всем необходимым данным
- меньше зависимостей, что делает этот подход более крипто-нативным в том смысле, что все находится в блокчейне (но хранение всех данных в блокчейне приведет к более высоким комиссиям за газ)

Как разработчик смарт-контрактов, вы должны оценить, какие варианты лучше всего подходят для вас.

## Заключение

В этом уроке вы изучили основы событий Solidity и их важность в разработке смарт-контрактов Ethereum. Теперь вы понимаете, как объявлять и вызывать события, несколько их распространенных вариантов использования и разницу между событиями и хранилищем смарт-контракта.

Теперь, когда у вас есть твердое понимание событий и их универсальных применений, вы можете использовать их для создания более сложных и интерактивных смарт-контрактов, отвечающих вашим конкретным потребностям, учитывая при этом соображения стоимости.

---

## Смотрите также

[events]: https://docs.soliditylang.org/en/latest/contracts.html#events
[The Graph]: https://thegraph.com/
