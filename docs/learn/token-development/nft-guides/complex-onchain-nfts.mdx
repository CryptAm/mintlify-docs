---
title: 'Сложные ончейн NFT'
slug: /complex-onchain-nfts
description: Руководство, которое учит создавать сложные NFT, процедурно генерируемые с метаданными и изображениями непосредственно в ончейн-среде.
author: briandoyle81

---

# Сложные ончейн NFT

Многие NFT зависят от метаданных и изображений, хранящихся вне цепи (offchain). Некоторые используют неизменяемые места хранения, такие как [IPFS]. Другие используют традиционные веб-локации, и многие из них позволяют владельцу контракта изменять URL, возвращаемый контрактом, когда сайт или пользователь пытается получить доступ к расположению изображения токена и его метаданных. Эта возможность не является плохой по своей сути, потому что мы, вероятно, хотим, чтобы кто-то мог исправить контракт, если место хранения перестанет работать. Однако это вводит требование доверия владельцу контракта.

Хотя это и сложно, можно написать смарт-контракт, который содержит всю необходимую логику и данные для генерации json-метаданных и SVG-изображений полностью в ончейн-среде. Его развертывание будет дорогим, но минт **будет** таким же дешевым, как и у более простых контрактов!

В этом руководстве мы покажем вам, как сделать это, чтобы создать собственный полностью ончейн-арт-проект, аналогичный нашему [sample project].

## Цели

К концу этого руководства вы должны уметь:

- Программно генерировать и возвращать json-метаданные для токенов ERC-721
- Детерминировано конструировать уникальное SVG-изображение в смарт-контракте
- Генерировать детерминированные псевдослучайные числа

## Предварительные требования

### Токены ERC-721

Это руководство предполагает, что вы умеете писать, тестировать и развертывать свои собственные токены ERC-721 на языке программирования Solidity. Если вам нужно сначала изучить это, ознакомьтесь с нашими материалами на [Base Learn] или разделами, посвященными [ERC-721 Tokens]!

### Векторная графика

Вам потребуется некоторое знакомство с форматом векторной графики SVG и базовые навыки редактирования и манипулирования векторной графикой. Если у вас их нет, найдите друга-художника и сотрудничайте!

## Создание графических активов

Для начала вам нужно будет создать несколько векторных графических активов и сделать макет примера того, как может выглядеть ваш NFT. Позже вы разрежете их и отформатируете таким образом, чтобы ваш смарт-контракт мог использовать их для сборки уникальных NFT для каждого минтера.

Макет должен содержать все элементы, которые вы планируете иметь в NFT, и вы должны иметь возможность вручную перемещать элементы или менять цвета, чтобы создать желаемый диапазон вариаций. Например:

- Градиентное небо, цвета в котором рандомизированы
- Одно из трех стилей солнца, всегда в одном и том же месте в правом верхнем углу
- От одного до пяти облаков, случайно расположенных в верхней половине холста
- Широкий горный хребет, который всегда будет посередине, но будет смещаться из стороны в сторону, чтобы показывать разные части для каждого NFT
- Океан на переднем плане, который всегда одинаков

Если вы художник или работаете с ним, вы можете использовать инструмент векторного рисрования по вашему выбору для сборки макета. Если нет, вы можете воспользоваться рядом стоковых изображений или инструментов с AI для помощи. Если вы это сделаете, убедитесь, что понимаете все соответствующие законы или условия обслуживания!

Вы также можете работать с нашим примером: [Sample Art]

В любом случае, у вас должно получиться что-то похожее на это:

![Mockup](/images/onchain-generative-nfts/mockup.png)

## Искусство размещения

Вы заметите, что SVG, вероятно, слишком велик, чтобы поместиться в смарт-контракт. Пример весит 103 КБ, поэтому вам придется проявить изобретательность, чтобы это сработало.

Вы выполните эту задачу, разделив каждый элемент макета и развернув их в отдельных смарт-контрактах. Для этого экспортируйте каждый элемент по отдельности и убедитесь, что экспортированные части не превышают примерно 15 КБ. Таким образом, у вас будет достаточно места, чтобы уместить каждую часть в пределах лимита в 24 КБ для скомпилированного байткода.

Если вы работаете с образцом, у вас получатся отдельные SVG для:

- Sun 1: 9 KB
- Sun 2: 9 KB
- Sun 3: 9 KB
- Ocean: 17 KB
- Mountain: 14 KB
- Cloud: 6 KB
- Sky: 802 bytes

Если у вас нет инструментов для этого, вы можете найти эти файлы здесь: [Sample Art]

## Архитектура контракта

Вам нужно будет создать и развернуть несколько контрактов для этого проекта. Они будут организованы по следующей архитектуре:

![Architecture](/images/onchain-generative-nfts/architecture.png)

Развертывание такого количества контрактов будет сопряжено с определенными затратами, но после их развертывания этот контракт будет стоить столько же, сколько и любой другой NFT-контракт. Помните, что функции `pure` и `view`, вызываемые вне блокчейна, не потребляют газ. Это означает, что вы можете использовать несколько контрактов для сборки относительно большого изображения без дополнительных затрат!

## Создание контрактов

Создайте новый проект, используя инструментарий по вашему выбору, и добавьте контракт с именем `LandSeaSkyNFT`. Импортируйте ERC-721 от OpenZeppelin, унаследуйтесь от него и настройте с конструктором, функцией для минта и счетчиком для отслеживания идентификатора токена:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract LandSeaSkyNFT is ERC721 {
    uint public counter;

    constructor() ERC721("Land, Sea, and Sky", "LSS") {}

    function mint() public {
        counter++;
        _safeMint(msg.sender, counter);
    }
}
```

### Переопределение функции `_baseURI()`

Обычно вы переопределяете `_baseURI()` базовым URL для выбранного вами места хранения метаданных NFT. Это может быть веб-сайт, папка IPFS или множество других возможных мест.

Поскольку этот контракт будет генерировать .json файл напрямую, вместо этого установите его так, чтобы сообщить об этом браузеру:

```solidity
function _baseURI() internal pure override returns (string memory) {
  return "data:application/json;base64,";
}
```

### Импорт библиотеки Base64

Как указано выше, вы будете возвращать метаданные json в формате [Base64]. OpenZeppelin есть утилитный контракт для этого. Вам также понадобится библиотека Strings. Импортируйте их:

```solidity
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
```

<Info>
Base64 позволяет надежно передавать двоичные данные через веб. Это не алгоритм сжатия, и фактически он увеличивает размер данных в соотношении 4/3.
</Info>

### Планирование переопределения функции `tokenURI()`

Затем настройте переопределение функции `tokenURI`. Вам нужно будет написать несколько других контрактов, чтобы это заработало, но вы можете написать большую часть кода и набросать план для остального, чтобы:

- Проверить и убедиться, что идентификатор токена существует
- Скомпилировать json-метаданные для токена, включая:
  - `"name"` NFT
  - `"description"`
  - `"image"`
- Закодировать вышеуказанное в Base64, объединить с `_baseURI` и вернуть.

```solidity
function tokenURI(uint _tokenId) public view override returns (string memory) {
  if(_tokenId > counter) {
    revert InvalidTokenId(_tokenId); // Не забудьте добавить ошибку выше!
  }

  string memory json = Base64.encode(
    bytes(
      string(
        abi.encodePacked(
          '{"name": "Land, Sea, and Sky #: ',
          Strings.toString(_tokenId),
          '", "description": "Land, Sea, and Sky is a collection of generative art pieces stored entirely onchain.", "image": "data:image/SVG+xml;base64,',
          "TODO: Build the SVG with the token ID as the seed",
          '"}'
        )
      )
    )
  );

  return string(abi.encodePacked(_baseURI(), json));
}
```

<Caution>
Соблюдение правильной расстановки кавычек и запятых, когда json разбит таким образом, является сложной задачей. При отладке смотрите сюда в первую очередь!
</Caution>

### Проверьте свой прогресс

Протестируйте свою функцию, написав простой тест для минта NFT, затем вызовите и выведите в лог результат функции `tokenURI`. Вы должны получить что-то похожее на:

```text
string: data:application/json;base64,eyJuYW1lIjogIkxhbmQsIFNlYSwgYW5kIFNreSAjMSIsICJkZXNjcmlwdGlvbiI6ICJMYW5kLCBTZWEsIGFuZCBTa3kgaXMgYSBjb2xsZWN0aW9uIG9mIGdlbmVyYXRpdmUgYXJ0IHBpZWNlcyBzdG9yZWQgZW50aXJlbHkgb25jaGFpbi4iLCAiaW1hZ2UiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxUT0RPOiBCdWlsZCB0aGUgU1ZHIHdpdGggdGhlIHRva2VuIElEIGFzIHRoZSBzZWVkIn0=
```

Чтобы проверить, сработало ли, вам нужно вручную декодировать данные base64; всё, что после запятой:

```text
eyJuYW1lIjogIkxhbmQsIFNlYSwgYW5kIFNreSAjMSIsICJkZXNjcmlwdGlvbiI6ICJMYW5kLCBTZWEsIGFuZCBTa3kgaXMgYSBjb2xsZWN0aW9uIG9mIGdlbmVyYXRpdmUgYXJ0IHBpZWNlcyBzdG9yZWQgZW50aXJlbHkgb25jaGFpbi4iLCAiaW1hZ2UiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxUT0RPOiBCdWlsZCB0aGUgU1ZHIHdpdGggdGhlIHRva2VuIElEIGFzIHRoZSBzZWVkIn0=
```

Вы можете использовать терминал: `echo -n '<string to decode>' | base64 --decode`

Сделайте это, и вы получите:

```text
{"name": "Land, Sea, and Sky #: 1", "description": "Land, Sea, and Sky is a collection of generative art pieces stored entirely onchain.", "image": "data:image/SVG+xml;base64,TODO: Build the SVG with the token ID as the seed"}
```

## Создание SVG

Далее вам нужно создать логику для компиляции реального рабочего SVG из сохраненных частей. Вам также нужно будет добавить некоторые вариации на основе идентификатора NFT.

### Контракт для рендеринга SVG

Добавьте новый файл и контракт с именем `SVGRenderer`. Ему не нужен конструктор, но понадобится библиотека `Strings`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract SVGRenderer {

}
```

Откройте пример SVG в редакторе кода и, используя его как образец, создайте функцию, которая использует `abi.encodePacked` для сборки всего в SVG кроме самого изображения. Оно слишком велико для одного контракта, поэтому вместо этого добавьте заглушки.

В зависимости от инструмента, который вы использовали для создания SVG, в этих строках могут быть ненужные дополнительные элементы, которые можно удалить. Также вам не нужны элементы в `<defs>` или `<styles>`. Вы воспользуетесь гибкостью формата, чтобы включить их в части, возвращаемые вспомогательным контрактом.

```solidity
function render(uint _tokenId) public view returns (string memory) {
  return string(
    abi.encodePacked(
      "<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>",
      // TODO: Добавить облака,
      // TODO: Добавить солнце,
      // TODO: Добавить сушу,
      // TODO: Добавить море,
      // TODO: Добавить фон,
      "</SVG>"
    )
  );
}
```

### Рендеринг моря

Элемент моря в этом NFT будет одинаковым для всех NFT, поэтому логично сначала написать этот контракт. Создайте его с именем `SeaRenderer` с функцией `render`. Элемент `<g>` является корневым для разных частей SVG, поэтому добавьте его и заглушку для остального.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract SeaRenderer {
  function render() public pure returns (string memory) {
    return // TODO: Отрендерить море
  }
}
```

Следующая часть сложна и немного громоздка. Вам нужно будет объединить части индивидуально экспортированного SVG, который содержит изображение моря и все его свойства, с данными о позиции этой части изображения из примера SVG. Затем вам нужно будет свести его к одной строке и добавить в качестве строковой константы.

Начните с открытия SVG океана. Измените viewBox на `viewBox="0 0 1024 1024"`. Переместите теги `<defs>` и `<scripts>` внутрь тега `<g>`. Откройте SVG в браузере, чтобы убедиться, что он не сломался.

Далее удалите `id` и `data-name` из корневого `<g>` и поэкспериментируйте со свойством `transform="translate(20,2.5)"`, чтобы вернуть изображение вниз вьюпорта.

С примером графики, `<g transform="translate(0,700)">` должно сработать.

Последние правки, которые вам нужно сделать, критически важны - выполните поиск и замену, чтобы изменить все имена классов `cls-1` и подобные на `cls-land-1`! В противном случае классы будут переопределять друг друга, и ни один цвет не будет правильным. Также найдите все экземпляры `linear-gradient` и сделайте то же самое.

**Убедитесь**, что вы меняете и определения, и места их использования!

Наконец, используйте инструмент по вашему выбору, чтобы минифицировать **только** самый внешний тег `<g>` и его содержимое. Это преобразует код в одну строку и удалит лишние пустые символы. Это облегчает добавление в ваш контракт и уменьшает объем данных. Добавьте его в качестве строковой константы в `SeaRenderer.sol`:

```solidity
string constant SVG = '<g transform="translate(0,700)"<way more code></g>';
```

Возможно, вам потребуется выполнить поиск и замену и убедиться, что вы используете только один тип кавычек в SVG.

Замените ваш `TODO` на константу.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

string constant SVG = <A very long string!>;

contract SeaRenderer {
  function render() public pure returns (string memory) {
    return SVG;
  }
}
```

Протестируйте эту функцию отдельно и убедитесь, что если вы вставите содержимое внутри тегов `<SVG>`, оно отображается как ожидалось!

### Вызов SeaRenderer

Вернитесь к `SVGRenderer.sol`. Добавьте `interface` для `SeaRenderer`. Все ваши контракты для рендеринга будут иметь функцию `render`, которая либо принимает `uint _tokenId`, либо не принимает аргументов, и возвращает строку. Из-за этого вы можете использовать единый интерфейс для всех контрактов рендеринга:

```solidity
interface ISVGPartRenderer {
  function render() external pure returns (string memory);
  function render(uint _tokenId) external pure returns (string memory);
}
```

Добавьте экземпляр внутри контракта `SVGRenderer` для `SeaRenderer` и конструктор, который принимает адрес для `SeaRenderer`:

```solidity
constructor(address _seaRenderer) {
  seaRenderer = ISVGPartRenderer(_seaRenderer);
}
```

Замените `// TODO: Добавить море`, вызовом вашей внешней функции.

```solidity
function render(uint _tokenId) public view returns (string memory) {
  return string(
    abi.encodePacked(
      "<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>",
      // TODO: Добавить облака,
      // TODO: Добавить солнце,
      // TODO: Добавить сушу,
      seaRenderer.render(),
      // TODO: Добавить фон,
      "</SVG>"
    )
  );
}
```

## Завершение первого прохода

Вернитесь к контракту `LandSeaSkyNFT` и добавьте `interface` для `SVGRenderer`.

```solidity
interface ISVGRenderer {
  function render(uint _tokenId) external view returns (string memory);
}
```

Добавьте его экземпляр и обновите `constructor`, чтобы установить его:

```
ISVGRenderer SVGRenderer;

constructor(address _SVGRenderer) ERC721("Land, Sea, and Sky", "LSS") {
  SVGRenderer = ISVGRenderer(_SVGRenderer);
}
```

<Info>
Для целей тестирования может быть удобнее, если вы добавите функции, позволяющие изменять эти адреса после развертывания. Но весь смысл этой работы — создание неизменяемых ончейн-NFT, поэтому не забудьте удалить их перед реальным развертыванием!
</Info>

Наконец, замените ваш `TODO` строкой для `Base64.encode` вызова рендерера:

```solidity
string memory json = Base64.encode(
  bytes(
    string(
      abi.encodePacked(
        '{"name": "Land, Sea, and Sky #: ',
        Strings.toString(tokenId),
        '", "description": "Land, Sea, and Sky is a collection of generative art pieces stored entirely onchain.", "image": "data:image/SVG+xml;base64,',
        Base64.encode(bytes(SVGRenderer.render(tokenId))),
        '"}'
      )
    )
  )
);
```

### Тестовое развертывание

Сейчас хорошее время для развертывания в тестовой сети, чтобы проверить, работает ли этот первый проход, как ожидалось. Если вы используете [Hardhat and Hardhat Deploy], вы можете использовать этот скрипт:

```tsx
import { HardhatRuntimeEnvironment } from 'hardhat/types';
import { DeployFunction } from 'hardhat-deploy/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const { deployments, getNamedAccounts } = hre;
  const { deploy } = deployments;
  const { deployer } = await getNamedAccounts();

  const SeaRenderer = await deploy('SeaRenderer', {
    from: deployer,
  });

  const SVGRenderer = await deploy('SVGRenderer', {
    from: deployer,
    args: [SeaRenderer.address],
  });

  const LandSeaSkyNFT = await deploy('LandSeaSkyNFT', {
    from: deployer,
    args: [SVGRenderer.address],
  });

  await hre.run('verify:verify', {
    address: LandSeaSkyNFT.address,
    constructorArguments: [SVGRenderer.address],
    contract: 'contracts/LandSeaSkyNFT.sol:LandSeaSkyNFT',
  });
};
export default func;
```

Разверните контракты в Base Sepolia и верифицируйте их, или по крайней мере верифицируйте `LandSeaSkyNFT` (приведенный выше скрипт сделает это).

Откройте контракт в [Basescan], подключите ваш кошелек и создайте несколько NFT.

**Подождите несколько минут**, затем откройте [testnet version of Opensea] и найдите ваш контракт. Это может занять несколько минут, но когда это произойдет, и если все работает, вы увидите NFT с частью изображения океана! Отлично!

![First pass NFT](/images/onchain-generative-nfts/first_pass.png)

## Добавление рендерера неба

Отличная работа! Большая часть самой сложной работы сделана. Теперь вам нужно просто добавить рендерер для каждого из остальных элементов, с той особенностью, что вы будете делать кастомизацию внутри самих SVG. Вам придется немного повозиться!

### Подготовка SVG

Откройте SVG неба и в редакторе, и в браузере. Как и с морем, первый шаг - изменить вьюпорт на 1024x1024, переместить элементы `<defs>` и `<style>` внутрь корневого `<g>` и трансформировать/переместить эту группу в правильное место (0,0 сработает!).

Измените `cls-1` на `cls-sky-1` как в определении, так и там, где он используется. Добавьте `sky` в `linear-gradient` тоже.

Также удалите данные информации о слое для этой группы. В итоге получится:

```html
<svg xmlns="http://www.w3.org/2000/SVG" viewBox="0 0 1024 1024">
  <g transform="translate(0,0)">
    <defs>
      <style>
        cls-sky-1 {
          fill: url(#linear-gradient-sky);
          stroke-width: 0px;
        }
      </style>
      <linearGradient
        id="linear-gradient-sky"
        x1="511.76"
        y1="10.19"
        x2="512.24"
        y2="865.99"
        gradientTransform="translate(63.89) scale(.88)"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset=".12" stop-color="#c391b4" />
        <stop offset=".34" stop-color="#ce9f9b" />
        <stop offset=".68" stop-color="#dfd061" />
        <stop offset=".96" stop-color="#e3f9f7" />
      </linearGradient>
    </defs>
    <path class="cls-sky-1" d="M1024,0v768.9H0V0h1024Z" />
  </g>
</svg>
```

У вас есть несколько вариантов дизайна. Вы могли бы использовать детерминировано выбранные, но по сути случайные цвета для создания градиента. Однако это приведет к тому, что подавляющее большинство NFT будут иметь поистине причудливые цвета, которые не выглядят приятно и не гармонируют с остальным изображением.

Никто не хочет, чтобы его небо было смесью бирюзового, темно-синего, бордового и коричневого!

Возможно, лучше добавить небольшое изменение к существующим цветам градиента и их диапазону. Начните с минификации корневой группы `<g>` и ее содержимого, затем создайте **две** константные строки: одну для всего, что находится до первого элемента `<stop>`, и одну для всего, что после последнего элемента `<stop>`.

Ни одна из строк не должна содержать `<stop>` элементы. Вы создадите их далее.

### Создание контракта для рендеринга

Добавьте новый файл и контракт с именем `SkyRenderer`. Добавьте ваши строки:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

string constant START = '<g transform="translate(0,0)"> <defs> <style>.cls-sky-1{fill: url(#linear-gradient-sky); stroke-width: 0px;}</style> <linearGradient id="linear-gradient-sky" x1="511.76" y1="10.19" x2="512.24" y2="865.99" gradientTransform="translate(63.89) scale(.88)" gradientUnits="userSpaceOnUse">';
string constant END = '</linearGradient> </defs> <path class="cls-sky-1" d="M1024,0v768.9H0V0h1024Z"/> </g>';

contract SkyRenderer {
  function render(uint _tokenId) public pure returns (string memory) {
    return //TODO;
  }
}
```

Далее добавьте константы для существующих свойств `offset` и `stop-color`:

```solidity
string constant OFFSET1 = ".12";
string constant OFFSET2 = ".34";
string constant OFFSET3 = ".68";
string constant OFFSET4 = ".96";
string constant COLOR1 = "#c391b4";
string constant COLOR2 = "#ce9f9b";
string constant COLOR3 = "#dfd061";
string constant COLOR4 = "#e3f9f7";
```

Теперь создайте заглушку для возвращаемого значения функции `render`. Она будет использовать встроенный метод `abi.encode` и приведение к `string` для объединения всех частей и их возврата.

```solidity
function render(uint _tokenId) public pure returns (string memory) {
  return string(
    abi.encodePacked(
      START,
      // TODO stop 1,
      // TODO stop 2,
      // TODO stop 3,
      // TODO stop 4,
      END
    )
  );
}
```

Сделайте то же самое для функции `buildStop`:

```solidity
function _buildStop(
    string memory _offset,
    string memory _color,
    uint _tokenId,
    uint _stopNumber
    ) internal pure returns (string memory) {
    return string(
      abi.encodePacked(
        '<stop offset="',
        // TODO tweaked offset,
        '" stop-color="',
        _color,
        '"/>'
      )
    );
  }
```

Теперь вам просто нужно разобраться, как изменить свойства на основе `_tokenId`. Это должно быть «случайным» в том смысле, что каждый NFT должен быть разным, но оно должно быть детерминированным, чтобы вы получали одно и то же изображение каждый раз при его загрузке.

Сначала **вычтите 10** из значений и преобразуйте их в `uint` без десятичных знаков в каждой из ваших констант для стопов, и уменьшите последнюю до `80`:

```solidity
uint constant OFFSET1 = 2;
uint constant OFFSET2 = 24;
uint constant OFFSET3 = 58;
uint constant OFFSET4 = 80;
```

Вам также нужно будет обновить параметр в `_buildStop`.

Добавьте функцию `_buildOffsetValue`. Она будет выбирать целое число от 0 до 20 для каждого смещения и добавлять его к только что созданным модифицированным смещениям. В результате получится изменение +-10 для каждого значения (последнее будет немного другим, чтобы оставаться в диапазоне):

```solidity
function _buildOffsetValue(
    uint _offset,
    uint _tokenId,
    uint _stopNumber
  ) internal pure returns (string memory) {
  bytes32 hash = keccak256(abi.encodePacked(_offset, _tokenId, _stopNumber));
  uint rand = uint(hash);
  uint change = rand % 20; // Генерирует число от 0 до 19
  if(change >= 10) {
    return string(
      abi.encodePacked(
        '.',
        Strings.toString(_offset + change)
      )
    );
  } else {
      return string(
      abi.encodePacked(
        '.',
        '0', // 9 это .09, а не .9
        Strings.toString(_offset + change)
      )
    );
  }
}
```

Эта функция использует хэширование для создания псевдослучайного числа с использованием идентификатора токена и номера стопа в качестве сидов, гарантируя постоянное значение, уникальное для каждого токена и каждого стопа внутри этого токена. Она использует то, как интерпретируется свойство offset - в данном случае `".12+.20" == ".32"`.

Наконец, обновите вашу функцию `render`, чтобы она вызывала `_buildStop`:

```solidity
function render(uint _tokenId) public pure returns (string memory) {
  return string(
    abi.encodePacked(
      START,
      _buildStop(OFFSET1, COLOR1, _tokenId, 1),
      _buildStop(OFFSET2, COLOR2, _tokenId, 2),
      _buildStop(OFFSET3, COLOR3, _tokenId, 3),
      _buildStop(OFFSET4, COLOR4, _tokenId, 4),
      END
    )
  );
}
```

### Интеграция SkyRenderer

Вернитесь к `SVGRenderer.sol` и добавьте экземпляр `ISVGPartRenderer` для `skyRenderer`. Добавьте аргумент в `constructor` и инициализируйте его, затем вызовите функцию `render` вместо вашего `TODO` для фона.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

interface ISVGPartRenderer {
  function render() external pure returns (string memory);
  function render(uint _tokenId) external pure returns (string memory);
}

contract SVGRenderer {

  ISVGPartRenderer seaRenderer;
  ISVGPartRenderer skyRenderer;

  constructor(address _seaRenderer, address _skyRenderer) {
    seaRenderer = ISVGPartRenderer(_seaRenderer);
    skyRenderer = ISVGPartRenderer(_skyRenderer);
  }

  function render(uint _tokenId) public view returns (string memory) {
    return string(
      abi.encodePacked(
        "<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>",
        // TODO: Добавить облака,
        // TODO: Добавить солнце,
        // TODO: Добавить сушу,
        skyRenderer.render(_tokenId),
        seaRenderer.render(),
        "</SVG>"
      )
    );
  }
}
```

Обновите скрипт развертывания, затем разверните и протестируйте, как и раньше.

```tsx
const SkyRenderer = await deploy('SkyRenderer', {
  from: deployer,
});

const SVGRenderer = await deploy('SVGRenderer', {
  from: deployer,
  args: [SeaRenderer.address, SkyRenderer.address],
});
```

Протестируйте, как и раньше. Ваши NFT теперь имеют небо!

## Добавление LandRenderer

Следующей частью SVG являются горы. Для этого вы будете изменять горизонтальное смещение слева направо, чтобы показывать разные части гор для каждого NFT.

### Подготовка SVG

Откройте SVG гор в браузере и редакторе. Снова установите `viewBox` в 1024x1024 и переместите `<defs>` и `<styles>` внутрь корневой группы (`<g>`).

Найдите значения transform/translate, которые сначала помещают горы вниз, показывая самую левую часть, а затем самую правую. `transform="translate(-150,350)"` и `transform="translate(-800,350)"` примерно подходят.

Не забудьте добавить `-land` к именам классов!

### Написание контракта

Добавьте файл и заглушку для `LandRenderer`:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract LandRenderer {
  function render(uint _tokenId) public pure returns (string memory) {
    return string(
      abi.encodePacked(
        '<g transform="translate(',
        // TODO,
        ',300)">',
        END
      )
    );
  }
}
```

Минифицируйте корневой элемент `<g>` и добавьте константу со всем, что после открывающего тега `<g>`. Используйте методы, аналогичные предыдущим, чтобы сгенерировать смещение на основе идентификатора токена, затем создайте SVG. У вас должно получиться что-то вроде этого:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

string constant END = "<long SVG string>";

contract LandRenderer {
  function render(uint _tokenId) public pure returns (string memory) {
    return string(
      abi.encodePacked(
        '<g transform="translate(',
        _buildOffset(_tokenId),
        ',300)">',
        END
      )
    );
  }

  function _buildOffset(uint _tokenId) internal pure returns (string memory) {
    bytes32 hash = keccak256(abi.encodePacked(_tokenId));
    uint rand = uint(hash);
    uint xOffset = (rand % 650) + 150; // Генерирует число от 150 до 799
    return string(abi.encodePacked("-", Strings.toString(xOffset)));
  }
}
```

### Интеграция LandRenderer

Обновите `SVGRenderer`:

```solidity
ISVGPartRenderer seaRenderer;
ISVGPartRenderer skyRenderer;
ISVGPartRenderer landRenderer;

constructor(address _seaRenderer, address _skyRenderer, address _landRenderer) {
  seaRenderer = ISVGPartRenderer(_seaRenderer);
  skyRenderer = ISVGPartRenderer(_skyRenderer);
  landRenderer = ISVGPartRenderer(_landRenderer);
}

function render(uint _tokenId) public view returns (string memory) {
  return string(
    abi.encodePacked(
      "<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>",
      skyRenderer.render(_tokenId),
      landRenderer.render(_tokenId),
      seaRenderer.render(),
      "</SVG>"
    )
  );
}
```

И скрипт развертывания:

```tsx
const LandRenderer = await deploy('LandRenderer', {
  from: deployer,
});

const SVGRenderer = await deploy('SVGRenderer', {
  from: deployer,
  args: [SeaRenderer.address, SkyRenderer.address, LandRenderer.address],
});
```

Протестируйте, как и раньше. Начинает выглядеть очень хорошо!

![Progress](/images/onchain-generative-nfts/progress.png)

## Добавление SunRenderer

Рендерер солнца будет использовать методы, похожие на те, которые вы уже применили. Солнце будет находиться в одном и том же месте для всех NFT. Вариативность будет заключаться в том, что каждое NFT будет показывать только одно из трех солнц, представленных в файле примера графики.

### Подготовка SVG

Для каждого из трех SVG солнца:

- Измените `viewBox` на 1024x1024
- Переместите `<defs>` и `<styles>` в первую группу
- Найдите правильный перевод, чтобы поместить солнце в правый верхний угол
  - 750, 100 должно сработать с примером графики
- Добавьте `-sun` к именам классов

### Написание контрактов

Сложность здесь в том, что вы не можете поместить все солнца в один контракт. Они слишком большие! Вместо этого разделите их на три отдельных, аналогично исходному рендереру океана. Например:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "hardhat/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

string constant SVG = '<long SVG>'

contract SunRenderer1 {
  function render() public pure returns (string memory) {
    return SVG;
  }
}
```

### Интеграция SunRenderer

Добавьте три `SunRenderer`, как вы это делали с другими контрактами рендеринга. Вам придется интегрировать этот немного иначе. Добавьте функцию, которая выбирает, какой `SunRenderer` вызывать, на основе идентификатора NFT.

```solidity
function pickSunRenderer(uint _tokenId) public view returns (ISVGPartRenderer) {
    bytes32 hash = keccak256(abi.encodePacked(_tokenId));
    uint rand = uint(hash);
    uint sun = rand % 3;
    if(sun == 0) {
      return sunRenderer1;
    } else if(sun == 1) {
      return sunRenderer2;
    } else {
      return sunRenderer3;
    }
  }
```

Убедитесь, что поместили его после `skyRenderer` в основной функции `render`!

```solidity
function render(uint _tokenId) public view returns (string memory) {
  return string(
    abi.encodePacked(
      "<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>",
      skyRenderer.render(_tokenId),
      pickSunRenderer(_tokenId).render(),
      landRenderer.render(_tokenId),
      seaRenderer.render(),
      "</SVG>"
    )
  );
}
```

Протестируйте. Теперь у каждого NFT в небе одно из трех солнц!

## Добавление CloudRenderer

Самостоятельно попробуйте добавить облака. Рендерер облаков должен:

- Случайно выбирать от одного до семи облаков
- Размещать эти облака случайным образом в верхней половине холста
- Находиться на слое выше солнца и неба, но ниже моря и гор

## Заключение

В этом руководстве вы узнали, как использовать тот факт, что вызовы вашего смарт-контракта извне цепи не используют газ, чтобы создать достаточно сложную систему для рендеринга замысловатых и уникальных NFT, метаданные и изображения которых существуют полностью в ончейн-среде. Вы также изучили некоторые техники создания детерминированных псевдослучайных чисел и их использования для добавления вариативности в ваше изображение. Вы разобрались со многими оговорками и особенностями программного объединения SVG-файлов. Наконец, вы попрактиковались в создании нескольких взаимодействующих контрактов.

[Base Learn]: https://base.org/learn
[ERC-721 Tokens]: https://docs.base.org/learn/erc-721-token/erc-721-standard-video
[IPFS]: https://ipfs.tech/
[Base64]: https://en.wikipedia.org/wiki/Base64
[Hardhat and Hardhat Deploy]: https://docs.base.org/learn/hardhat-deploy/hardhat-deploy-sbs
[testnet version of Opensea]: https://testnets.opensea.io/
[sample project]: https://github.com/base-org/land-sea-and-sky
[Sample Art]: https://github.com/base-org/land-sea-and-sky/tree/master/Final_SVGs
[Basescan]: https://sepolia.basescan.org/

