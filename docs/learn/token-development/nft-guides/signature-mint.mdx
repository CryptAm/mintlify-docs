---
title: 'NFT с минтом по подписи (Signature Mint)'
slug: /signature-mint-nft
description: Руководство, которое учит создавать минт по подписи, в котором минтеры платят свой собственный газ, но сначала должны получить действительное подписанное разрешение.
author: briandoyle81

---

# NFT с минтом по подписи (Signature Mint)
_Минт по подписи (signature mint)_ - это термин для создания NFT, при котором получатель NFT платит свой собственный газ за получение NFT, но может сделать это только в том случае, если у него есть корректное сообщение, подписанное владельцем или авторизованным адресом контракта минта. Причины для этого включают возможность оплаты комиссий за минт фиатными деньгами, возможность держателям NFT в одной цепочке создать этот NFT в несвязанной цепочке или ограничение доступа к минту для пользователей, которые соответствуют другим конкретным оффчейн-требованиям.

Минты по подписи не являются особенно сложными, но их реализация остается трудной. Поскольку они используют как хэширование, так и криптографию, не существует частично-правильных состояний - либо все абсолютно верно, и минт работает, либо **что-то** не так **где-то**, и он не работает.

В сочетании с быстрыми изменениями в Solidity, библиотечных контрактах и фронтенд-библиотеках, устранение ошибок становится особенно трудным.

## Цели

К концу этого руководства вы должны уметь:

- Криптографически подписывать сообщение с помощью кошелька
- Проверять подписанное сообщение в смарт-контракте
- Реализовывать минт ERC-721 по подписи

## Предварительные требования

### Токены ERC-721

Это руководство предполагает, что вы умеете писать, тестировать и развертывать свои собственные токены ERC-721 на языке программирования Solidity. Если вам нужно сначала изучить это, ознакомьтесь с нашими материалами на [Base Learn] или разделами, посвященными [ERC-721 Tokens]!

### Vercel

Вам нужно уметь развертывать ваше приложение на [Vercel], или использовать другое решение самостоятельно. Ознакомьтесь с нашим руководством по [deploying with Vercel] если вам нужна помощь!

## Создание контракта

Начните с настройки контракта [OpenZeppelin ERC-721]. Настройте переменные и используйте конструктор для назначения:

- Имя коллекции
- Символ коллекции
- Описание
- IPFS-хэш для изображения NFT (предполагая одинаковое изображение для каждого NFT)
- Счетчик для отслеживания следующего идентификатора NFT

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SoulboundSignatureMint is ERC721, Ownable {
    string public nameString;
    string public description;
    string public tokenArtIPFSId;
    uint public counter;

    constructor(
      string memory _nameString,
      string memory _symbol,
      string memory _tokenArtIPFSId,
      string memory _description
      ) ERC721(_nameString, _symbol) Ownable(msg.sender) {
      nameString = _nameString;
      description = _description;
      tokenArtIPFSId = _tokenArtIPFSId;
    }
}
```

Вы также используете `Ownable`, чтобы назначить владельца этого контракта. Вместо этого можно просто сохранить адрес авторизованного подписывающего лица, если вы не собираетесь добавлять функциональность, доступную только владельцу.

### Публичная функция минта

Для `public` функции минта создайте функцию `mintTo`, которая принимает `address` для `_recipient`.

<Info>
Распространенной практикой было просто создавать токен и отдавать его `msg.sender`. Эта практика выходит из моды. Разрешение получателю отличаться от отправителя дает большую гибкость. Это также необходимо для назначения правильного владельца NFT в случае, если пользователь использует смарт-контракт кошелек, paymaster или другую форму абстракции аккаунта.
</Info>

```solidity
function mintTo(address _recipient, bytes memory _signature) public {
  counter++;
  _safeMint(msg.sender, counter);
}
```

### Ончейн-метаданные

Вместо указания на файл `json` в традиционном интернете, вы можете поместить ваши метаданные непосредственно в контракт. Для этого сначала импортируйте вспомогательные библиотеки:

```solidity
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
```

Затем переопределите функции для `_baseURI` и `tokenURI`, чтобы возвращать метаданные в формате `json`, закодированные в base64, с информацией, предоставленной в конструкторе:

```solidity
function _baseURI() internal pure override returns (string memory) {
  return "data:application/json;base64,";
}

function tokenURI(uint _tokenId) public view override returns (string memory) {
  if(_tokenId > counter) {
    revert InvalidTokenId(_tokenId);
  }

  string memory json = Base64.encode(
    bytes(
      string(
        abi.encodePacked(
          '{"name": "',
          nameString,
          ' #: ',
          Strings.toString(_tokenId),
          '","description": "',
          description,
          '", "image": "ipfs://',
          tokenArtIPFSId,
          '"}'
        )
      )
    )
  );

  return string(abi.encodePacked(_baseURI(), json));
}
```

**Будьте очень внимательны** при настройке одинарных и двойных кавычек выше и обязательно протестируйте эту функцию, чтобы убедиться, что результат представляет собой корректные метаданные json. Ошибка здесь сломает NFT, и он не будет правильно отображаться в кошельках или на торговых площадках!

### Предотвращение переводов

_Soulbound_ - это термин из видеоигр, означающий, что предмет навсегда прикреплен к получателю - его **нельзя** передать. Вам решать, соответствует ли это ограничение вашим целям дизайна. Мы часто его используем, потому что наши NFT предназначены быть забавными сувенирами или маркерами личных достижений, а не чем-то, что когда-либо будет иметь денежную стоимость. Предотвращение торговли уменьшает спекуляции и фарминг на том, что мы сделали для развлечения!

Чтобы предотвратить переводы, кроме первоначального минта, вы можете `override` функцию `_update`.

<Info>
Ранее это делалось с помощью функции `_beforeTransfer`. Текущие версии реализации ERC-721 от OpenZeppelin заменили эту функцию на `_update`.
</Info>

```solidity
/**
  * Запретить переводы (Soulbound NFT)
  */
/**
  * @dev Внутренняя функция для обработки переводов токенов.
  * Ограничивает перевод Soulbound токенов.
  */
function _update(address to, uint256 tokenId, address auth)
    internal
    override(ERC721)
    returns (address)
{
    address from = _ownerOf(tokenId);
    if (from != address(0) && to != address(0)) {
        revert SoulboundToken();
    }

    return super._update(to, tokenId, auth);
}
```

### Развертывание и тестирование

Прежде чем погрузиться в сложности проверки криптографической подписи, стоит проверить ваш контракт и убедиться, что он работает, как ожидается. Вам нужно будет закрепить изображение в IPFS и получить хэш для использования в ваших метаданных. Вы можете использовать такой сервис, как [Pinata] для помощи в этом.

### Добавление проверки подписи

Чтобы проверить подпись, которую вы позже создадите в вашем бэкенде, вы будете использовать пару криптографических утилит от OpenZeppelin:

```solidity
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
```

```solidity
using ECDSA for bytes32;
using MessageHashUtils for bytes32;
```

Эти утилиты абстрагируют большую часть сложностей, связанных с работой с сообщениями, соответствующими спецификациям [ERC-191] и [EIP-712]. Важно, что они работают с форматом сообщения, который добавляет префикс `"\x19Ethereum Signed Message:\n32"` к сообщению. Вы **обязаны** делать то же самое при создании подписанного сообщения!

Добавьте функцию `validateSignature`:

```solidity
function validateSignature(address _recipient, bytes memory _signature) public view returns (bool) {
  bytes32 messageHash = keccak256(abi.encodePacked(_recipient));
  bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
  address signer = ethSignedMessageHash.recover(_signature);

  return signer == owner();
}
```

Способ проверки немного непонятен, особенно учитывая, что вы еще не создали `_signature`. Функция имеет два входа:

- Сообщение или переменные в подписанном сообщении
  - Здесь это `address` `_recipient`
  - `_signature`, или подписанное сообщение, предоставленное пользователем, утверждающим, что ему разрешено создать NFT

Во-первых, функция воссоздает хэш данных, которые должны быть подписаны. Если бы вы включали другие переменные, вы бы также включили их сюда. Далее `messageHash.toEthSignedMessageHash` добавляет байтовое представление `"\x19Ethereum Signed Message:\n32"` к сообщению, а затем хэширует результат.

Наконец, вызов `recover` с `ethSignedMessageHash` и `_signature` пытается восстановить подписавший `address` из `_signature`, используя **независимо сконструированные** данные сообщения.

Если восстановленный адрес совпадает с ожидаемым адресом, в данном случае владельцем контракта, то предоставленная `_signature` действительна. Если адреса не совпадают, то `_signature` недействительна.

Обновите вашу функцию `mintTo`, чтобы использовать проверку:

```solidity
function mintTo(address _recipient, bytes memory _signature) public {
  if(!validateSignature(_recipient, _signature)) {
    revert InvalidSignature();
  }

  counter++;
  _safeMint(msg.sender, counter);
}
```

<Danger>
Ничто в вышеуказанном методе проверки не предотвращает возможность пользователя или третьей стороны получить действительное подписанное сообщение из предыдущей транзакции и повторно использовать его для **новой** транзакции. В данном случае это не имеет значения, потому что повторное использование подписи позволило бы только создать больше soulbound NFT для адреса внутри подписи.

Другие требования к дизайну должны использовать nonce как часть подписанных данных, чтобы предотвратить повторное использование подписи.
</Danger>

## Подписание сообщения

Если вы используете [Hardhat] c [viem], вы можете написать тесты, чтобы проверить, что механизмы подписания и проверки работают. В противном случае в этом нет смысла, поскольку успех зависит от точного и специфического способа и порядка подписания. Если вы используете другой инструментарий для написания смарт-контрактов, продолжайте в вашем бэкенде напрямую.

Если вы используете другую библиотеку, вам нужно будет провести исследование, чтобы выяснить, как **точно** воспроизвести шаги, описанные ниже.

### Настройка теста

Добавьте новый файл теста и заполните каркас для развертывания вашего контракта и запуска теста:

```tsx
import { loadFixture } from '@nomicfoundation/hardhat-toolbox-viem/network-helpers';
import { expect } from 'chai';
import hre from 'hardhat';

describe('Test', function () {
  // Определяем фикстуру для повторного использования одной и той же настройки в каждом тесте.
  // Используем loadFixture для запуска этой настройки один раз, создания снапшота этого состояния,
  // и сброса Hardhat Network к этому снапшоту в каждом тесте.
  async function deploySignatureFixture() {
    // Контракты развертываются с использованием первого подписывающего/аккаунта по умолчанию
    const [owner, signer0, signer1] = await hre.viem.getWalletClients();

    const soulboundSignatureMint = await hre.viem.deployContract('SoulboundSignatureMint', [
      'Cool NFT Name', // Имя
      'CNFT', // Symbol
      'QmRsQCyTEALYnHvBupFcs2ofzeeswEEEGN...', // IPFS Hash
      'This is a cool NFT!', // Описание
    ]);

    const publicClient = await hre.viem.getPublicClient();

    return {
      soulboundSignatureMint,
      owner,
      signer1,
      publicClient,
    };
  }

  describe('Mint', function () {
    it('Should validate the signed message', async function () {
      const { soulboundSignatureMint, owner, signer0, signer1 } = await loadFixture(
        deploySignatureFixture,
      );

      const ownerAddress = await owner.account.address;
      const signer1Address = await signer1.account.address;

      // TODO...

      // Signer 1 вызывает функцию mintTo с подписью
      expect(await soulboundSignatureMint.write.mintTo([signer1Address, signature])).to.be.ok;
    });
  });
});
```

Вы можете использовать пример в документации [signMessage] для в клиенте кошелька [viem], чтобы начать, но он **не** будет работать, как ожидалось.

```tsx
// ПЛОХОЙ ПРИМЕР КОДА, НЕ ИСПОЛЬЗОВАТЬ!
const signature = await owner.signMessage({
  message: signer1Address,
});
```

Попробуйте, и это не сработает. Добавьте лог в ваш контракт, и вы увидите, что восстановленный адрес `signer` случаен, а не первый адрес в списке аккаунтов Hardhat по умолчанию.

Причина в том, что хотя `signMessage` и следует упомянутым ранее стандартам, добавляет `"\x19Ethereum Signed Message:\n32"` к сообщению и правильно его подписывает, он не подготавливает данные для подписания точно так же, как смарт-контракт преобразует `address` в `bytes32`.

Чтобы исправить это, сначала импортируйте некоторые вспомогательные функции из [viem]:

```tsx
import { keccak256, encodePacked, toBytes } from 'viem';
```

Затем `encodePacked` и `keccak256` хэшируют ваши переменные и превращают их в `bytes`, точно так же, как вы сделали в контракте в `validateSignature`:

```tsx
const message = keccak256(encodePacked(['address'], [signer1Address]));
const messageBytes = toBytes(message);
```

Наконец, вызовите функцию кошелька `signMessage` с вновь собранными `messageBytes`. Вам нужно будет пометить представление данных как `raw`:

```tsx
const signature = await owner.signMessage({
  message: { raw: messageBytes },
});
```

Протестируйте снова, и тест пройдет!

## Подписание из бэкенда

Вам решать, какие условия вы готовы подписать сообщение. Как только эти условия выполнены, вы можете использовать аналогичный процесс для загрузки кошелька из вашего приватного ключа и подписания сообщения на любом бэкенде TypeScript:

```tsx
const authorizedAccount = privateKeyToAccount(COINBASE_WALLET_KEY as `0x${string}`);

const authorizedClient = createWalletClient({
  account: authorizedAccount,
  chain: base,
  transport: http(), // Оставьте пустым для локального аккаунта
});

// Согласовать подписанное сообщение с OpenZeppelin/Solidity

const messageToSign = keccak256(encodePacked(['address'], [userAddress as `0x${string}`]));
const messageBytes = getBytes(messageToSign);

// Создать Ethereum Signed Message с адресом пользователя
const signedMessage = await authorizedClient.signMessage({
  message: { raw: messageBytes },
});
console.log('User address:', userAddress);
console.log('Signed message:', signedMessage);

const data = encodeFunctionData({
  abi: mintContractData.abi,
  functionName: 'mintTo',
  args: [userAddress, signedMessage],
});
```

<Info>
`privateKeyToAccount` ожидает, что ваш ключ начинается с `0x`. Возможно, вам потребуется добавить его вручную, в зависимости от инструмента, из которого вы его экспортировали.
</Info>

## Заключение

В этом руководстве вы узнали, как создать минт по подписи, который позволяет вам устанавливать условия на бэкенде, прежде чем пользователю будет разрешено создать ваш NFT. Вы узнали детальные и специфические шаги, необходимые для согласования метода [viem] подписания сообщений [OpenZeppelin] с методом их проверки. Наконец, вы узнали о некоторых рисках и соображениях, необходимых при проектировании этого типа минта.

[Base Learn]: https://base.org/learn
[ERC-721 Tokens]: https://docs.base.org/base-learn/docs/erc-721-token/erc-721-standard-video
[Vercel]: https://vercel.com
[deploying with Vercel]: /tutorials/farcaster-frames-deploy-to-vercel
[OpenZeppelin ERC-721]: https://docs.openzeppelin.com/contracts/2.x/api/token/erc721
[Pinata]: https://www.pinata.cloud/
[ERC-191]: https://eips.ethereum.org/EIPS/eip-191
[EIP-712]: https://eips.ethereum.org/EIPS/eip-712
[Hardhat]: https://hardhat.org/
[viem]: https://viem.sh/
[signMessage]: https://viem.sh/docs/actions/wallet/signMessage.html
[OpenZeppelin]: https://www.openzeppelin.com/

