---
title: Упражнение по токенам ERC-20
description: Упражнение - Создайте свой собственный токен ERC-20!
hide_table_of_contents: false
sidebarTitle: Упражнение
---

Создайте контракт, соответствующий следующим спецификациям.

---

## Контракт

Создайте контракт с именем `WeightedVoting`. Добавьте следующее:

- `maxSupply` в размере 1 000 000
- Ошибки для:
  - `TokensClaimed`
  - `AllTokensClaimed`
  - `NoTokensHeld`
  - `QuorumTooHigh`, возвращающая предложенное количество кворума
  - `AlreadyVoted`
  - `VotingClosed`
- Структуру с именем `Issue`, содержащую:
  - Набор OpenZeppelin Enumerable Set для хранения адресов с именем `voters`
  - Строку `issueDesc`
  - Хранилище для количества `votesFor`, `votesAgainst`, `votesAbstain`, `totalVotes`, и `quorum`
  - Логические значения, хранящие, является ли вопрос `passed` и `closed`

<Warning>
Модульные тесты требуют, чтобы эта `struct` была построена с переменными в указанном выше порядке.
</Warning>


- Массив `Issue` с именем `issues`
- Перечисление (`enum`) для `Vote`, содержащее:
  - `AGAINST`
  - `FOR`
  - `ABSTAIN`
- Все остальное, необходимое для выполнения задач

Добавьте следующие функции.

### Конструктор

Инициализируйте токен ERC-20 и сожгите нулевой элемент `issues`.

### Получение токенов (Claim)

Добавьте `public` функцию с именем `claim`. При вызове, пока количество токенов, равное `maximumSupply`, еще не было распределено, любой кошелек, который еще не получал токены ранее, должен иметь возможность получить 100 токенов. Если кошелек попытается получить токены во второй раз, должен произойти откат (revert) с ошибкой `TokensClaimed`.

Как только все токены будут получены, эта функция должна выполнить откат с ошибкой `AllTokensClaimed`.

<Warning>
В нашем простом токене мы использовали `totalSupply` для предварительной чеканки токенов. Реализация ERC20, которую мы используем, также отслеживает `totalSupply`, но делает это по-другому.

Ознакомьтесь с документацией и комментариями в коде, чтобы узнать как.
</Warning>


### Создание вопроса (Create Issue)

Реализуйте `external` функцию с именем `createIssue`. Она должна добавлять новый `Issue` в `issues`, позволяя пользователю установить описание вопроса и `quorum` - количество голосов, необходимое для закрытия вопроса.

Только держатели токенов могут создавать вопросы, и нельзя создавать вопросы, требующие `quorum` больше текущего общего количества токенов.

Эта функция должна возвращать индекс вновь созданного вопроса.

<Warning>
Один из модульных тестов сломается, если вы разместите проверку `quorum` перед проверкой того, что пользователь владеет токеном. Тест сравнивает закодированные имена ошибок, которые **не** читаемы человеком. Если вы получаете `-> AssertionError: �s is not equal to �9�` или подобное, скорее всего, проблема в этом.
</Warning>


### Получение вопроса (Get Issue)

Добавьте `external` функцию с именем `getIssue`, которая может возвращать все данные для вопроса с предоставленным `_id`.

`EnumerableSet` имеет внутри `mapping`, поэтому он не может быть возвращен за пределами контракта. Вам придется что-то придумать.

<Note>
**Подсказка**

Тип возвращаемого значения для этой функции должен быть `struct`, очень похожим на тот, который хранит вопросы.
</Note>

### Голосование  (Vote)

Добавьте `public` функцию с именем `vote`, которая принимает `_issueId` и голос держателя токенов. Функция должна выполнять откат, если вопрос закрыт или кошелек уже голосовал по этому вопросу.

Держатели должны проголосовать всеми своими токенами за, против или воздержаться от голосования по вопросу. Это количество должно быть добавлено к соответствующему члену вопроса и общему количеству собранных голосов.

Если это голосование приводит общее количество голосов к `quorum` для этого голосования или превышает его, тогда:

- Вопрос должен быть установлен так, чтобы `closed` был `true`
- Если голосов за больше, чем против, установить `passed` в `true`

---

### Отправьте свой контракт и получите NFT-значок! (BETA)

<Note>
#### Эй, куда делся мой NFT?!

[Тестовые сети](/learn/deployment-to-testnet/test-networks) не являются постоянными! Base Goerli [скоро будет приостановлена](https://base.mirror.xyz/kkz1-KFdUwl0n23PdyBRtnFewvO48_m-fZNzPMJehM4), в пользу Base Sepolia.

Поскольку это отдельные сети с отдельными данными, ваши NFT **не будут** перенесены.

**Не волнуйтесь!** Мы зафиксировали адреса всех владельцев NFT на Base Goerli и включим их, когда позже в этом году выпустим механизм переноса этих NFT в основную сеть! Вы также можете повторно развернуть на Sepolia и повторно отправить, если хотите!
</Note>


<Warning>
Спецификация контракта содержит действия, которые могут быть выполнены только один раз данным адресом. В результате модульные тесты для проходящего контракта будут успешными только **первый** раз, когда вы тестируете.

**Возможно, вам потребуется отправить новое развертывание, чтобы пройти тест**
</Warning>

{/* <CafeUnitTest nftNum={14}/> */}

<iframe
  src="https://684b5e62b1ff46bc5bf83966-aijszlfakk.chromatic.com/iframe.html?args=&id=components-cafeunittest--fourteen&viewMode=story&dark=true&hero=true"
  width="100%"
  height="auto"
/>
