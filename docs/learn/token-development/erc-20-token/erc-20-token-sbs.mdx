---
title: Реализация ERC-20
sidebarTitle: Пошаговое руководство
description: Реализуйте свой собственный токен ERC-20.
hide_table_of_contents: false
---

ERC-20 - это стандарт, который позволяет разрабатывать взаимозаменяемые (fungible) токены и помогает сайтам и приложениям, таким как биржи, знать, как находить и отображать информацию об этих токенах. Вы можете использовать существующие реализации, такие как реализация от [OpenZeppelin], для разработки собственных токенов.

---

## Цели

К концу этого урока вы должны уметь:

- Описывать OpenZeppelin
- Импортировать реализацию ERC-20 от OpenZeppelin
- Описывать разницу между стандартом ERC-20 и ERC20.sol от OpenZeppelin
- Создавать и развертывать токен, соответствующий стандарту ERC-20

---

## Настройка контракта

Создайте новый файл Solidity, добавьте лицензию и прагму, а также импортируйте реализацию ERC-20, ссылка на которую приведена выше.

Добавьте контракт с именем `MyERC20Token`, который наследуется от `ERC20`.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol";

contract MyERC20Token is ERC20 {

}
```

### Добавление конструктора

Ознакомьтесь с конструктором в строке 53 реализации [OpenZeppelin]. Он требует строки для имени и символа, которые вы хотите использовать для своего токена. Они используют немного другое соглашение об именовании, помещая `_` после имени параметров. Как и в любой другой функции, вы можете передавать переменные любого имени, если они правильного типа, поэтому не стесняйтесь продолжать добавлять `_` впереди в конструкторе вашего контракта:

```solidity
constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {

}
```

<Warning>
Не существует ни регулирующего органа, ни встроенных программных правил, которые мешали бы вам или кому-либо еще использовать то же имя и символ, что и уже используемый токен. Мошенники часто пользуются этим фактом, и даже добросовестные разработчики могут вызвать путаницу, не будучи осторожными в этом вопросе.
</Warning>


Вот и все. Вы закончили! Разверните и протестируйте, и вы должны увидеть всю функциональность, требуемую стандартом и предоставляемую реализацией OpenZeppelin.

<Frame>
![Deployed](/images/learn/erc-20/deployed-token.png)
</Frame>

Проведите тестирование. Вы увидите, что `totalSupply` и все балансы равны нулю.

По умолчанию десятичный знак для токена будет 18, что является наиболее распространенным выбором. Помните, что десятичных типов еще нет, поэтому 1.0 ETH на самом деле - это `uint`, содержащий 1 * 10**18, или 1000000000000000000.

---

## Дальнейшее тестирование ERC-20

Строка 251 реализации [OpenZeppelin] содержит функцию `_mint`, но она является internal. В результате вам нужно будет придумать механизм чеканки (minting) и добавить его через свой собственный контракт.

### Минт в конструкторе

Один из способов использования функции `_mint` - создать начальное предложение токенов в конструкторе. Добавьте вызов _mint, который начисляет 1 полный токен создателю контракта. Помните, десятичный знак равен 18. Чеканка буквально 1 - это создание крошечной пылинки.

```solidity
constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {
    _mint(msg.sender, 1 * 10**18);
}
```

Повторно разверните. Без каких-либо дополнительных действий с вашей стороны вы должны обнаружить, что `totalSupply` теперь равен 1000000000000000000, как и `balanceOf` развертывающего адреса.

Вы также можете использовать это для чеканки токенов другим пользователям. Добавьте второй и третий аккаунты:

<Accordion title="Показать код">

```solidity
constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {
    _mint(msg.sender, 1 * 10**18);
    _mint(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2, 1 * 10**18);
    _mint(0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db, 1 * 10**18);
}
```

</Accordion>


**Вернитесь** к первому аккаунту и повторно разверните. Протестируйте, чтобы подтвердить, что каждый аккаунт имеет соответствующее количество токенов.

### Тестирование функции перевода

Попробуйте использовать функцию `transfer` для перемещения токенов.

Что произойдет, если вы попытаетесь сжечь токен, отправив его на нулевой адрес? Попробуйте!

Вы получите ошибку, потому что защита от сжигания встроена в функцию `_transfer`.

```text
transact to MyERC20Token.transfer pending ...
transact to MyERC20Token.transfer errored: VM error: revert.

revert
	The transaction has been reverted to the initial state.
Reason provided by the contract: "ERC20: transfer to the zero address".
Debug the transaction to get more information.
```

### Тестирование функции transferFrom

Возможно, вы заметили, что есть другая функция под названием `transferFrom`. Для чего она нужна? Проверьте документацию в контракте, чтобы узнать!

Эта функция работает вместе с функцией `allowance`, чтобы дать владельцу одного кошелька разрешение потратить до указанного количества токенов, принадлежащих другому. Биржи могут использовать это, чтобы позволить пользователю выставить токены на продажу по заданной цене, не забирая их во владение.

---

## Заключительные мысли по ERC-20

Мир все еще выясняет, как справляться со всеми новыми возможностями, которые предоставляют токены. Старые законы применяются по-новому, и пишутся новые законы. Разные юрисдикции делают это уникальными, а иногда и противоречивыми способами.

Вам следует проконсультироваться с юристом в вашей юрисдикции, прежде чем выпускать собственные токены.

---

## Заключение

В этом уроке вы узнали, как легко создать токен, соответствующий стандарту ERC-20, используя реализацию OpenZeppelin. Вы рассмотрели как минимум один метод создания начального предложения токенов и поняли, что вам нужно самостоятельно решать, как лучше всего создавать свои токены и соблюдать все соответствующие законы и нормативные акты.

---

[OpenZeppelin]: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol
