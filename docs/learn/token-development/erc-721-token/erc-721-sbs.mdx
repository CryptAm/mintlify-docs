---
title: Токен ERC-721
description: Создайте свой собственный NFT на основе стандарта ERC-721.
hide_table_of_contents: false
sidebarTitle: Пошаговое руководство
---

import { Danger } from "/snippets/danger.mdx";

Панки, обезьяны и птицы всех видов. Вы слышали о них, видели их и, возможно, даже достаточно удачливы, чтобы владеть известным NFT. Или, может быть, вы просто купили случайную коллекцию и не знаете, что делать со своим NFT. NFT на самом деле не являются картинками или чем-то еще конкретным. Это метод доказательства владения цифровым активом. Любой может кликнуть правой кнопкой мыши на изображение обезьяны и установить его в качестве аватара профиля, но только владелец может использовать его с приложениями, которые используют веб3-право собственности.

Стандарт токенов ERC-721 - это основная техническая спецификация, которая не только делает возможным цифровое владение, но и предоставляет стандартизированный способ для торговых площадок, галерей и других сайтов знать, как взаимодействовать с этими цифровыми предметами.

---

## Цели

К концу этого урока вы должны уметь:

- Анализировать структуру токена ERC-721
- Сравнивать и противопоставлять технические спецификации ERC-20 и ERC-721
- Ознакомиться с формальной спецификацией ERC-721
- Создавать и развертывать токен, соответствующий стандарту ERC-721
- Использовать токен ERC-721 для контроля владения другой структурой данных

---

## Реализация токена ERC-721 от OpenZeppelin

JPG, возможно, сейчас в тренде, но в будущем селфи, которое вы публикуете в социальных сетях, текстовое сообщение, которое вы отправляете своей матери, и боевой топор +4, который вы используете в своей любимой MMO, могут быть NFT.

### Импорт и настройка

Начните с открытия контракта ERC-721 от [OpenZeppelin] в Github. Скопируйте ссылку и используйте ее для импорта контракта ERC-721. Создайте свой собственный контракт с именем `MyERC721`, который наследуется от `ERC721Token`. Добавьте конструктор, который инициализирует `_name` и `_symbol`.


<Accordion title="Показать код">
```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol";

contract MyERC721Token is ERC721 {
  constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {

  }
}
```
</Accordion>

### Минт NFTs

Функция минта, предоставляемая OpenZeppelin, `_safeMint`, является `internal`. Чтобы использовать ее для того, чтобы позволить вашим клиентам создавать NFT, вам нужно реализовать функцию в вашем контракте, которая вызывает функцию в импортированном контракте.

Прежде чем вы сможете это сделать, вам нужен способ предоставить два параметра, необходимых для _safeMint:

- `address to` - владелец нового NFT
- `uint256 tokenId` - идентификационный номер нового NFT

Владелец прост, вы можете просто использовать `msg.sender`, чтобы предоставить право собственности кошельку, выполняющему чеканку.

ID немного сложнее. Распространенной практикой является просто назначение общего количества NFT, включая создаваемый, в качестве `tokenId`. Это просто, облегчает поиск всех NFT в коллекции и помогает соответствовать распространенному мнению сообщества, что NFT с меньшими номерами лучше, как и другие коллекционные предметы ограниченного выпуска.

<Warning>
Сокрытие определенной информации, такой как идентификаторы клиентов, часто считается лучшей практикой. Это может затруднить доступ злоумышленника, который обошел другие функции безопасности, к большему количеству данных. Если `134` является допустимым `customer_id`, вероятно, `135` тоже является. То же самое нельзя сказать о `bfcb51bd-c04f-42d5-8116-3def754e8c32`.

Эта практика не так полезна в блокчейне, потому что вся информация общедоступна.
</Warning>


Для реализации генерации ID просто добавьте `uint` с именем `counter` в хранилище и инициализируйте его как 1, либо при объявлении, либо в конструкторе.

Теперь вы можете добавить функцию `redeemNFT`, которая вызывает `safeMint`, используя `msg.sender` и `counter`, а затем увеличивает `counter`:

<Accordion title="Показать код">
  
```solidity
function redeemNFT() external {
    _safeMint(msg.sender, counter);
    counter++;
}
```
</Accordion>


<Danger>
Как программист, вы, вероятно, приложили большие усилия, чтобы усвоить идею индексации с нуля. Массивы начинаются с 0. Пиксель в левом верхнем углу вашего экрана находится в позиции 0, 0.

В результате вам нужно быть очень осторожным при работе с Solidity, потому что нет концепции `undefined`, а «удаленные» значения возвращаются к своему значению по умолчанию, которое для чисел равно 0.

Чтобы предотвратить риски безопасности, вам нужно убедиться, что вы никогда не даете ID или индекс массива 0 чему-либо. В противном случае попытка удалить значение, такое как член `struct` с именем `authorizedSellerID`, может предоставить адресу кошелька, хранящемуся в индексе 0, доступ к этому ресурсу.
</Danger>


Разверните и протестируйте. Обязательно:

- Создайте несколько NFT
- Переведите NFT с одного аккаунта Remix на другой
- Попробуйте перевести NFT на `0x0000000000000000000000000000000000000000`

---

## URI для ERC-721

Стандарт ERC-721 включает возможность определения [URI] связанного с каждым NFT. Они предназначены для указания на файл `json`, соответствующий Схеме JSON метаданных ERC721

```json
{
  "title": "Asset Metadata",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "Identifies the asset to which this NFT represents"
    },
    "description": {
      "type": "string",
      "description": "Describes the asset to which this NFT represents"
    },
    "image": {
      "type": "string",
      "description": "A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."
    }
  }
}
```

Обратите внимание, что это не обязательно. В реализации OpenZeppelin функция, возвращающая `_baseURI`, является `virtual` и должна быть переопределена наследуемым контрактом.

```
// OpenZeppelin ERC-721
/**
    * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
    * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
    * by default, can be overridden in child contracts.
    */
function _baseURI() internal view virtual returns (string memory) {
    return "";
}
```

Таким образом, владелец контракта может выбрать, каким будет значение, и когда, как или если оно может быть изменено. Например, контракт [Bored Ape Yacht Club] имеет функцию, позволяющую владельцу установить или изменить _baseURI, изменив место хранения метаданных и, возможно, их содержимое.

```solidity
// Из boredapeyachtclub.sol
function setBaseURI(string memory baseURI) public onlyOwner {
    _setBaseURI(baseURI);
}
```

Метаданные для [BAYC] [stored on IPFS], но некоторые проекты даже используют централизованные, веб2-опции хранения!

### NFT Подмена

[Doodles] - еще одна коллекция NFT, которая для хранения метаданных. Давайте изменим наш контракт, чтобы переключать метаданные туда-сюда между двумя коллекциями.

Начните с сохранения баз IPFS метаданных как констант на уровне контракта. Добавьте перечисление для выбора между этими двумя вариантами и экземпляр этого перечисления.

<Accordion title="Показать код">

```solidity
    string constant BAYC = "https://ipfs.io/ipfs/QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/";
    string constant DOODLES = "https://ipfs.io/ipfs/QmPMc4tcBsMqLRuCQtPmPe84bpSjrC3Ky7t3JWuHXYB4aS/";

    enum NFTMetadata { BAYC, DOODLES }
    NFTMetadata nftMetadata = NFTMetadata.BAYC;
```

</Accordion>

Наконец, добавьте переопределение `_baseURI`, которое возвращает соответствующий выбор в зависимости от того, какая коллекция активна, и функцию для переключения URI.

<Accordion title="Показать код">

```solidity
function _baseURI() internal override view returns(string memory) {
    if (nftMetadata == NFTMetadata.BAYC) {
        return BAYC;
    } else if (nftMetadata == NFTMetadata.DOODLES){
        return DOODLES;
    } else {
        revert("Error...");
    }
}

function switchURI() public {
    // TODO: Limit to contract owner
    nftMetadata = nftMetadata == NFTMetadata.BAYC ? NFTMetadata.DOODLES : NFTMetadata.BAYC;
}
```

</Accordion>

Разверните, создайте несколько NFT и вызовите `tokenURI`, чтобы найти информацию для токена номер 1. Вы должны получить:

```text
https://ipfs.io/ipfs/QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/1
```

Это ссылка на файл метаданных json для первой Bored Ape:

```json
{
  "image": "ipfs://QmPbxeGcXhYQQNgsC6a36dDyYUcHgMLnGKnF8pVFmGsvqi",
  "attributes": [
    {
      "trait_type": "Mouth",
      "value": "Grin"
    },
    {
      "trait_type": "Clothes",
      "value": "Vietnam Jacket"
    },
    {
      "trait_type": "Background",
      "value": "Orange"
    },
    {
      "trait_type": "Eyes",
      "value": "Blue Beams"
    },
    {
      "trait_type": "Fur",
      "value": "Robot"
    }
  ]
}
```

Ссылки IPFS не работают нативно прямо в браузере, но вы можете увидеть изображение здесь:

https://ipfs.io/ipfs/QmPbxeGcXhYQQNgsC6a36dDyYUcHgMLnGKnF8pVFmGsvqi/

Теперь вызовите вашу функцию `switchURI`, а затем снова вызовите `tokenURI` для токена 1.

Теперь вы получите новую ссылку на метаданные:

```text
https://ipfs.io/ipfs/QmPMc4tcBsMqLRuCQtPmPe84bpSjrC3Ky7t3JWuHXYB4aS/1
```

Которая содержит метаданные для Doodle 1 вместо BAYC 1:

```json
{
  "image": "ipfs://QmTDxnzcvj2p3xBrKcGv1wxoyhAn2yzCQnZZ9LmFjReuH9",
  "name": "Doodle #1",
  "description": "A community-driven collectibles project featuring art by Burnt Toast. Doodles come in a joyful range of colors, traits and sizes with a collection size of 10,000. Each Doodle allows its owner to vote for experiences and activations paid for by the Doodles Community Treasury. Burnt Toast is the working alias for Scott Martin, a Canadian\u2013based illustrator, designer, animator and muralist.",
  "attributes": [
    {
      "trait_type": "face",
      "value": "holographic beard"
    },
    {
      "trait_type": "hair",
      "value": "white bucket cap"
    },
    {
      "trait_type": "body",
      "value": "purple sweater with satchel"
    },
    {
      "trait_type": "background",
      "value": "grey"
    },
    {
      "trait_type": "head",
      "value": "gradient 2"
    }
  ]
}
```

Ваша робот-обезьяна теперь стала человеком с радужной бородой!

https://ipfs.io/ipfs/QmTDxnzcvj2p3xBrKcGv1wxoyhAn2yzCQnZZ9LmFjReuH9

---

## Заключение

В этом уроке вы узнали, как использовать реализацию ERC-721 от OpenZeppelin для создания собственного контракта NFT. Вы также узнали, как хранятся метаданные NFT и что они не обязательно являются неизменяемыми.

---

[OpenZeppelin]: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol
[Coinbase NFT]: https://nft.coinbase.com/
[URI]: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier
[stored on IPFS]: https://ipfs.io/ipfs/QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/
[BAYC]: https://nft.coinbase.com/collection/ethereum/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d
[CryptoPunks]: https://nft.coinbase.com/collection/ethereum/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
[Doodles]: https://nft.coinbase.com/collection/ethereum/0x8a90cab2b38dba80c64b7734e58ee1db38b8992e
[uses IPFS]: https://ipfs.io/ipfs/QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/

