---
title: Отладка ошибок
sidebarTitle: Руководство по ошибкам
description: Узнайте, как выявлять и исправлять распространенные ошибки в Solidity.
hide_table_of_contents: false
---

## Цели обучения

После изучения этого урока вы сможете:

- Отлаживать распространенные ошибки Solidity, включая откат транзакции, нехватку газа, переполнение стека, переполнение/потерю значимости значения, выход индекса за пределы диапазона и т.д.

---

## Ошибки компилятора

Ошибки компилятора разнообразны, но почти всегда их очень легко исправить, поскольку сообщение об ошибке обычно говорит, что не так и как это исправить.

### Ошибки типов

Вы получите ошибку компилятора, если попытаетесь присвоить литерал неправильному типу.

```solidity
// Плохой пример кода, не используйте
function compilerTypeError() public pure returns (uint) {
    uint myNumber = "One";
    return myNumber;
}
```

```text
from solidity:
TypeError: Type literal_string "One" is not implicitly convertible to expected type uint256.
 --> contracts/ErrorTriage.sol:8:9:
  |
8 |         uint myNumber = "One";
  |         ^^^^^^^^^^^^^^^^^^^^^
```

Исправьте, корректируя тип или значение в соответствии с вашими потребностями:

<Accordion title="Reveal code">


```solidity
function compilerTypeErrorFixed() public pure returns (string) {
    string myNumber = "One";
    return myNumber;
}
```

</Accordion>

### Ошибки преобразования

Ошибки преобразования возникают, когда вы пытаетесь _неявно_ преобразовать один тип в другой. Solidity позволяет это только в очень узких обстоятельствах, где нет возможности неоднозначной интерпретации данных.
```solidity
// Плохой пример кода, не используйте
function compilerConversionError() public pure returns (uint) {
    int8 first = 1;

    return first;
}
```

```text
из solidity:
TypeError: Аргумент возврата типа int8 не является неявно преобразуемым в ожидаемый тип (тип первой возвращаемой переменной) uint256.
  --> contracts/ErrorTriage.sol:15:16:
   |
15 |         return first;
   |                ^^^^^
```

Исправьте, явно преобразуя при необходимости:

<Accordion title="Reveal code">


```solidity
function compilerConversionErrorFixed() public pure returns (uint) {
    int8 first = 1;

    return uint(uint8(first));
}
```

</Accordion>

<Tip>
Вам часто потребуется использовать несколько преобразований для перехода от одного типа к другому.
</Tip>


### Ошибки операторов

Вы не можете использовать операторы между типами так гибко, как вы, возможно, привыкли.

```solidity
// Плохой пример кода, не используйте
function compilerOperatorError() public pure returns (uint) {
    int8 first = 1;
    uint256 second = 2;

    uint sum = first + second;

    return sum;
}
```

Ошибки операторов часто сопровождаются ошибкой типа.

```text
из solidity:
TypeError: Оператор + не совместим с типами int8 и uint256.
  --> contracts/ErrorTriage.sol:22:20:
   |
22 |         uint sum = first + second;
   |                    ^^^^^^^^^^^^^^

из solidity:
TypeError: Тип int8 не является неявно преобразуемым в ожидаемый тип uint256.
  --> contracts/ErrorTriage.sol:22:9:
   |
22 |         uint sum = first + second;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
```

Исправьте, явно преобразуя к конечному типу:

<Accordion title="Reveal code">


```
function compilerOperatorErrorFixed() public pure returns (uint) {
    int8 first = 1;
    uint256 second = 2;

    uint sum = uint(uint8(first)) + second;

    return sum;
}
```

</Accordion>

### Лимит глубины стека

[EVM stack] имеет 1024 слота, но доступны только верхние 16 слотов. В результате вы можете одновременно иметь менее 16 переменных в области видимости.

<Warning>
Другие элементы также могут использовать эти слоты. Вам **не гарантируется** 15 слотов, их может быть меньше.
</Warning>


```solidity
// Плохой пример кода, не используйте
function stackDepthLimit() public pure returns (uint) {
        uint first = 1;
        uint second = 2;
        uint third = 3;
        uint fourth = 4;
        uint fifth = 5;
        uint sixth = 6;
        uint seventh = 7;
        uint eighth = 8;
        uint ninth = 9;
        uint tenth = 10;
        uint eleventh = 11;
        uint twelfth = 12;
        uint thirteenth = 13;
        uint fourteenth = 14;
        uint fifteenth = 15;
        uint sixteenth = 16;

        return first +
                second +
                third +
                fourth +
                fifth +
                sixth +
                seventh +
                eighth +
                ninth +
                tenth +
                eleventh +
                twelfth +
                thirteenth +
                fourteenth +
                fifteenth +
                sixteenth;
    }
```

```text
из solidity:
CompilerError: Стек слишком глубокий. Попробуйте компилировать с --via-ir (cli) или эквивалентным viaIR: true (стандартный JSON) с включением оптимизатора. В противном случае попробуйте удалить локальные переменные.
  --> contracts/ErrorTriage.sol:92:17:
   |
92 |                 eighth +
   |                 ^^^^^^
```

Исправьте эту ошибку, разбивая большие функции и разделяя операции на разные уровни области видимости.

<Accordion title="Reveal code">


```solidity
function stackDepthLimitFixed() public pure returns (uint) {
    uint subtotalA;
    {
        uint first = 1;
        uint second = 2;
        uint third = 3;
        uint fourth = 4;
        uint fifth = 5;
        uint sixth = 6;
        uint seventh = 7;
        uint eighth = 8;
        subtotalA = first +
            second +
            third +
            fourth +
            fifth +
            sixth +
            seventh +
            eighth;
    }

    uint subtotalB;
    {
        uint ninth = 9;
        uint tenth = 10;
        uint eleventh = 11;
        uint twelfth = 12;
        uint thirteenth = 13;
        uint fourteenth = 14;
        uint fifteenth = 15;
        uint sixteenth = 16;
        subtotalB = ninth +
            tenth +
            eleventh +
            twelfth +
            thirteenth +
            fourteenth +
            fifteenth +
            sixteenth;
    }

    return subtotalA + subtotalB;
}
```

</Accordion>

---

## Логические ошибки

Логические ошибки возникают, когда ваш код синтаксически правилен, но все же приводит к состоянию данных, которое нарушает правила языка.

[panic] возникает, когда ваш код пытается выполнить незаконную операцию. Они возвращаются с очень простым кодом ошибки, который, к сожалению, Remix скрывает. Однако он компенсирует это неудобство, предоставляя очень мощный отладчик.

<Warning>
Виртуальная машина Remix ведет себя не совсем так же, как настоящие ончейн-операции, поэтому учтите, что эти ошибки не будут вести себя точно так же, если они возникнут при тестировании с Hardhat или при вызове из фронтенда.
</Warning>
caution

Для каждого из этих примеров скопируйте их в Remix, чтобы изучить с помощью отладчика самостоятельно.

### Выход индекса массива за границы

Паника будет вызвана, если вы попытаетесь получить доступ к массиву по недопустимому индексу.A panic will be triggered if you try to access an array at an invalid index.

```solidity
// Плохой пример кода, не используйте
function badGetLastValue() public pure returns (uint) {
    uint[4] memory arr = [uint(1), 2, 3, 4];

    return arr[arr.length];
}
```

Запуск этой функции приведет к следующей ошибке в консоли:

```text
 вызов ErrorTriage.badGetLastValue завершился ошибкой: Ошибка VM: revert.

revert
	Транзакция была откачена до исходного состояния.
Примечание: Вызываемая функция должна быть payable, если вы отправляете значение, и отправляемое значение должно быть меньше вашего текущего баланса.
Отладьте транзакцию, чтобы получить больше информации.
```

Нажмите кнопку _Debug_ чтобы открыть отладчик.

<Frame>
![Debugger](/images/learn/error-triage/debugger.png)
</Frame>

Отладчик содержит панели с информацией о переменных в хранилище, памяти, о том, что находится в стеке, и т.д. Вы также можете добавлять точки останова в строки кода для дальнейшей помощи в отладке.

Одна из самых полезных функций - это ссылка вверху с инструкцией _"Click here to jump where the call reverted."_

Нажмите на эту ссылку, и отладчик перейдет к точке сбоя **и выделит код, который вызвал панику**. Отлично!

<Frame>
![Highlighted Code](/images/learn/error-triage/highlight-code.png)
</Frame>

Вы можете найти конкретную ошибку здесь, но это сложно.

Посмотрите на панель _Memory_. Первый элемент по адресу `0x0` имеет хэш, начинающийся с `0x4e487b71`. Этот код указывает на панику.

Второй элемент, по адресу `0x20`, содержит скрытый код ошибки `32`, который указывает на выход индекса массива за границы.

<Frame>
![Array out-of-bounds](/images/learn/error-triage/array-out-of-bounds.png)
</Frame>

Иногда лучше сначала просмотреть код, чтобы увидеть, очевидна ли ошибка.

```solidity
function badGetLastValueFixed() public pure returns (uint) {
    uint[4] memory arr = [uint(1), 2, 3, 4];

    return arr[arr.length-1];
}
```

### Нехватка газа

Настройки по умолчанию в Remix затрудняют вызов ошибки нехватки газа, потому что виртуальная машина часто сначала падает. Для этого примера перейдите на вкладку _Deploy & Run Transactions_ и уменьшите лимит газа до **300000**.

Если вы пишете код, который может иметь неоднозначное время выполнения, становится очень сложно точно оценить лимиты газа.

В этом примере каждый цикл имеет шанс 1 из 1000 завершиться.

<Warning>
`block.timestamp` может быть подделан. **НЕ ИСПОЛЬЗУЙТЕ** это как источник случайности, если какое-либо значение может быть получено из одного результата по сравнению с другим!
</Warning>


```solidity
// Плохой пример кода, не используйте
function badRandomLoop() public view returns (uint) {
    uint seed = 0;
    // НЕ ИСПОЛЬЗУЙТЕ ЭТОТ МЕТОД ДЛЯ СЛУЧАЙНЫХ ЧИСЕЛ!!! ЕГО ЛЕГКО ВЗЛОМАТЬ!!!
    while(uint(keccak256(abi.encodePacked(block.timestamp, seed))) % 1000 != 0) {
        seed++;
        // ...сделать что-то
    }

    return seed;
}
```

Запустите эту функцию несколько раз. Часто она будет работать нормально. В других случаях появляется ошибка:

```text
вызов ErrorTriage.badLoop завершился ошибкой: Ошибка VM: out of gas.

out of gas
	В транзакции закончился газ. Пожалуйста, увеличьте Gas Limit.

Отладьте транзакцию, чтобы получить больше информации.
```

Сообщение об ошибке здесь немного вводит в заблуждение. Вы обычно не хотите исправлять это, увеличивая лимит газа. Если вы получаете ошибку газа из-за того, что транзакция не оценила достаточное количество газа, лучше переработать код для лучшей предсказуемости.

```solidity
function badRandomLoopFixed() public view returns (uint) {
    // НЕ ИСПОЛЬЗУЙТЕ ЭТОТ МЕТОД ДЛЯ СЛУЧАЙНЫХ ЧИСЕЛ!!! ЕГО ЛЕГКО ВЗЛОМАТЬ!!!
    uint times = uint(keccak256(abi.encodePacked(block.timestamp))) % 1000;

    for(uint i = 0; i <= times; i++) {
        // ...сделать что-то
    }

    return times;
}
```

### Переполнение или потеря значимости

Тип `uint` вызовет _панику_ в случае переполнения или потери значимости.

```solidity
function badSubtraction() public pure returns (uint) {
    uint first = 1;
    uint second = 2;
    return first - second;
}
```

Как и прежде, вы можете увидеть код паники и тип паники в _памяти_.

<Frame>
![Underflow](/images/learn/error-triage/underflow.png)
</Frame>

В этом случае тип ошибки - `11`, для переполнения/потери значимости вне блока `unchecked`.

Исправьте, изменив свой код для обработки ожидаемого диапазона значений.

<Accordion title="Reveal code">


```solidity
function badSubstractionFixed() public pure returns (int) {
    int first = 1;
    int second = 2;
    return first - second;
}
```

</Accordion>

### Деление на ноль

Ошибки деления на ноль также вызывают панику с кодом `12`.

```solidity
function badDivision() public pure returns (uint) {
    uint first = 1;
    uint second = 0;
    return first / second;
}
```

<Frame>
![Divide by zero](/images/learn/error-triage/divide-by-zero.png)
</Frame>

Не делите на ноль.

---

## Заключение

В этом уроке вы рассмотрели причины и решения ряда ошибок компилятора и логических ошибок, с которыми вы можете столкнуться.

---

[panic]: https://docs.soliditylang.org/en/v0.8.17/control-structures.html?#panic-via-assert-and-error-via-require
[EVM stack]: https://docs.soliditylang.org/en/v0.8.17/introduction-to-smart-contracts.html#storage-memory-and-the-stack
