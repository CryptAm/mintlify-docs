---
sidebarTitle: Монеты Base App
title: 'Найдите и загрузите метаданные для всех монет, созданных через Base App'
description: 'Узнайте, как использовать данные из блокчейна для индексации всех пулов Uniswap v4, созданных для монет, созданных через Zora и Base App, и загрузки метаданных, включая доступную ликвидность, текущие цены, информацию о токенах и многое другое'
---

С запуском Base App пользователи могут публиковать посты в сети и получать оплату, "монетизируя" свой контент. Монеты контента создаются через Zora, и пул Uniswap v4 автоматически создается и инициализируется для этой монеты. В этом стартовом руководстве мы расскажем, как индексировать данные из блокчейна от Uniswap для идентификации всех пулов, содержащих токены экосистемы Zora, фильтровать из них токены Base App и загружать метаданные для этих пулов.

## Обзор

Полный код для этой стартовой реализации можно найти [здесь](https://github.com/base/demos/tree/master/base-app-coins). Руководство ниже объясняет основные компоненты, как это работает, и какие части вам может потребоваться адаптировать под ваши нужды.

Пример представляет собой проект Bun + TypeScript, который использует `viem` для взаимодействия с сетью Base через стандартные методы Ethereum JSON-RPC. Он также использует SDK от Uniswap для упрощения некоторых расчетов.

## Основные компоненты

#### 1. Мониторинг событий (`index.ts`)
Основная точка входа сканирует события `Initialize` Uniswap V4 в указанном диапазоне блоков для обнаружения вновь созданных пулов.

```typescript
const logs = await publicClient.getContractEvents({
    abi: UniswapV4ABI,
    address: UniswapV4PoolManager,
    fromBlock: START_BLOCK_NUMBER,
    toBlock: END_BLOCK_NUMBER,
    eventName: "Initialize"
})

const poolKeys = logs.map((log) => {
    return {
        currency0: log.args.currency0,
        currency1: log.args.currency1,
        fee: log.args.fee,
        tickSpacing: log.args.tickSpacing,
        hooks: log.args.hooks
    }
}) as PoolKey[]
```

**Ключевые аспекты:**
- Использует `publicClient.getContractEvents()` для получения событий инициализации пулов
- Фильтрует события от контракта Uniswap V4 PoolManager
- Извлекает ключи пулов (currency0, currency1, fee, tickSpacing, hooks) из логов событий

**Кастомизации:**
- Настройте `START_BLOCK_NUMBER` и `END_BLOCK_NUMBER` под ваши нужды
- Если вы хотите индексировать эти события в реальном времени, используйте `watchContractEvent` от `viem`


#### 2. Загрузка данных о пулах (`utils.ts`)
Содержит утилиты для обогащения данных о пулах информацией из блокчейна.

```typescript
export async function loadData(key: PoolKey) {
    // Загружаем информацию о каждом токене (name, symbol, decimals)
    const [currency0, currency1] = await Promise.all([
        getCurrency(key.currency0),
        getCurrency(key.currency1)
    ])

    const poolId = Pool.getPoolId(currency0, currency1, key.fee, key.tickSpacing, key.hooks) as `0x${string}`;
    // Загружаем текущую цену пула
    const [sqrtPriceX96, tick, _protocolFee, _lpFee] = await stateView.read.getSlot0([poolId]);
    // Загружаем общее количество доступной ликвидности в пуле
    const liquidity = await stateView.read.getLiquidity([poolId])

    //
    const pool = new Pool(
        currency0,
        currency1,
        key.fee,
        key.tickSpacing,
        key.hooks,
        sqrtPriceX96.toString(),
        liquidity.toString(),
        tick,
    )
    return pool;
}
```


**Определение валюты:**
```typescript
export async function getCurrency(address: string): Promise<Currency> {
    if (address === zeroAddress) {
        return Ether.onChain(base.id);
    }

    const erc20 = getContract({
        abi: erc20Abi,
        address: address as `0x${string}`,
        client: publicClient
    })

    const [name, symbol, decimals] = await Promise.all([
        erc20.read.name(),
        erc20.read.symbol(),
        erc20.read.decimals()
    ])

    return new Token(base.id, address, decimals, symbol, name)
}
```

**Технические детали:**
- Использует контракт Uniswap V4 StateView для эффективных запросов состояния
- Обрабатывает как токены ERC20, так и нативный ETH (нулевой адрес)


#### 3. Логика классификации токенов

```typescript
let coinType: string | undefined;
if (key.hooks === "0xd61A675F8a0c67A73DC3B54FB7318B4D91409040") {
    coinType = "ZORA_CREATOR_COIN"
} else if (key.hooks === "0x9ea932730A7787000042e34390B8E435dD839040") {
    coinType = "ZORA_V4_COIN"
}

if (!coinType) continue;

// Определяем, приходит ли монета из Base App или Zora
const appType = await categorizeAppType(pool);
```

**Base App Token Detection:**
```typescript

export async function categorizeAppType(pool: Pool) {
    async function tryGetPlatformReferrer(address: string) {
        const zoraBaseCoin = getContract({
            abi: parseAbi([
                "function platformReferrer() view returns (address)",
            ]),
            address: address as `0x${string}`,
            client: publicClient
        })

        try {
            const platformReferrer = await zoraBaseCoin.read.platformReferrer()
            return platformReferrer
        } catch (error) {
            return ADDRESS_ZERO
        }
    }

    // Пытаемся получить `platformReferrer()` для обеих валют в пуле
    // возвращаем ADDRESS_ZERO, если функция не существует (валюта не является Zora монетой)
    const [currency0PlatformReferrer, currency1PlatformReferrer] = await Promise.all([
        tryGetPlatformReferrer(pool.currency0.wrapped.address),
        tryGetPlatformReferrer(pool.currency1.wrapped.address)
    ])

    // Если любая из валют имеет адрес реферера Base App,
    // монета приходит из Base App
    if ([currency0PlatformReferrer, currency1PlatformReferrer].includes(BASE_PLATFORM_REFERRER)) {
        return "TBA"
    }

    return "ZORA"
}
```

Поскольку монеты создаются через Zora, фильтрация до тех, которые из Base App, сводится к просмотру адреса платформенного реферера (platform referrer) на Zora монете. Мы не знаем, является ли Zora монета обязательно currency0 или currency1 в пуле, поэтому мы пытаемся получить адрес платформенного реферера для обоих. Для токенов, таких как WETH, у которых эта функция просмотра недоступна, произойдет возврат к нулевому адресу. Если любая из валют возвращает действительный адрес платформенного реферера, который также соответствует адресу реферера, используемому Base App, мы классифицируем монету как пришедшую из Base App.


#### 4. Расчеты ликвидности

```typescript
const priceUpper = TickMath.getSqrtRatioAtTick(TickMath.MAX_TICK)
const priceLower = TickMath.getSqrtRatioAtTick(TickMath.MIN_TICK)

const amount0 = SqrtPriceMath.getAmount0Delta(pool.sqrtRatioX96, priceUpper, pool.liquidity, true);
const amount1 = SqrtPriceMath.getAmount1Delta(priceLower, pool.sqrtRatioX96, pool.liquidity, true)

const amount0HumanReadable = formatUnits(BigInt(amount0.toString()), pool.currency0.decimals);
const amount1HumanReadable = formatUnits(BigInt(amount1.toString()), pool.currency1.decimals);
```

Учитывая количество `liquidity`, которое мы ранее загрузили для пула, мы используем SDK Uniswap для вычислений и получаем удобочитаемые версии того, сколько каждого токена доступно в пуле в качестве общей ликвидности.


## Альтернативные подходы к реализации

### Источники данных о событиях

Эта реализация использует прямые вызовы JSON-RPC через `viem`, но вы можете адаптировать ее для других источников данных:

**Subgraphs**: Если вы уже используете The Graph Protocol, измените логику получения событий, чтобы запрашивать субграф Uniswap V4 вместо прямых RPC вызовов. Замените вызов `getContractEvents` на GraphQL запросы.

**Сервисы индексации**: Для проектов, использующих сторонние сервисы индексации со своими собственными API, замените их API событий, сохраняя ту же логику извлечения ключей пулов.

**Мониторинг в реальном времени**: Преобразуйте из пакетной обработки в реальное время, настроив подписки WebSocket на события новых блоков и обрабатывая пулы по мере их создания.

### Хранение данных

Текущая реализация выводит метаданные в консоль, но вы можете захотеть:
- Сохранять результаты в базе данных для постоянного анализа
- Отправлять данные во внешние API или вебхуки
- Кэшировать результаты, чтобы избежать повторной обработки известных пулов

## Вывод


Объект метаданных содержит следующие поля:

```typescript
const metadata = {
    id: pool.poolId,
    key: pool.poolKey,
    currency0: {
        name: pool.currency0.name,
        symbol: pool.currency0.symbol,
        decimals: pool.currency0.decimals,
        address: pool.currency0.wrapped.address,
    },
    currency1: {
        name: pool.currency1.name,
        symbol: pool.currency1.symbol,
        decimals: pool.currency1.decimals,
        address: pool.currency1.wrapped.address,
    },
    sqrtPriceX96: pool.sqrtRatioX96.toString(),
    tick: pool.tickCurrent,
    liquidity: pool.liquidity.toString(),
    liquidityCurrency0: amount0.toString(),
    liquidityCurrency1: amount1.toString(),
    liquidityCurrency0HumanReadable: `${amount0HumanReadable} ${pool.currency0.symbol}`,
    liquidityCurrency1HumanReadable: `${amount1HumanReadable} ${pool.currency1.symbol}`,
    currency0Price,
    currency1Price,
    currency0PriceHumanReadable: `1 ${pool.currency0.symbol} = ${currency0Price} ${pool.currency1.symbol}`,
    currency1PriceHumanReadable: `1 ${pool.currency1.symbol} = ${currency1Price} ${pool.currency0.symbol}`,
    coinType,
    appType
}
```

### Идентификаторы пулов
- `id`: Уникальный хеш-идентификатор пула
- `key`: Полный объект ключа пула с валютами, комиссией, интервалом тиков (tickSpacing) и хуками (hooks)

### Информация о валютах
- `currency0/currency1.name`: Удобочитаемое имя токена
- `currency0/currency1.symbol`: Символ токена (например, "USDC", "WETH")
- `currency0/currency1.decimals`: Количество знаков после запятой токена для форматирования (decimals)
- `currency0/currency1.address`: Адрес контракта

### Данные о цене
- `sqrtPriceX96`: Текущая цена пула в формате sqrt Uniswap
- `tick`: Текущий тик (логарифмическое представление цены)
- `currency0Price`: Цена currency0 в терминах currency1
- `currency1Price`: Цена currency1 в терминах currency0
- `currency0PriceHumanReadable`: Форматированная строка цены
- `currency1PriceHumanReadable`: Форматированная строка цены

### Метрики ликвидности
- `liquidity`: Общая ликвидность пула во внутреннем формате Uniswap
- `liquidityCurrency0`: Количество currency0 в пуле (сырое значение)
- `liquidityCurrency1`: Количество currency1 в пуле (сырое значение)
- `liquidityCurrency0HumanReadable`: Форматированное количество с символом
- `liquidityCurrency1HumanReadable`: Форматированное количество с символом

### Классификация
- `coinType`: Тип токена Zora ("ZORA_CREATOR_COIN" или "ZORA_V4_COIN")
- `appType`: Экосистема приложения ("ZORA" или "TBA")

## Сценарии использования метаданных

### Аналитика и мониторинг
- **Отслеживание цен**: Мониторьте цены токенов и движение цен с течением времени
- **Анализ ликвидности**: Отслеживайте общую заблокированную стоимость (TVL) в различных пулах токенов
- **Обнаружение рынков**: Выявляйте новые токены, входящие в экосистему

### Торговля и DeFi
- **Обнаружение арбитража**: Сравнивайте цены в разных пулах или DEX
- **Анализ провайдеров ликвидности**: Оценивайте привлекательность пулов для позиций LP
- **Анализ объема**: Отслеживайте торговую активность в определенных категориях токенов

### Анализ экосистемы
- **Категоризация токенов**: Понимайте, какие токены принадлежат каким экосистемам
- **Метрики адаптации**: Мониторьте рост использования токенов Zora и Base App
- **Сравнение между сетями**: Сравнивайте активность в разных сетях

### Интеграционные проекты
- **Отслеживание портфеля**: Включайте токены Zora/Base App в приложения для управления портфелем
- **Интеграция с кошельками**: Улучшайте UI кошельков с информацией о токенах, специфичной для экосистемы
- **Протоколы DeFi**: Создавайте продукты для кредитования, стейкинга или фарминга доходности (yield farming) вокруг этих токенов

## Конфигурация

### Переменные окружения 
- `RPC_URL`: Конечная точка RPC сети Base (обязательно)

### Диапазон блоков
Измените `START_BLOCK_NUMBER` и `END_BLOCK_NUMBER` в `index.ts` для сканирования разных диапазонов или реализации непрерывного мониторинга.

### Адреса хуков (hook)
Добавляйте новые адреса хуков в логику классификации по мере развертывания новых контрактов Zora.

## Начало работы

```bash
# Установите зависимости
bun install

# Установите ваш URL RPC
export RPC_URL="your-base-rpc-endpoint"

# Запустите сканер
bun run index.ts
```

Вывод будет показывать метаданные для каждого обнаруженного пула, соответствующего критериям классификации.

## Расширения и модификации

Это стартовое руководство может быть расширено многими способами:
- Добавьте поддержку дополнительных контрактов хуков по мере их развертывания
- Включите исторические данные о ценах и объемах
- Добавьте оповещения о значительных изменениях ликвидности
- Создайте веб-интерфейсы для просмотра обнаруженных пулов
- Интегрируйте с приложениями для отслеживания портфеля или торговли

Модульная структура упрощает адаптацию отдельных компонентов при сохранении основной логики обнаружения и классификации пулов.
