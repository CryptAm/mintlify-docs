---
title: "Мост Base-Solana"
description: "Мост для токенов и сообщений между Base и Solana"
icon: "bridge"
---

import { GithubRepoCard } from "/snippets/GithubRepoCard.mdx"

<Warning>
  Мост Base-Solana сейчас работает только в тестовых сетях (Base Sepolia ↔ Solana Devnet)..
</Warning>

Мост Base–Solana обеспечивает двусторонние переводы токенов и передачу сообщений между сетями Base и Solana. С его помощью можно:

* **Переводить токены** между Base и Solana
* **Отправлять произвольные кроссчейн-сообщения**
* **Комбинировать переводы и вызовы функций**
* **Развёртывать обернутые токены** в любой из сетей

Данное руководство объясняет архитектуру моста и содержит практические примеры реализации.

## Как это работает

### В сети Base
Контракт моста в Base блокирует или сжигает токены при отправке сообщения в Solana и выпускает или разблокирует токены при получении сообщения из Solana.
Сам контракт моста строит дерево Меркла для исходящих сообщений.
Валидаторы проверяют корень Меркла каждые 300 финализированных блоков и отправляют его в Solana.
Затем вы можете доказать, что ваше сообщение существует в дереве, чтобы завершить перевод в Solana.

<Info>
При переводе в Solana токены, нативные для Base(ETH), блокируются, а нативные для Solana(SOL) сжигаются.
При переносе в Base токены, нативные для Solana выпускаются, а нативные токены Base разблокируются.
</Info>

**Основные смарт-контракты:**
- [**Bridge Contract**](https://github.com/base/bridge/blob/main/base/src/Bridge.sol): обрабатывает исходящие переводы
- [**CrossChainERC20**](https://github.com/base/bridge/blob/main/base/src/CrossChainERC20.sol): токены, которые можно выпускать/сжигать при кроссчейн-переводах
- [**BridgeValidator**](https://github.com/base/bridge/blob/main/base/src/BridgeValidator.sol): проверяет сообщения по подписям валидаторов
- [**Twin Contract**](https://github.com/base/bridge/blob/main/base/src/Twin.sol): ваш персональный контракт в Base, в котором выполняются вызовы из Solana

<Tip>
**Что такое Twin Contract?**
Twin Contract - это смарт-контракт в Base, который действует как ваш `msg.sender` при отправке произвольных вызовов контрактов из Solana.
</Tip>

### В сети Solana
Мост в Solana обрабатывает переводы токенов, блокируя или сжигая их. Для сообщений валидаторы передают их в Base, где они выполняются через персональный Twin Contract.

**Основные программы Solana:**
- [**Bridge Program**](https://github.com/base/bridge/blob/main/solana/programs/bridge): обрабатывает исходящие переводы
- [**Base Relayer Program**](https://github.com/base/bridge/blob/main/solana/programs/base_relayer): координирует передачу сообщений (не является частью основной системы моста)

Полный репозиторий:
<GithubRepoCard title="Base Bridge - Официальный репозиторий" githubUrl="https://github.com/base/bridge" />

<Info>
Программа ретранслятора — это дополнительный модуль, не являющийся обязательным для работы моста. Она просто облегчает процесс передачи сообщений из Solana в Base.
</Info>

## Процессы работы моста

<CardGroup cols={3}>
  <Card title="Из Solana в Base" icon="arrow-right" href="#solana-to-base">
    Автоматическая система ретрансляции для бесшовных переводов
  </Card>

  <Card title="Из Base в Solana" icon="arrow-left" href="#base-to-solana">
    Ручные переводы на основе доказательств с полным контролем
  </Card>

  <Card title="Полнофункциональный пример" icon="code" href="#sol2base%3A-full-stack-example">
    Полноценное приложение с интеграцией фронтенда
  </Card>
</CardGroup>

## Из Solana в Base

**Процесс:** Блокировка SOL → Ожидание предварительного подтверждения валидаторами → Выполнение в Base

Мост из Solana в Base использует можель на основе pull-запросов, которая включает 3 шага:

1. **Инициированиея перевода в Solana** - заблокируйте свои SOL или нативные SPL-токены в хранилище Solana.
2. **Ожидание предварительного подтверждения сообщения валидаторами** - валидаторы проверяют и подтверждают ваш перевод.
3. **Выполнение перевода в Base** - подтверждённый перевод выполняется в Base для выпуска SOL и выполнения любых дополнительных произвольных вызовов.

<Info>
Токены, нативные для Solana, блокируются, а токены, нативные для Base, сжигаются при отправке в Solana. 
Токены, нативные для Base, выпускаются, а токены, нативные для Solana, разблокируются при отправке в Base.
</Info>

Для удобства доступен сервис ретрансляции, который автоматически выполняет этап 3 для пользователей, желающих ограничиться только исходной транзакцией в Solana. Это обеспечивает максимально плавный опыт использования моста при сохранении безопасности модели на основе pull-запросов.

<GithubRepoCard title="Скрипт ретрансляции из Solana в Base" githubUrl="https://github.com/base/bridge/blob/main/scripts/src/commands/sol/onchain/bridge/solana-to-base/bridge-sol.handler.ts" />

### Пример автоматической ретрансляции
Это пример скрипта, который показывает, как отправлять SOL через мост с автоматической ретрансляцией.

```typescript solToBaseWithAutoRelay/index.ts expandable
// Настройка
const TO = "0x8c1a617bdb47342f9c17ac8750e0b070c372c721"; // адрес Base
const AMOUNT = 0.001; // количество SOL

// Перевод SOL с автоматической ретрансляцией
const ixs = [
  getBridgeSolInstruction({
    payer,
    from: payer,
    solVault: solVaultAddress,
    bridge: bridgeAccountAddress,
    outgoingMessage,
    to: toBytes(TO),
    remoteToken: toBytes("0xC5b9112382f3c87AFE8e1A28fa52452aF81085AD"), // SOL в Base
    amount: BigInt(AMOUNT * 10**9),
  }),
  await buildPayForRelayIx(RELAYER_PROGRAM_ID, outgoingMessage, payer)
];

await buildAndSendTransaction(SOLANA_RPC_URL, ixs, payer);
```

Подробнее см. в разделе [Скрипт ретрансляции из Solana в Base](https://github.com/base/bridge/blob/main/scripts/src/commands/sol/onchain/bridge/solana-to-base/bridge-sol.handler.ts).

### Обертка пользовательских SPL-токенов

Пример выше показывает, как переводить нативный SOL в Base через мост.
Чтобы преводить пользовательские SPL-токены, необходимо создать их обернутые ERC20-представления в Base с помощью CrossChainERC20Factory.

<GithubRepoCard title="Пример обертывания токенов" githubUrl="https://github.com/base/bridge/blob/main/scripts/src/commands/sol/onchain/bridge/solana-to-base/wrap-token.handler.ts" />

```typescript wrapSolTokenOnBase/index.ts expandable
// Развертывание обернутого токена в Base
const mintBytes32 = getBase58Codec().encode(SOLANA_SPL_MINT_ADDRESS).toHex();

await client.writeContract({
  address: "0x58207331CBF8Af87BB6453b610E6579D9878e4EA", // Factory
  abi: TokenFactory,
  functionName: "deploy",
  args: [`0x${mintBytes32}`, "Token Name", "SYMBOL", 9],
});
```

## Из Base в Solana

**Процесс:** Сжигание SOL (в Base) → ожидание ~15 минут → генерация доказательства → выполнение в Solana

Отправка SOL через мост из Base в Solana требует ручной генерации доказательства.
Вы сжигаете обернутый SOL в Base, ждете финализации, затем создаете криптографическое доказательство, чтобы выполнить транзакцию в Solana и получить нативный SOL.

<GithubRepoCard title="Пример из Base в Solana" githubUrl="https://github.com/base/bridge/blob/main/scripts/src/internal/sol/base.ts" />


```typescript bridgeSolFromBaseToSolana/index.ts expandable
// Шаг 1: Сжигание SOL в Base
const transfer = {
  localToken: "0xC5b9112382f3c87AFE8e1A28fa52452aF81085AD", // SOL (в Base)
  remoteToken: pubkeyToBytes32(SOL_ADDRESS),
  to: pubkeyToBytes32(solanaAddress),
  remoteAmount: BigInt(AMOUNT * 10**9),
};

const txHash = await client.writeContract({
  address: "0xB2068ECCDb908902C76E3f965c1712a9cF64171E", // Мост
  abi: Bridge,
  functionName: "bridgeToken",
  args: [transfer, []],
});

// Шаг 2: Ожидание финализации
const isProvable = await isBridgeMessageProvable(txHash);

// Шаг 3: Генерация доказательства
const { event, rawProof } = await generateProof(txHash, baseBlockNumber);

// Шаг 4: Выполнение в Solana
const proveIx = getProveMessageInstruction({
  nonce: event.message.nonce,
  sender: toBytes(event.message.sender),
  data: toBytes(event.message.data),
  proof: rawProof.map(e => toBytes(e)),
  messageHash: toBytes(event.messageHash),
});

const relayIx = getRelayMessageInstruction({ message: messagePda });
await buildAndSendTransaction(SOLANA_RPC_URL, [proveIx, relayIx], payer);
```

## Утилити

Репозиторий содержит утилити для преобразования адресов между форматами Solana и Base, получения ключей из Solana CLI для подписания транзакций, а также для сборки и отправки транзакций Solana.

<GithubRepoCard title="Примеры моста Base - Утилити" githubUrl="https://github.com/base/bridge/tree/main/scripts/src/commands" />

### Преобразование адресов

Преобразование публичного ключа Solana в bytes32 для контрактов Base:
```typescript example.ts
// Преобразование открытого ключа Solana в bytes32 для контрактов Base
import { pubkeyToBytes32 } from "./utils/pubkeyToBytes32";

const bytes32Address = pubkeyToBytes32(solanaAddress);
```

### Управление ключами

Получение ключей из Solana CLI для подписания транзакций:

```typescript example.ts
import { getSolanaCliConfigKeypairSigner } from "./utils/keypair";

const payer = await getSolanaCliConfigKeypairSigner();
```

### Сборка транзакций

Сборка и отправка транзакций Solana:

```typescript example.ts
import { buildAndSendTransaction } from "./utils/buildAndSendTransaction";

const signature = await buildAndSendTransaction(SOLANA_RPC_URL, ixs, payer);
```

## Sol2Base: Полнофункциональный пример

<GithubRepoCard title="Sol2Base - Полнофункциональное приложение моста" githubUrl="https://github.com/base/sol2base" />

Sol2Base - это готовое к использованию приложение на Next.js, которое демонстрирует создание полноценного фронтенда для моста между Base и Solana. В нём используется «хакерская» стилистика с анимациями в духе «Матрицы». Приложение поддерживает подключение кошельков, кран CDP, разрешение ENS/Basename и мониторинг транзакций в реальном времени.

### Реализация сервиса моста

Основной сервис моста обрабатывает переводы SOL с автоматической ретрансляцией и разрешением адресов:

```typescript src/lib/bridge.ts expandable
export class SolanaBridge {
  private connection: Connection;

  constructor() {
    this.connection = new Connection(SOLANA_DEVNET_CONFIG.rpcUrl, 'confirmed');
  }

  async createBridgeTransaction(
    walletAddress: PublicKey,
    amount: number,
    destinationAddress: string,
    signTransaction: (transaction: Transaction) => Promise<Transaction>
  ): Promise<string> {
    // Импорт преобразователя адресов и реализации моста
    const { addressResolver } = await import('./addressResolver');
    const { realBridgeImplementation } = await import('./realBridgeImplementation');
    
    // Разрешение адреса назначения (обрабатывает ENS/basename)
    const resolvedAddress = await addressResolver.resolveAddress(destinationAddress);

    // Проверка суммы
    if (amount < BRIDGE_CONFIG.minBridgeAmount / Math.pow(10, 9)) {
      throw new Error(`Minimum bridge amount is ${BRIDGE_CONFIG.minBridgeAmount / Math.pow(10, 9)} SOL`);
    }

    // Создание фактической транзакции моста
    const transaction = await realBridgeImplementation.createBridgeTransaction(
      walletAddress,
      amount,
      resolvedAddress
    );

    // Отправка транзакции
    const signature = await realBridgeImplementation.submitBridgeTransaction(
      transaction,
      walletAddress,
      signTransaction
    );

    return signature;
  }
}
```
### Сервис разрешения адресов

Поддерживает ENS и Basename для удобной адресации:

```typescript src/lib/addressResolver.ts expandable
export class AddressResolver {
  async resolveAddress(input: string): Promise<string> {
    const trimmedInput = input.trim();

    // Если это уже действительный адрес Ethereum, возвращаем как есть
    if (this.isValidEthereumAddress(trimmedInput)) {
      return trimmedInput;
    }

    // Обработка ENS имен (.eth)
    if (trimmedInput.endsWith('.eth') && !trimmedInput.endsWith('.base.eth')) {
      return await this.resolveEns(trimmedInput);
    }

    // Обработка basenames (.base.eth or .base)
    if (trimmedInput.endsWith('.base.eth') || trimmedInput.endsWith('.base')) {
      return await this.resolveBasename(trimmedInput);
    }

    throw new Error('Invalid address format');
  }

  private async resolveEns(ensName: string): Promise<string> {
    const response = await fetch(`https://api.ensdata.net/${ensName}`);
    const data = await response.json();
    
    if (!data.address) {
      throw new Error(`ENS name ${ensName} does not resolve to an address`);
    }

    return data.address;
  }
}
```

### Интерфейс моста React

Полноценный компонент пользовательского интерфейса с интеграцией кошелька и проверкой данных формы:

```typescript src/components/BridgeInterface.tsx expandable
export const BridgeInterface: React.FC = () => {
  const { publicKey, connected, signTransaction } = useWallet();
  const [solBalance, setSolBalance] = useState<number>(0);
  const [transactions, setTransactions] = useState<BridgeTransaction[]>([]);

  // Обработка транзакции моста
  const handleBridge = async (amount: number, destinationAddress: string) => {
    if (!publicKey || !signTransaction) {
      setError('Wallet not connected');
      return;
    }

    try {
      const txHash = await solanaBridge.createBridgeTransaction(
        publicKey, 
        amount, 
        destinationAddress,
        signTransaction
      );

      // Добавление в историю транзакций
      const newTransaction: BridgeTransaction = {
        txHash,
        amount,
        destinationAddress,
        status: 'confirmed',
        timestamp: Date.now(),
        type: 'bridge'
      };

      setTransactions(prev => [newTransaction, ...prev]);
      await loadBalances();

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Bridge transaction failed');
    }
  };

  return (
    <div className="max-w-4xl mx-auto space-y-8">
      <BalanceDisplay solBalance={solBalance} />
      <FaucetButton onFaucet={handleSolFaucet} />
      <BridgeForm onBridge={handleBridge} maxAmount={solBalance} />
      <TransactionStatus transactions={transactions} />
    </div>
  );
};
```

### Форма моста с разрешением адресов

Интеллектуальный компонент формы с поддержкой ENS/Basename и проверкой данных:

```typescript src/components/BridgeForm.tsx expandable
export const BridgeForm: React.FC<BridgeFormProps> = ({ onBridge, maxAmount }) => {
  const [amount, setAmount] = useState<string>('');
  const [destinationAddress, setDestinationAddress] = useState<string>('');
  const [resolvedAddress, setResolvedAddress] = useState<string>('');
  const [isResolvingAddress, setIsResolvingAddress] = useState<boolean>(false);

  // Отложенное разрешение адреса
  const resolveAddress = useCallback(async (address: string) => {
    if (!address.trim()) return;

    setIsResolvingAddress(true);
    try {
      const type = addressResolver.getInputType(address);
      
      if (type === 'Ethereum Address') {
        setResolvedAddress(address);
      } else {
        const resolved = await addressResolver.resolveAddress(address);
        setResolvedAddress(resolved);
      }
    } catch (error) {
      setErrors(prev => ({ 
        ...prev, 
        address: error instanceof Error ? error.message : 'Failed to resolve address'
      }));
    } finally {
      setIsResolvingAddress(false);
    }
  }, []);

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="number"
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="Enter SOL amount"
      />
      
      <input
        type="text"
        value={destinationAddress}
        onChange={(e) => setDestinationAddress(e.target.value)}
        placeholder="0x..., Basename, or ENS"
      />
      
      {resolvedAddress && resolvedAddress !== destinationAddress && (
        <div className="resolved-address">
          ✓ Resolved to: {resolvedAddress}
        </div>
      )}
      
      <button type="submit" disabled={!amount || !resolvedAddress}>
        Bridge to Base
      </button>
    </form>
  );
};
```

### Установка и разработка

```bash Terminal expandable
# Клонирование и настройка
git clone https://github.com/base/sol2base.git
cd sol2base
npm install --legacy-peer-deps

# Настройка окружения
cp env.template .env.local
# Добавьте учетные данные API платформы разработчиков Coinbase (CDP) для крана (опционально)

# Запуск сервера разработки
npm run dev
# Откройте http://localhost:3000
```

<Tip>
**Получите учетные данные API платформы разработчиков Coinbase (CDP) в [портале](https://portal.cdp.coinbase.com/projects/api-keys/client-key).**

В приведенном выше примере используется кран платформы разработчиков Coinbase для SOL.
Чтобы получить доступ к API крана, вы можете следовать инструкциям [здесь](https://docs.cdp.coinbase.com/faucets/introduction/welcome).
</Tip>

## Адреса контрактов

### Base Sepolia

```json
{
  "Bridge": "0xB2068ECCDb908902C76E3f965c1712a9cF64171E",
  "CrossChainERC20Factory": "0x58207331CBF8Af87BB6453b610E6579D9878e4EA",
  "WrappedSOL": "0xC5b9112382f3c87AFE8e1A28fa52452aF81085AD"
}
```

### Solana Devnet

```json
{
  "BridgeProgram": "HSvNvzehozUpYhRBuCKq3Fq8udpRocTmGMUYXmCSiCCc",
  "BaseRelayerProgram": "ExS1gcALmaA983oiVpvFSVohi1zCtAUTgsLj5xiFPPgL"
}
```

## Решение проблем

<AccordionGroup>
  <Accordion title="Транзакция не выполнена в Base">
    * Убедитесь в достаточном количестве ETH для комиссий за газ
    * Для токенов ERC20 сначала утвердите контракт моста с помощью `approve()`
    * Проверьте правильность адресов токенов и их соответствие ожидаемому формату
    * Убедитесь, что ваш приватный ключ правильно установлен в файле `.env`
  </Accordion>

  <Accordion title="Сообщение не появляется в Solana">
    * Подождите не менее 15 минут для ретрансляции сообщения
    * Убедитесь, что ваша транзакция на Base была успешной и содержала событие `MessageRegistered`
    * Проверьте, что вы используете правильную сеть (testnet/devnet)
    * Убедитесь, что мост Solana обработал номер блока Base
  </Accordion>

  <Accordion title="Ошибка проверки доказательства">
    * Убедитесь, что вы используете последний номер блока Base из моста Solana
    * Проверьте соответствие хэша сообщения исходной транзакции
    * Убедитесь, что доказательство было сгенерировано на правильной высоте блока
    * Проверьте правильность получения всех адресов аккаунтов
  </Accordion>

  <Accordion title="Автоматическая ретрансляция не работает">
    * Убедитесь в достаточном количестве SOL для оплаты комиссий ретрансляции
    * Проверьте правильность настройки программы ретранслятора Base
    * Убедитесь, что исходящее сообщение было успешно создано
    * Отслеживайте статус транзакций в обоих обозревателях Solana и Base
  </Accordion>
</AccordionGroup>

## Безопасность

<Warning>
  **Важные замечания по безопасности:**

  * Используйте только тестовые средства (SOL сети devnet Solana и ETH сети Sepolia Base)
  * Проверяйте все адреса перед использованием моста
  * Отслеживайте транзакции в обеих сетях
  * Обеспечьте безопасность ваших приватных ключей и никогда не делитесь ими
</Warning>

## Ресурсы

<CardGroup cols={2}>
  <Card title="Репозиторий GitHub" icon="github" href="https://github.com/base/bridge">
    Просмотр исходного кода и примеров
  </Card>

  <Card title="Обозреватель Solana" icon="magnifying-glass" href="https://explorer.solana.com/?cluster=devnet">
    Мониторинг транзакций в сети devnet Solana
  </Card>

  <Card title="Обозреватель Base Sepoliar" icon="magnifying-glass" href="https://sepolia.basescan.org/">
    Мониторинг транзакций в сети Base Sepolia
  </Card>

  <Card title="Поддержка в Discord" icon="discord" href="https://base.org/discord">
    Получите помощь от сообщества
  </Card>
</CardGroup>
